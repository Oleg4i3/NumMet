<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Опис проекту: Симуляція орбіт супутників</title>
  <!-- Підключення MathJax для рендерингу LaTeX-формул, включаючи матриці -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      line-height: 1.6;
      background-color: #f4f4f4;
      color: #333;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
    }
    h2 {
      margin-top: 40px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
    }
    h3 {
      margin-top: 20px;
    }
    p {
      margin: 10px 0;
    }
    ul, ol {
      margin: 15px 0;
      padding-left: 30px;
    }
    .math {
      background-color: #f9f9f9;
      padding: 15px;
      border-left: 4px solid #3498db;
      margin: 20px 0;
      overflow-x: auto;
    }
    .math p {
      margin: 5px 0;
    }
    code {
      background-color: #eee;
      padding: 2px 5px;
      border-radius: 3px;
    }
    pre {
      background-color: #f8f8f8;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
    }
    .section {
      margin-bottom: 40px;
    }
    /* Стилі для MathJax, щоб уникнути переповнення */
    .MathJax {
      font-size: 1em !important;
    }
    .mathjax-container {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
</head>
<body>
  <h1>Опис проекту: Симуляція орбіт супутників</h1>

  <div class="section">
    <h2>Мета проекту</h2>
    <p>Метою проекту є створення інтерактивного симулятора для моделювання орбітального руху супутників навколо Землі з метою оптимізації їхнього розміщення для забезпечення максимального покриття заданої території за мінімальний час. Симулятор дозволяє користувачам задавати параметри орбіт (висота, нахил, кількість супутників), налаштовувати зону покриття та застосовувати метод імітації відпалу для пошуку оптимальної конфігурації супутників. Проект спрямований на аналіз і візуалізацію орбітального руху в двох системах відліку (зоряній та земній), а також оцінку ефективності покриття земної поверхні.</p>
  </div>

  <div class="section">
    <h2>Можливі застосування</h2>
    <p>Симулятор має широкий спектр застосувань у різних галузях, де потрібне супутникове спостереження або зв’язок. Нижче наведено приклади можливих сценаріїв використання:</p>
    <ul>
      <li><strong>Метеорологія</strong>: Оптимізація розміщення метеорологічних супутників для моніторингу погодних умов, прогнозування штормів, ураганів та інших атмосферних явищ. Наприклад, симулятор може допомогти визначити орбіти для забезпечення щогодинного сканування тропічних регіонів для раннього виявлення циклону.</li>
      <li><strong>Рятувальні служби</strong>: Розробка конфігурацій супутників для швидкого виявлення сигналів лиха (наприклад, від маячків EPIRB або PLB) у віддалених регіонах, таких як океани чи гірські масиви. Симулятор дозволяє мінімізувати час до виявлення сигналу.</li>
      <li><strong>Моніторинг природних катастроф</strong>: Використання супутників для сканування зон лісових пожеж, повеней або вулканічної активності. Наприклад, симулятор може оптимізувати орбіти для щоденного покриття регіонів, схильних до пожеж, для раннього виявлення осередків займання.</li>
      <li><strong>Екологічний моніторинг</strong>: Супутники для спостереження за вирубкою лісів, забрудненням водойм або зміною льодового покриву. Симулятор допомагає забезпечити регулярне покриття критичних екологічних зон, наприклад, Амазонії чи Арктики.</li>
      <li><strong>Комунікації</strong>: Планування орбіт для супутників зв’язку, які забезпечують широкосмуговий доступ до Інтернету в сільських або віддалених регіонах. Симулятор може оптимізувати розташування для максимального покриття населених пунктів.</li>
      <li><strong>Аграрний сектор</strong>: Моніторинг сільськогосподарських угідь для оцінки стану посівів, вологості ґрунту або прогнозування врожаю. Симулятор дозволяє налаштувати орбіти для регулярного сканування великих аграрних регіонів.</li>
      <li><strong>Військові та безпекові задачі</strong>: Оптимізація орбіт для розвідувальних супутників, які забезпечують моніторинг стратегічних об’єктів або зон конфліктів із мінімальним часом між прольотами.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Математичні моделі та формули</h2>
    <p>Симулятор базується на ряді математичних моделей, які описують орбітальний рух, зону покриття, перетворення координат і відображення на карті. Нижче наведено детальний опис усіх формул із поясненням величин.</p>

    <h3>1. Період орбітального руху</h3>
    <div class="math mathjax-container">
      <p>Період обертання супутника навколо Землі розраховується за третім законом Кеплера:</p>
      <p>\[ T = 2\pi \sqrt{\frac{r^3}{GM}} \]</p>
      <p>де:</p>
      <ul>
        <li>\( T \) — період обертання (с),</li>
        <li>\( r = R_{\text{earth}} + h \) — відстань від центру Землі до супутника (м), де \( R_{\text{earth}} = 6371 \, \text{км} \) — радіус Землі, \( h \) — висота орбіти (км),</li>
        <li>\( G = 6.67430 \times 10^{-11} \, \text{м}^3 \text{кг}^{-1} \text{с}^{-2} \) — гравітаційна стала,</li>
        <li>\( M = 5.972 \times 10^{24} \, \text{кг} \) — маса Землі.</li>
      </ul>
      <p>Ця формула дозволяє визначити, скільки часу потрібно супутнику для одного повного оберту навколо Землі.</p>
    </div>

    <h3>2. Радіус зони покриття</h3>
    <div class="math mathjax-container">
      <p>Радіус зони покриття на поверхні Землі залежить від висоти орбіти та мінімального кута підйому (\(\epsilon\)):</p>
      <p>\[ \cos(\rho + \epsilon) = \frac{R_{\text{earth}}}{r} \cos(\epsilon) \]</p>
      <p>\[ \rho = \arccos\left(\frac{R_{\text{earth}}}{r} \cos(\epsilon)\right) - \epsilon \]</p>
      <p>\[ \gamma = \arcsin\left(\frac{r}{R_{\text{earth}}} \sin(\rho)\right) \]</p>
      <p>\[ R_{\text{cov}} = R_{\text{earth}} \gamma \]</p>
      <p>де:</p>
      <ul>
        <li>\( \epsilon \) — мінімальний кут підйому (рад),</li>
        <li>\( \rho \) — кутовий радіус конуса видимості супутника,</li>
        <li>\( \gamma \) — кутовий радіус зони покриття на поверхні Землі,</li>
        <li>\( R_{\text{cov}} \) — лінійний радіус зони покриття (км),</li>
        <li>\( r = R_{\text{earth}} + h \) — відстань від центру Землі до супутника (км).</li>
      </ul>
      <p>Ця модель визначає область на поверхні Землі, яку може спостерігати супутник за заданим мінімальним кутом підйому.</p>
    </div>

    <h3>3. Рівняння орбіт та їх перетворення</h3>
    <div class="math mathjax-container">
      <p>Положення супутника в орбітальній площині задається у двовимірних координатах як вектор:</p>
      <p>\[ \mathbf{r}_{\text{orb}} = \begin{pmatrix} x_{\text{orb}} \\ y_{\text{orb}} \end{pmatrix} = \begin{pmatrix} r \cos(\theta) \\ r \sin(\theta) \end{pmatrix} \]</p>
      <p>де:</p>
      <ul>
        <li>\( r = R_{\text{earth}} + h \) — радіус орбіти,</li>
        <li>\( \theta = \omega t + \phi_0 \) — кутова фаза, де \( \omega = \frac{2\pi}{T} \) — кутова швидкість, \( \phi_0 \) — початкова фаза, \( t \) — час.</li>
      </ul>
      <p>Для переходу в тривимірну інерціальну систему (зоряну) застосовується матриця обертання, що враховує нахил орбіти (\( i \)) та довготу висхідного вузла (\( \Omega \)). Координати в зоряній системі:</p>
      <p>\[ \mathbf{r} = \begin{pmatrix} x \\ y \\ z \end{pmatrix} = \mathbf{R}_{\Omega} \mathbf{R}_i \begin{pmatrix} x_{\text{orb}} \\ y_{\text{orb}} \\ 0 \end{pmatrix} \]</p>
      <p>де матриці обертання:</p>
      <p>\[ \mathbf{R}_{\Omega} = \begin{pmatrix} \cos(\Omega) & -\sin(\Omega) & 0 \\ \sin(\Omega) & \cos(\Omega) & 0 \\ 0 & 0 & 1 \end{pmatrix}, \quad \mathbf{R}_i = \begin{pmatrix} 1 & 0 & 0 \\ 0 & \cos(i) & -\sin(i) \\ 0 & \sin(i) & \cos(i) \end{pmatrix} \]</p>
      <p>Повна матриця перетворення:</p>
      <p>\[ \mathbf{R} = \mathbf{R}_{\Omega} \mathbf{R}_i = \begin{pmatrix} \cos(\Omega) & -\sin(\Omega) \cos(i) & \sin(\Omega) \sin(i) \\ \sin(\Omega) & \cos(\Omega) \cos(i) & -\cos(\Omega) \sin(i) \\ 0 & \sin(i) & \cos(i) \end{pmatrix} \]</p>
      <p>Таким чином:</p>
      <p>\[ \begin{pmatrix} x \\ y \\ z \end{pmatrix} = \begin{pmatrix} \cos(\Omega) & -\sin(\Omega) \cos(i) & \sin(\Omega) \sin(i) \\ \sin(\Omega) & \cos(\Omega) \cos(i) & -\cos(\Omega) \sin(i) \\ 0 & \sin(i) & \cos(i) \end{pmatrix} \begin{pmatrix} r \cos(\theta) \\ r \sin(\theta) \\ 0 \end{pmatrix} \]</p>
      <p>У земній системі відліку враховується обертання Землі з кутовою швидкістю \( \omega_{\text{earth}} = \frac{2\pi}{T_{\text{earth}}} \), де \( T_{\text{earth}} = 86164.1 \, \text{с} \) (зоряна доба). Координати в земній системі:</p>
      <p>\[ \mathbf{r}_e = \begin{pmatrix} x_e \\ y_e \\ z_e \end{pmatrix} = \mathbf{R}_{\text{earth}}(t) \begin{pmatrix} x \\ y \\ z \end{pmatrix} \]</p>
      <p>де матриця обертання Землі:</p>
      <p>\[ \mathbf{R}_{\text{earth}}(t) = \begin{pmatrix} \cos(\omega_{\text{earth}} t) & \sin(\omega_{\text{earth}} t) & 0 \\ -\sin(\omega_{\text{earth}} t) & \cos(\omega_{\text{earth}} t) & 0 \\ 0 & 0 & 1 \end{pmatrix} \]</p>
      <p>Широта (\( \lambda \)) та довгота (\( \phi \)) супутника в земній системі розраховуються як:</p>
      <p>\[ \phi = \arctan2(y_e, x_e) \]</p>
      <p>\[ \lambda = \arctan2\left(z_e, \sqrt{x_e^2 + y_e^2}\right) \]</p>
      <p>де \( \arctan2 \) — функція, що враховує квадрант.</p>
      <p>Матрична форма дозволяє компактно описати перетворення координат і полегшує чисельну реалізацію в коді симулятора.</p>
    </div>

    <h3>4. Перетворення координат у проєкцію Меркатора</h3>
    <div class="math mathjax-container">
      <p>Для відображення положення супутника на карті використовується проєкція Меркатора. Координати (\( \lambda \), \( \phi \)) перетворюються на пікселі canvas:</p>
      <p>\[ p_x = \frac{\phi + 180}{360} \cdot \text{width} \]</p>
      <p>\[ p_y = \frac{\text{height}}{2} - \frac{\lambda}{180} \cdot \text{height} \]</p>
      <p>де:</p>
      <ul>
        <li>\( \phi \) — довгота (градуси, від -180 до 180),</li>
        <li>\( \lambda \) — широта (градуси, від -90 до 90),</li>
        <li>\( \text{width}, \text{height} \) — розміри canvas (пікселі).</li>
      </ul>
      <p>Ця проєкція забезпечує коректне відображення траєкторій і зон покриття на плоскій карті.</p>
    </div>

    <h3>5. Зона покриття (footprint)</h3>
    <div class="math mathjax-container">
      <p>Зона покриття супутника на поверхні Землі апроксимується як коло з кутовим радіусом \( \alpha = \frac{R_{\text{cov}}}{R_{\text{earth}}} \). Координати точок на межі зони покриття:</p>
      <p>\[ \lambda' = \arcsin\left(\sin(\lambda) \cos(\alpha) + \cos(\lambda) \sin(\alpha) \cos(\theta)\right) \]</p>
      <p>\[ \phi' = \phi + \arctan2\left(\sin(\theta) \sin(\alpha) \cos(\lambda), \cos(\alpha) - \sin(\lambda) \sin(\lambda')\right) \]</p>
      <p>де:</p>
      <ul>
        <li>\( (\lambda, \phi) \) — широта та довгота супутника,</li>
        <li>\( \alpha \) — кутовий радіус зони покриття,</li>
        <li>\( \theta \) — азимутальний кут (від 0 до \( 2\pi \)),</li>
        <li>\( (\lambda', \phi') \) — координати точок на межі зони покриття.</li>
      </ul>
      <p>Ці формули дозволяють побудувати полігон зони покриття для відображення на карті.</p>
    </div>

    <h3>6. Відсоток покриття</h3>
    <div class="math mathjax-container">
      <p>Відсоток покриття обчислюється як відношення покритих пікселів до загальної кількості пікселів у заданій зоні (обмеженій максимальною широтою \( \lambda_{\text{max}} \)):</p>
      <p>\[ \text{Coverage} = \frac{\sum_{\text{covered pixels}} w_i}{\sum_{\text{all pixels}} w_i} \cdot 100\% \]</p>
      <p>де \( w_i = \cos(\lambda_i) \) — ваговий коефіцієнт, що враховує зменшення площі при наближенні до полюсів.</p>
      <p>Це дозволяє оцінити, яка частина земної поверхні в межах \( \lambda_{\text{max}} \) покрита супутниками.</p>
    </div>
  </div>

  <div class="section">
    <h2>Обґрунтування методу оптимізації</h2>
    <p>Оптимізація конфігурації супутників (довготи висхідного вузла, початкової фази, нахилу орбіти) є складною задачею, оскільки цільова функція (час до досягнення цільового покриття) є нелінійною, мультимодальною та має численні локальні мінімуми. Нижче розглянуто вибір методу оптимізації, альтернативи, їх переваги та недоліки.</p>

    <h3>Чому не градієнтні методи?</h3>
    <p>Градієнтні методи, такі як градієнтний спуск, ефективні для гладких, унімодальних функцій із відомими похідними. Однак у цій задачі:</p>
    <ul>
      <li>Цільова функція (час покриття) не має аналітичного виразу для обчислення градієнта.</li>
      <li>Функція є мультимодальною, тобто має багато локальних мінімумів, що призводить до застрягання градієнтних методів у локальних оптимумах.</li>
      <li>Обчислення чисельного градієнта вимагає значних обчислювальних ресурсів, оскільки потрібні численні оцінки функції в сусідніх точках.</li>
    </ul>
    <p>Таким чином, градієнтні методи не підходять для цієї задачі через складність цільової функції та потребу в глобальній оптимізації.</p>

    <h3>Вибір глобальної оптимізації</h3>
    <p>Для пошуку глобального оптимуму в мультимодальному просторі параметрів необхідні методи глобальної оптимізації. Основні альтернативи:</p>
    <ul>
      <li><strong>Генетичні алгоритми</strong>:
        <ul>
          <li><strong>Переваги</strong>: Ефективні для мультимодальних функцій, дозволяють паралельне дослідження простору параметрів, відносно прості в реалізації.</li>
          <li><strong>Недоліки</strong>: Вимагають налаштування багатьох параметрів (розмір популяції, ймовірність мутації, кросовер), можуть бути повільними через велику кількість ітерацій, не завжди гарантують збіжність до глобального оптимуму.</li>
        </ul>
      </li>
      <li><strong>Метод рою часток (Particle Swarm Optimization)</strong>:
        <ul>
          <li><strong>Переваги</strong>: Простий у реалізації, ефективний для безперервних просторів, швидше за генетичні алгоритми в деяких задачах.</li>
          <li><strong>Недоліки</strong>: Може застрягати в локальних мінімумах, чутливий до початкових умов і параметрів (швидкість часток, інерція).</li>
        </ul>
      </li>
      <li><strong>Імітація відпалу (Simulated Annealing)</strong>:
        <ul>
          <li><strong>Переваги</strong>: Простий у реалізації, ефективний для мультимодальних функцій, дозволяє уникати локальних мінімумів завдяки механізму "стрибків" на ранніх ітераціях, потребує менше параметрів налаштування.</li>
          <li><strong>Недоліки</strong>: Може бути повільним для дуже великих просторів параметрів, ефективність залежить від вибору початкової температури та швидкості охолодження.</li>
        </ul>
      </li>
      <li><strong>Випадковий пошук</strong>:
        <ul>
          <li><strong>Переваги</strong>: Дуже простий, не потребує налаштувань.</li>
          <li><strong>Недоліки</strong>: Низька ефективність, не гарантує знаходження навіть локального оптимуму за розумний час.</li>
        </ul>
      </li>
    </ul>

    <h3>Чому обрано імітацію відпалу?</h3>
    <p>Метод імітації відпалу було обрано з таких причин:</p>
    <ul>
      <li><strong>Простота реалізації</strong>: Алгоритм потребує лише трьох основних параметрів (початкова температура, швидкість охолодження, максимальна кількість ітерацій), що спрощує його налаштування порівняно з генетичними алгоритмами.</li>
      <li><strong>Ефективність для мультимодальних функцій</strong>: Механізм випадкових стрибків на високих температурах дозволяє досліджувати різні регіони простору параметрів, уникаючи локальних мінімумів.</li>
      <li><strong>Гнучкість</strong>: Метод легко адаптується до змін у моделі, наприклад, додавання нових параметрів оптимізації (кут нахилу, ексцентриситет).</li>
      <li><strong>Обчислювальна ефективність</strong>: Для задачі з кількома супутниками (до 10) і відносно невеликим простором параметрів метод забезпечує розумну швидкість збіжності.</li>
    </ul>
    <p>Недоліки, такі як залежність від параметрів температури, мінімізуються шляхом їх інтерактивного налаштування через інтерфейс користувача.</p>

    <h3>Опис методу імітації відпалу</h3>
    <p>Імітація відпалу (Simulated Annealing) імітує процес охолодження металу, де частинки поступово втрачають енергію, досягаючи стану з мінімальною енергією. У контексті оптимізації:</p>
    <ul>
      <li><strong>Цільова функція</strong>: Час до досягнення цільового відсотка покриття земної поверхні.</li>
      <li><strong>Параметри</strong>: Довгота висхідного вузла (\( \Omega \)), початкова фаза (\( \phi_0 \)) для кожного супутника та нахил орбіти (\( i \)).</li>
      <li><strong>Алгоритм</strong>:
        <ol>
          <li>Ініціалізація початкового стану (випадкові \( \Omega \), \( \phi_0 \), \( i \)) та температури (\( T_0 \)).</li>
          <li>На кожній ітерації:
            <ul>
              <li>Генерується новий стан шляхом випадкової зміни одного параметра (наприклад, \( \Omega_i \to \Omega_i + \Delta \), де \( \Delta \) — випадкове зміщення).</li>
              <li>Обчислюється нова цільова функція (\( E_{\text{new}} \)) і різниця з поточною (\( \Delta E = E_{\text{new}} - E_{\text{current}} \)).</li>
              <li>Новий стан приймається, якщо \( \Delta E \leq 0 \) або з імовірністю \( \exp(-\Delta E / T) \), що дозволяє "стрибки" до гірших рішень на високих температурах.</li>
            </ul>
          </li>
          <li>Температура знижується за законом \( T \to T \cdot \alpha \), де \( \alpha \) — швидкість охолодження (наприклад, 0.95).</li>
          <li>Процес триває, поки \( T > T_{\text{min}} \) або не досягнуто максимальної кількості ітерацій.</li>
        </ol>
      </li>
      <li><strong>Результат</strong>: Найкращий знайдений стан (конфігурація супутників) із мінімальним часом покриття.</li>
    </ul>
    <p>У симуляторі користувач може налаштувати \( T_0 \) (початкова температура, за замовчуванням 100), \( \alpha \) (швидкість охолодження, 0.95) та максимальну кількість ітерацій (500), що забезпечує гнучкість у балансуванні між швидкістю та якістю оптимізації.</p>
  </div>

  <div class="section">
    <h2>Опис симулятора</h2>
    <h3>Інтерфейс користувача</h3>
    <p>Симулятор реалізований як веб-додаток із інтерактивним інтерфейсом, який включає:</p>
    <ul>
      <li><strong>Панель керування</strong>:
        <ul>
          <li>Кількість супутників (1–10).</li>
          <li>Висота орбіти (200–4000 км, повзунок).</li>
          <li>Нахил орбіти (0–180°, з опцією ретроградних орбіт).</li>
          <li>Мінімальний кут підйому (0–90°).</li>
          <li>Цільовий відсоток покриття (0–100%).</li>
          <li>Максимальна широта (0–90°).</li>
          <li>Швидкість симуляції (1–300).</li>
          <li>Параметри оптимізації: початкова температура (100–10000), швидкість охолодження (0.9–0.999), максимальна кількість ітерацій (100–2000).</li>
          <li>Чекбокси: показувати зону покриття, трасу покриття, траєкторії, ретроградні орбіти, земна/зоряна система відліку.</li>
          <li>Кнопки: Пауза/Відновити, Очистити мапу, Оптимізувати, Зберегти/Завантажити конфігурацію.</li>
        </ul>
      </li>
      <li><strong>Інформаційна панель</strong>:
        <ul>
          <li>Період орбіти (у добах і годинах).</li>
          <li>Відсоток покриття (%).</li>
          <li>Час до цільового покриття (у добах і годинах або "Не досягнуто").</li>
          <li>Прогрес оптимізації: поточна ітерація, найкращий час, прогрес-бар.</li>
        </ul>
      </li>
      <li><strong>Візуалізація</strong>:
        <ul>
          <li>Верхнє полотно (`mapCanvas`): Карта світу з траєкторіями супутників, зонами покриття та трасою покриття.</li>
          <li>Нижнє полотно (`orbitCanvas`): 3D-візуалізація орбіт у зоряній або земній системі відліку.</li>
        </ul>
      </li>
      <li><strong>Модальне вікно</strong>: Для редагування параметрів окремого супутника (довгота висхідного вузла, початкова фаза) при кліку на супутник у паузі.</li>
    </ul>

    <h3>Призначення основних функцій коду</h3>
    <p>Код у файлі `script.js` поділений на функції, кожна з яких виконує певну роль у симуляції. Основні функції:</p>
    <ul>
      <li><strong>`initializeSatellites(num, raanList, phaseList, inclinationRad)`</strong>:
        <p>Ініціалізує масив супутників із заданими параметрами (кількість, довгота висхідного вузла, початкова фаза, нахил). Скидає таймер симуляції, очищує трасу покриття.</p>
      </li>
      <li><strong>`getOrbitalPeriod(alt_km)`</strong>:
        <p>Обчислює період орбіти за формулою Кеплера на основі висоти орбіти.</p>
      </li>
      <li><strong>`getCoverageRadius(alt_km, min_elevation_deg)`</strong>:
        <p>Розраховує радіус зони покриття на основі висоти орбіти та мінімального кута підйому.</p>
      </li>
      <li><strong>`getCoverageFootprint(lat, lon, radius_km)`</strong>:
        <p>Генерує координати полігону зони покриття для заданого положення супутника та радіусу.</p>
      </li>
      <li><strong>`calculateCoveragePercentage()`</strong>:
        <p>Обчислює відсоток покриття, аналізуючи пікселі на трасі покриття з урахуванням вагового коефіцієнта \( \cos(\lambda) \).</p>
      </li>
      <li><strong>`calculateSatellitePosition(alt, inc, raan, theta, t, earthRot)`</strong>:
        <p>Розраховує 3D-координати супутника та його широту/довготу в земній системі відліку з урахуванням обертання Землі.</p>
      </li>
      <li><strong>`simulate()`</strong>:
        <p>Основна функція симуляції, яка оновлює позиції супутників, трасу покриття, відсоток покриття та викликає функції малювання (`drawMap`, `drawOrbit3D`).</p>
      </li>
      <li><strong>`drawMap(alt, min_elev)`</strong>:
        <p>Малює карту світу, траєкторії супутників, зони покриття та трасу покриття на верхньому полотні.</p>
      </li>
      <li><strong>`drawOrbit3D(earthRot, frameRotationAngle)`</strong>:
        <p>Візуалізує орбіти та положення супутників у 3D на нижньому полотні в зоряній або земній системі відліку.</p>
      </li>
      <li><strong>`showSatelliteParams(sat, index)`</strong>:
        <p>Відображає модальне вікно з параметрами супутника (редаговані: \( \Omega \), \( \phi_0 \); лише для читання: широта, довгота, радіус покриття тощо).</p>
      </li>
      <li><strong>`saveConfiguration()`</strong>:
        <p>Зберігає поточну конфігурацію (параметри симуляції та супутників) у JSON-файл.</p>
      </li>
      <li><strong>`loadConfiguration(event)`</strong>:
        <p>Завантажує конфігурацію з JSON-файлу та застосовує її до симулятора.</p>
      </li>
      <li><strong>`evaluateCoverageTime(raanList, phaseList, inclination)`</strong>:
        <p>Оцінює час до досягнення цільового покриття для заданої конфігурації супутників. Використовується в оптимізації.</p>
      </li>
      <li><strong>`simulatedAnnealing()`</strong>:
        <p>Реалізує алгоритм імітації відпалу для оптимізації параметрів супутників (\( \Omega \), \( \phi_0 \), \( i \)). Оновлює прогрес оптимізації та найкращий час.</p>
      </li>
    </ul>
    <p>Ці функції взаємодіють через глобальні змінні (наприклад, масив `satellites`, canvas-контексти) та обробники подій для реакції на дії користувача (зміна повзунків, кліки по кнопках).</p>
  </div>

</body>
</html>
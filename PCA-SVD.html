<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BigData Simulator: PCA & Detection</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script>window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };</script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #eaeff2; margin: 0; padding: 10px; color: #2c3e50; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        
        /* TABS */
        .tabs { display: flex; gap: 5px; border-bottom: 2px solid #ddd; margin-bottom: 15px; }
        .tab-btn { padding: 10px 25px; cursor: pointer; border: none; background: #f8f9fa; font-size: 15px; font-weight: 600; color: #7f8c8d; border-radius: 6px 6px 0 0; transition: all 0.2s; }
        .tab-btn:hover { background: #e9ecef; color: #3498db; }
        .tab-btn.active { background: #3498db; color: white; }
        
        .tab-content { display: none; }
        .tab-content.active { display: grid; grid-template-columns: 280px 1fr; gap: 15px; }

        /* CONTROLS */
        .controls { background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef; height: fit-content; font-size: 0.9em; }
        .viz { min-height: 550px; display: flex; flex-direction: column; }
        
        h2 { margin-top: 0; color: #2c3e50; font-size: 1.2rem; border-bottom: 2px solid #3498db; display: inline-block; padding-bottom: 5px; margin-bottom: 10px; }
        
        .btn { width: 100%; padding: 10px; margin-bottom: 8px; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold; font-size: 0.9rem; transition: 0.2s; }
        .btn:hover { opacity: 0.9; }
        .btn-primary { background: #3498db; }
        .btn-danger { background: #e74c3c; } 
        .btn-success { background: #27ae60; }
        .btn-warning { background: #f39c12; }
        
        label { display: block; margin-top: 10px; font-weight: 600; margin-bottom: 4px; color: #34495e; }
        input[type="range"], select { width: 100%; cursor: pointer; padding: 4px; border-radius: 4px; border: 1px solid #ccc; }
        
        .info-box { background: #eef7fb; border-left: 4px solid #3498db; padding: 10px; font-size: 0.85em; margin-top: 15px; line-height: 1.4; border-radius: 4px; }

        /* COMPACT DASHBOARD FOR TAB 3 */
        .img-dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 4px; 
            width: 100%;
            height: 600px;
        }
        .dash-card {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .dash-plot { width: 100%; height: 100%; }
        
        /* Plot sizing */
        #plot1 { width: 100%; height: 550px; }
		
		
		
		/* –ù–æ–≤–∏–π –∫–ª–∞—Å –¥–ª—è –±–ª–æ–∫—É —Ç–µ–æ—Ä—ñ—ó –Ω–∞ –≤—Å—é —à–∏—Ä–∏–Ω—É */
.theory-block {
    grid-column: 1 / -1; /* –†–æ–∑—Ç—è–≥—É—î –Ω–∞ –≤—Å—é —à–∏—Ä–∏–Ω—É —Å—ñ—Ç–∫–∏ */
    background: #fff;
    border-left: 5px solid #2c3e50; /* –¢–µ–º–Ω—ñ—à–∏–π –∫–æ–ª—ñ—Ä –¥–ª—è "–∞–∫–∞–¥–µ–º—ñ—á–Ω–æ—Å—Ç—ñ" */
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    margin-top: 10px;
}

.theory-block summary {
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    color: #2c3e50;
    margin-bottom: 10px;
}

.theory-content {
    margin-top: 15px;
    font-size: 0.95em;
    line-height: 1.6;
    color: #444;
    border-top: 1px solid #eee;
    padding-top: 15px;
}
    </style>
</head>
<body>

<div class="container">
    <h1 style="text-align: center; margin-bottom: 15px; color: #2c3e50; font-size: 1.5rem;">–ß–∏—Å–µ–ª—å–Ω—ñ –º–µ—Ç–æ–¥–∏ –≤ Big Data: PCA & Detection</h1>
    
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('tab1')">1. –ì–µ–æ–º–µ—Ç—Ä—ñ—è</button>
        <button class="tab-btn" onclick="switchTab('tab2')">2. Live –ï–ö–ì</button>
        <button class="tab-btn" onclick="switchTab('tab3')">3. Image Defects</button>
    </div>

    <div id="tab1" class="tab-content active">
        <div class="controls">
            <h2>–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –î–∞–Ω–∏—Ö</h2>
            <button class="btn btn-primary" onclick="Tab1.generate()">üîÑ –ù–æ–≤–∞ —Ö–º–∞—Ä–∞ —Ç–æ—á–æ–∫</button>
            <button class="btn btn-danger" onclick="Tab1.addAnomaly()">‚ö†Ô∏è –î–æ–¥–∞—Ç–∏ –≤–∏–ø–∞–¥–∫–æ–≤–∏–π –≤–∏–∫–∏–¥</button>
            
            <label>–ö–æ—Ä–µ–ª—è—Ü—ñ—è (–ù–∞—Ö–∏–ª —Ç—Ä–µ–Ω–¥—É):</label>
            <input type="range" id="t1-slope" min="-2" max="2" step="0.1" value="0.8" oninput="Tab1.generate()">
            
            <label>–†–æ–∑–∫–∏–¥ (–î–∏—Å–ø–µ—Ä—Å—ñ—è —à—É–º—É):</label>
            <input type="range" id="t1-spread" min="0.1" max="2.5" step="0.1" value="0.8" oninput="Tab1.generate()">
            
            <label>–ü–æ—Ä—ñ–≥ –∞–Ω–æ–º–∞–ª—ñ—ó ($Threshold$): <span id="t1-val">2.0</span></label>
            <input type="range" id="t1-thresh" min="0.5" max="5" step="0.1" value="2.0" oninput="Tab1.update()">

            <div class="info-box">
                <strong>–ì–µ–æ–º–µ—Ç—Ä–∏—á–Ω–∏–π –∑–º—ñ—Å—Ç:</strong>
                <p>1. –ú–∏ —à—É–∫–∞—î–º–æ –≤—ñ—Å—å $PC1$ (–∑–µ–ª–µ–Ω–∞), –≤–∑–¥–æ–≤–∂ —è–∫–æ—ó –¥–∞–Ω—ñ –º–∞—é—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É –¥–∏—Å–ø–µ—Ä—Å—ñ—é.</p>
                <p>2. –ê–Ω–æ–º–∞–ª—ñ—è –¥–µ—Ç–µ–∫—Ç—É—î—Ç—å—Å—è —á–µ—Ä–µ–∑ –≤—ñ–¥—Å—Ç–∞–Ω—å –≤—ñ–¥ —Ç–æ—á–∫–∏ –¥–æ —Ü—ñ—î—ó –ª—ñ–Ω—ñ—ó (–ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä).</p>
            </div>
        </div>
        <div class="viz">
            <div id="plot1"></div>
        </div>
		
		<details class="theory-block">
    <summary><strong>üéì –¢–µ–æ—Ä—ñ—è: –ú–µ—Ç–æ–¥ –ì–æ–ª–æ–≤–Ω–∏—Ö –ö–æ–º–ø–æ–Ω–µ–Ω—Ç (PCA)</strong></summary>
    <div style="margin-top: 10px; font-size: 0.9em; line-height: 1.6;">
        <p><strong>–°—É—Ç—å –º–µ—Ç–æ–¥—É:</strong> PCA (Principal Component Analysis) ‚Äî —Ü–µ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–µ –ª—ñ–Ω—ñ–π–Ω–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è, —è–∫–µ –ø—Ä–æ–µ–∫—Ç—É—î –¥–∞–Ω—ñ –≤ –Ω–æ–≤—É —Å–∏—Å—Ç–µ–º—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, –¥–µ –æ—Å—ñ (–≥–æ–ª–æ–≤–Ω—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏) –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω—ñ –∑–∞ –∑–º–µ–Ω—à–µ–Ω–Ω—è–º –¥–∏—Å–ø–µ—Ä—Å—ñ—ó.</p>
        
        <strong>–ê–ª–≥–æ—Ä–∏—Ç–º (–ß–∏—Å–µ–ª—å–Ω—ñ –º–µ—Ç–æ–¥–∏):</strong>
        <ol style="padding-left: 20px; margin: 5px 0;">
            <li><strong>–¶–µ–Ω—Ç—Ä—É–≤–∞–Ω–Ω—è:</strong> –í—ñ–¥–Ω—ñ–º–∞—î–º–æ —Å–µ—Ä–µ–¥–Ω—î –∑–Ω–∞—á–µ–Ω–Ω—è –≤—ñ–¥ –∫–æ–∂–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –¥–∞–Ω–∏—Ö: 
                $$X_{centered} = X - \mu$$
            </li>
            <li><strong>–ö–æ–≤–∞—Ä—ñ–∞—Ü—ñ–π–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è:</strong> –û–±—á–∏—Å–ª—é—î–º–æ –º–∞—Ç—Ä–∏—Ü—é $\Sigma$, —è–∫–∞ –æ–ø–∏—Å—É—î –∑–≤'—è–∑–æ–∫ –º—ñ–∂ –æ–∑–Ω–∞–∫–∞–º–∏:
                $$\Sigma = \frac{1}{n-1} X_{centered}^T X_{centered}$$
            </li>
            <li><strong>–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥:</strong> –†–æ–∑–≤'—è–∑—É—î–º–æ –∑–∞–¥–∞—á—É –Ω–∞ –≤–ª–∞—Å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è $\Sigma$:
                $$\Sigma v = \lambda v$$
                –î–µ $v$ ‚Äî –≤–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (–Ω–∞–ø—Ä—è–º–æ–∫ –æ—Å—ñ), –∞ $\lambda$ ‚Äî –≤–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ (–≤–µ–ª–∏—á–∏–Ω–∞ –¥–∏—Å–ø–µ—Ä—Å—ñ—ó –≤–∑–¥–æ–≤–∂ —Ü—ñ—î—ó –æ—Å—ñ).
            </li>
            <li><strong>–ü—Ä–æ–µ–∫—Ü—ñ—è:</strong> –î–ª—è –∑–Ω–∏–∂–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ –º–∏ –∑–∞–ª–∏—à–∞—î–º–æ –ª–∏—à–µ –≤–µ–∫—Ç–æ—Ä–∏ –∑ –Ω–∞–π–±—ñ–ª—å—à–∏–º–∏ $\lambda$.</li>
        </ol>

        <p><strong>–î–µ—Ç–µ–∫—Ç—É–≤–∞–Ω–Ω—è –∞–Ω–æ–º–∞–ª—ñ–π:</strong></p>
        <p>–ê–Ω–æ–º–∞–ª—ñ—è ‚Äî —Ü–µ —Ç–æ—á–∫–∞, —è–∫–∞ –ø–æ–≥–∞–Ω–æ –∞–ø—Ä–æ–∫—Å–∏–º—É—î—Ç—å—Å—è –º–æ–¥–µ–ª–ª—é. –ú–∏ –≤–∏–º—ñ—Ä—é—î–º–æ <em>Reconstruction Error</em> (–≤—ñ–¥—Å—Ç–∞–Ω—å –≤—ñ–¥ —Ç–æ—á–∫–∏ –¥–æ —ó—ó –ø—Ä–æ–µ–∫—Ü—ñ—ó –Ω–∞ –ø—ñ–¥–ø—Ä–æ—Å—Ç—ñ—Ä PCA). –í —Ç–µ—Ä–º—ñ–Ω–∞—Ö –ª—ñ–Ω—ñ–π–Ω–æ—ó –∞–ª–≥–µ–±—Ä–∏, —Ü–µ –Ω–æ—Ä–º–∞ –ø—Ä–æ–µ–∫—Ü—ñ—ó –Ω–∞ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–µ –¥–æ–ø–æ–≤–Ω–µ–Ω–Ω—è.</p>
        
        <p><strong>–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –≤ Big Data:</strong> –°—Ç–∏—Å–Ω–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø–µ—Ä–µ–¥ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è–º, –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –±–∞–≥–∞—Ç–æ–≤–∏–º—ñ—Ä–Ω–∏—Ö –¥–∞–Ω–∏—Ö (t-SNE, UMAP —è–∫ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è), –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –µ—Ç–∞–ø –¥–ª—è K-Means –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—ó.</p>
    </div>
</details>
		
		
    </div>

    <div id="tab2" class="tab-content">
        <div class="controls">
            <h2>Live –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥</h2>
            <button class="btn btn-success" id="btn-ecg-start" onclick="Tab2.toggle()">‚ñ∂ –°—Ç–∞—Ä—Ç / –ü–∞—É–∑–∞</button>
            <button class="btn btn-warning" onclick="Tab2.reset()">‚èÆ –†–µ—Å—Ç–∞—Ä—Ç —Å–∏—Å—Ç–µ–º–∏</button>
            
            <label>–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –∞–Ω–∞–ª—ñ–∑—É:</label>
            <select id="t2-features-select" onchange="Tab2.reset()">
                <option value="rt">R-Peak vs T-Wave (Pos Corr)</option>
                <option value="rw">Ampl vs Width (Neg Corr)</option>
            </select>
            <p style="font-size:0.8em; color:#777; margin-top:2px;">*–î–ª—è "Ampl vs Width" –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ï–∫—Å—Ç—Ä–∞—Å–∏—Å—Ç–æ–ª—É</p>

            <label>–®–≤–∏–¥–∫—ñ—Å—Ç—å —Å–∏–º—É–ª—è—Ü—ñ—ó:</label>
            <input type="range" id="t2-speed" min="1" max="10" step="1" value="4">

            <hr style="border: 0; border-top: 1px solid #ddd; margin: 10px 0;">

            <label>–¢–∏–ø –ø–∞—Ç–æ–ª–æ–≥—ñ—ó:</label>
            <select id="t2-pathology-type">
                <option value="invertedT">1. –Ü–Ω–≤–µ—Ä—Å—ñ—è T-–∑—É–±—Ü—è</option>
                <option value="stElev">2. –ï–ª–µ–≤–∞—Ü—ñ—è ST</option>
                <option value="pvc">3. –ï–∫—Å—Ç—Ä–∞—Å–∏—Å—Ç–æ–ª–∞ (PVC)</option>
                <option value="noise">4. –ê—Ä—Ç–µ—Ñ–∞–∫—Ç / –®—É–º</option>
            </select>
            <button class="btn btn-danger" style="margin-top:5px;" onclick="Tab2.injectPathology()">‚ö° –î–æ–¥–∞—Ç–∏ –ø–∞—Ç–æ–ª–æ–≥—ñ—é</button>
            
            <label>–ß—É—Ç–ª–∏–≤—ñ—Å—Ç—å –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞:</label>
            <input type="range" id="t2-thresh" min="2" max="15" step="0.5" value="6">
            
            <div class="info-box">
                <p><strong>–ü–æ—Ä–∞–¥–∞:</strong> –ï–∫—Å—Ç—Ä–∞—Å–∏—Å—Ç–æ–ª–∞ (PVC) ‚Äî —Ü–µ —à–∏—Ä–æ–∫–µ —ñ —Ä–∞–Ω–Ω—î —Å–∫–æ—Ä–æ—á–µ–Ω–Ω—è. –í–æ–Ω–æ —ñ–¥–µ–∞–ª—å–Ω–æ –¥–µ—Ç–µ–∫—Ç—É—î—Ç—å—Å—è —á–µ—Ä–µ–∑ –ø–∞—Ä—É –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ "Ampl vs Width".</p>
            </div>
        </div>
        <div class="viz" style="gap: 10px;">
            <div id="plot2-signal" style="height: 280px; border:1px solid #eee; border-radius:4px;"></div>
            <div id="plot2-features" style="height: 280px; border:1px solid #eee; border-radius:4px;"></div>
        </div>
		
		
		<details class="theory-block">
    <summary><strong>üéì –¢–µ–æ—Ä—ñ—è: –í—ñ–¥—Å—Ç–∞–Ω—å –ú–∞—Ö–∞–ª–∞–Ω–æ–±—ñ—Å–∞</strong></summary>
    <div style="margin-top: 10px; font-size: 0.9em; line-height: 1.6;">
        <p><strong>–ü—Ä–æ–±–ª–µ–º–∞ –ï–≤–∫–ª—ñ–¥–æ–≤–æ—ó –≤—ñ–¥—Å—Ç–∞–Ω—ñ:</strong> –£ –ø—Ä–æ—Å—Ç–æ—Ä—ñ –æ–∑–Ω–∞–∫ –∑–º—ñ–Ω–Ω—ñ —á–∞—Å—Ç–æ –∫–æ—Ä–µ–ª—é—é—Ç—å (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∑—Ä—ñ—Å—Ç —ñ –≤–∞–≥–∞). –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∑–≤–∏—á–∞–π–Ω–æ—ó –≤—ñ–¥—Å—Ç–∞–Ω—ñ $d(x, \mu) = ||x - \mu||$ —Ñ–æ—Ä–º—É—î "—Å—Ñ–µ—Ä–∏—á–Ω–∏–π" –ø–æ—Ä—ñ–≥, —è–∫–∏–π —ñ–≥–Ω–æ—Ä—É—î —Ñ–æ—Ä–º—É —Ö–º–∞—Ä–∏ –¥–∞–Ω–∏—Ö, —â–æ –ø—Ä–∏–∑–≤–æ–¥–∏—Ç—å –¥–æ –ø–æ–º–∏–ª–æ–∫ I —Ç–∞ II —Ä–æ–¥—É.</p>
        
        <strong>–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ –º–æ–¥–µ–ª—å:</strong>
        <p>–í—ñ–¥—Å—Ç–∞–Ω—å –ú–∞—Ö–∞–ª–∞–Ω–æ–±—ñ—Å–∞ –≤—Ä–∞—Ö–æ–≤—É—î –∫–æ–≤–∞—Ä—ñ–∞—Ü—ñ–π–Ω—É –º–∞—Ç—Ä–∏—Ü—é $S$ –¥–ª—è "–≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è" –ø—Ä–æ—Å—Ç–æ—Ä—É:</p>
        $$D_M(x) = \sqrt{(x - \mu)^T S^{-1} (x - \mu)}$$
        
        <strong>–ó–≤'—è–∑–æ–∫ –∑ –ª—ñ–Ω—ñ–π–Ω–æ—é –∞–ª–≥–µ–±—Ä–æ—é:</strong>
        <ul>
            <li>–ú–∞—Ç—Ä–∏—Ü—è $S^{-1}$ (Precision Matrix) –¥—ñ—î —è–∫ –º–µ—Ç—Ä–∏—á–Ω–∏–π —Ç–µ–Ω–∑–æ—Ä, —â–æ –¥–µ—Ñ–æ—Ä–º—É—î –ø—Ä–æ—Å—Ç—ñ—Ä —Ç–∞–∫, —â–æ–± –µ–ª—ñ–ø—Å —Ä–æ–∑—Å—ñ—é–≤–∞–Ω–Ω—è –ø–µ—Ä–µ—Ç–≤–æ—Ä–∏–≤—Å—è –Ω–∞ –∫–æ–ª–æ.</li>
            <li>–Ø–∫—â–æ $S = I$ (–æ–¥–∏–Ω–∏—á–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è, –¥–∞–Ω—ñ –Ω–µ–∫–æ—Ä–µ–ª—å–æ–≤–∞–Ω—ñ), —Ç–æ $D_M$ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–∞ –ï–≤–∫–ª—ñ–¥–æ–≤—É –≤—ñ–¥—Å—Ç–∞–Ω—å.</li>
        </ul>

        <strong>Data Stream Mining:</strong>
        <p>–£ –ø–æ—Ç–æ–∫–æ–≤–∏—Ö –¥–∞–Ω–∏—Ö (—è–∫ –ï–ö–ì –∞–±–æ –ª–æ–≥–∏ —Å–µ—Ä–≤–µ—Ä—ñ–≤) –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ $\mu$ —Ç–∞ $S$ –æ–Ω–æ–≤–ª—é—é—Ç—å—Å—è –¥–∏–Ω–∞–º—ñ—á–Ω–æ (online learning). –í–∏–∫–∏–¥–æ–º –≤–≤–∞–∂–∞—î—Ç—å—Å—è —Ç–æ—á–∫–∞, –¥–ª—è —è–∫–æ—ó $D_M^2 > \chi^2_{k, \alpha}$ (–ø–æ—Ä—ñ–≥ —Ö—ñ-–∫–≤–∞–¥—Ä–∞—Ç —Ä–æ–∑–ø–æ–¥—ñ–ª—É).</p>
        
        <p><strong>–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è:</strong> Fraud Detection (–ø–æ—à—É–∫ –Ω–µ—Ç–∏–ø–æ–≤–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π), Predictive Maintenance (–º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ç—É—Ä–±—ñ–Ω, –¥–≤–∏–≥—É–Ω—ñ–≤).</p>
    </div>
</details>
    </div>

    <div id="tab3" class="tab-content">
        <div class="controls">
            <h2>–í—ñ–∑—É–∞–ª—å–Ω–∏–π –ö–æ–Ω—Ç—Ä–æ–ª—å</h2>
            
            <button class="btn btn-primary" style="margin-top:5px;" onclick="Tab3.generateNewDefect()">üì∑ –ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –∑—Ä–∞–∑–æ–∫</button>
            <p style="font-size:0.8em; color:#777; margin-top:2px;">(–ó–º—ñ–Ω—é—î –ø–æ–∑–∏—Ü—ñ—é –¥–µ—Ñ–µ–∫—Ç—É)</p>
            
            <label>–¢–∏–ø –ø–æ–≤–µ—Ä—Ö–Ω—ñ (–¢–µ–∫—Å—Ç—É—Ä–∞):</label>
            <select id="t3-texture-type" onchange="Tab3.recalc()">
                <option value="stripes">–°–∫–ª–∞–¥–Ω—ñ —Å–º—É–≥–∏</option>
                <option value="grid"> –°—ñ—Ç–∫–∞</option>
               
                <option value="wood">–®—É–º–Ω–∏–π –≥—Ä–∞–¥—ñ—î–Ω—Ç</option>
				<option value="waves">–•–≤–∏–ª—ñ</option>
            </select>

            <label>–†—ñ–≤–µ–Ω—å —à—É–º—É (Denoising):</label>
            <input type="range" id="t3-noise" min="0" max="0.3" step="0.01" value="0.05" oninput="Tab3.recalc()">
            
            <label>–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –º–æ–¥–µ–ª—ñ ($k$): <span id="t3-kval">1</span></label>
            <input type="range" id="t3-components" min="1" max="5" step="1" value="1" oninput="Tab3.recalc()">
            <p style="font-size:0.8em; color:#777; margin-top:2px;">*–î–ª—è "–°—ñ—Ç–∫–∏" —Å–ø—Ä–æ–±—É–π—Ç–µ k=2. –î–ª—è —Ö–≤–∏–ª—å –≤–∏—Å—Ç–∞—á–∏—Ç—å k=1.</p>
            
            <label>–ü–æ—Ä—ñ–≥ —á—É—Ç–ª–∏–≤–æ—Å—Ç—ñ:</label>
            <input type="range" id="t3-thresh" min="0.05" max="1.5" step="0.05" value="0.5" oninput="Tab3.recalc()">

            <div class="info-box">
                <strong>–Ø–∫ –ø—ñ–¥—ñ–±—Ä–∞—Ç–∏ $k$?</strong>
                <p>–Ø–∫—â–æ $k$ –∑–∞–º–∞–ª–µ ‚Äî –Ω–∞ –∫–∞—Ä—Ç—ñ –∞–Ω–æ–º–∞–ª—ñ–π –≤–∏–¥–Ω–æ —Ñ–æ–Ω (–Ω–µ–¥–æ–≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è).</p>
                <p>–Ø–∫—â–æ $k$ –∑–∞–≤–µ–ª–∏–∫–µ ‚Äî –¥–µ—Ñ–µ–∫—Ç –∑–Ω–∏–∫–∞—î (–ø–µ—Ä–µ–Ω–∞–≤—á–∞–Ω–Ω—è).</p>
            </div>
			
			
        </div>
        <div class="viz">
            <div class="img-dashboard">
                <div class="dash-card">
                    <div id="plot3-orig" class="dash-plot"></div>
                </div>
                <div class="dash-card">
                    <div id="plot3-recon" class="dash-plot"></div>
                </div>
                <div class="dash-card">
                    <div id="plot3-diff" class="dash-plot"></div>
                </div>
                <div class="dash-card">
                    <div id="plot3-scree" class="dash-plot"></div>
                </div>
            </div>
        </div>
		
		
			<details class="theory-block">
    <summary><strong>üéì –¢–µ–æ—Ä—ñ—è: Low-Rank Approximation (SVD)</strong></summary>
    <div style="margin-top: 10px; font-size: 0.9em; line-height: 1.6;">
        <p><strong>–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è —è–∫ –º–∞—Ç—Ä–∏—Ü—è:</strong> –£ Big Data –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∞–±–æ —á–∞—Å–æ–≤—ñ —Ä—è–¥–∏ —á–∞—Å—Ç–æ —Ä–æ–∑–≥–ª—è–¥–∞—é—Ç—å—Å—è —è–∫ –º–∞—Ç—Ä–∏—Ü—ñ $A$ —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ $m \times n$. –ú–∏ –ø—Ä–∏–ø—É—Å–∫–∞—î–º–æ, —â–æ "–∫–æ—Ä–∏—Å–Ω–∏–π —Å–∏–≥–Ω–∞–ª" (—Ñ–æ–Ω) –º–∞—î –Ω–∏–∑—å–∫–∏–π —Ä–∞–Ω–≥ (–º–∞–ª–æ –ª—ñ–Ω—ñ–π–Ω–æ –Ω–µ–∑–∞–ª–µ–∂–Ω–∏—Ö –ø–∞—Ç–µ—Ä–Ω—ñ–≤), –∞ —à—É–º/–¥–µ—Ñ–µ–∫—Ç–∏ ‚Äî –ø–æ–≤–Ω–∏–π —Ä–∞–Ω–≥.</p>
        
        <strong>–°–∏–Ω–≥—É–ª—è—Ä–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ (SVD):</strong>
        <p>–ë—É–¥—å-—è–∫—É –º–∞—Ç—Ä–∏—Ü—é –º–æ–∂–Ω–∞ —Ä–æ–∑–∫–ª–∞—Å—Ç–∏ —è–∫:</p>
        $$A = U \Sigma V^T = \sum_{i=1}^{r} \sigma_i u_i v_i^T$$
        <p>–¥–µ $\sigma_i$ ‚Äî —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ñ —á–∏—Å–ª–∞ (–≤–∞–≥–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏).</p>

        <strong>Eckart-Young-Mirsky Theorem:</strong>
        <p>–ù–∞–π–∫—Ä–∞—â–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –º–∞—Ç—Ä–∏—Ü—ñ $A$ —Ä–∞–Ω–≥–æ–º $k$ (–¥–µ $k < r$) –¥–æ—Å—è–≥–∞—î—Ç—å—Å—è —É—Å—ñ—á–µ–Ω–Ω—è–º —Å—É–º–∏ SVD:</p>
        $$A_k = \sum_{i=1}^{k} \sigma_i u_i v_i^T$$
        
        <strong>–ê–ª–≥–æ—Ä–∏—Ç–º –¥–µ—Ç–µ–∫—Ç—É–≤–∞–Ω–Ω—è (Robust PCA):</strong>
        <ol style="padding-left: 20px; margin: 5px 0;">
            <li>–†–æ–∑–∫–ª–∞–¥–∞—î–º–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è: $A = L + S$ (Low-rank + Sparse).</li>
            <li>$L$ (—Ñ–æ–Ω) –∞–ø—Ä–æ–∫—Å–∏–º—É—î—Ç—å—Å—è –ø–µ—Ä—à–∏–º–∏ $k$ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ ($A_k$).</li>
            <li>$S$ (–∞–Ω–æ–º–∞–ª—ñ—ó) –æ—Ç—Ä–∏–º—É—î–º–æ —è–∫ —Ä—ñ–∑–Ω–∏—Ü—é: $S = |A - A_k|$.</li>
        </ol>

        <p><strong>–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è:</strong> –û—á–∏—â–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å –≤—ñ–¥ —à—É–º—É, —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π–Ω—ñ —Å–∏—Å—Ç–µ–º–∏ (Netflix Matrix Factorization), Latent Semantic Analysis (NLP).</p>
    </div>
</details>
		

		
		
    </div>
</div>

<script>
    // === MATH ENGINE ===
    const MathCore = {
        mean: (pts) => {
            let n = pts.length, sx = 0, sy = 0;
            if(n===0) return [0,0];
            pts.forEach(p => { sx += p[0]; sy += p[1]; });
            return [sx/n, sy/n];
        },
        pca2D: (pts) => {
            if(pts.length < 2) return null;
            const mean = MathCore.mean(pts);
            let n = pts.length, xx=0, xy=0, yy=0;
            pts.forEach(p => {
                let dx = p[0]-mean[0], dy = p[1]-mean[1];
                xx += dx*dx; xy += dx*dy; yy += dy*dy;
            });
            let cov = [[xx/(n-1), xy/(n-1)], [xy/(n-1), yy/(n-1)]];
            let a = cov[0][0], b = cov[0][1], d = cov[1][1];
            let tr = a+d, det = a*d - b*b;
            let L1 = (tr + Math.sqrt(tr*tr - 4*det))/2;
            let L2 = (tr - Math.sqrt(tr*tr - 4*det))/2;
            let theta = (Math.abs(b) > 1e-9) ? Math.atan2(L1 - a, b) : ((a<d)?Math.PI/2:0);
            return { mean, L1, L2, angle: theta };
        },
        getEllipse: (mean, L1, L2, angle, scale) => {
            let rx = Math.sqrt(Math.max(0, L1)) * scale;
            let ry = Math.sqrt(Math.max(0, L2)) * scale;
            let x=[], y=[];
            for(let t=0; t<=2*Math.PI; t+=0.15) {
                let dx = rx*Math.cos(t), dy = ry*Math.sin(t);
                x.push(mean[0] + dx*Math.cos(angle) - dy*Math.sin(angle));
                y.push(mean[1] + dx*Math.sin(angle) + dy*Math.cos(angle));
            }
            return {x, y};
        }
    };

    function switchTab(id) {
        document.querySelectorAll('.tab-content').forEach(d => d.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        document.querySelector(`button[onclick="switchTab('${id}')"]`).classList.add('active');
        
        setTimeout(() => {
            if(id === 'tab1') Tab1.update();
            if(id === 'tab2') { Plotly.relayout('plot2-signal', {autosize: true}); Plotly.relayout('plot2-features', {autosize: true}); }
            if(id === 'tab3') Tab3.recalc();
        }, 100);
    }

    // === TAB 1: GEOMETRY ===
    const Tab1 = {
        data: [],
        generate: () => {
            Tab1.data = [];
            const slope = parseFloat(document.getElementById('t1-slope').value);
            const spread = parseFloat(document.getElementById('t1-spread').value);
            for(let i=0; i<50; i++) {
                let x = (Math.random()*16) - 8;
                let noise = (Math.random()-0.5) * spread * 4.0; 
                let y = slope * x + noise;
                Tab1.data.push([x, y]);
            }
            Tab1.update();
        },
        addAnomaly: () => {
            let x = (Math.random()*10) - 5;
            let slope = parseFloat(document.getElementById('t1-slope').value);
            let y = -slope * x + (Math.random()>0.5 ? 6 : -6);
            Tab1.data.push([x, y]);
            Tab1.update();
        },
        update: () => {
            const thresh = parseFloat(document.getElementById('t1-thresh').value);
            document.getElementById('t1-val').innerText = thresh.toFixed(1);
            const res = MathCore.pca2D(Tab1.data);
            if(!res) return;
            let normX=[], normY=[], anomX=[], anomY=[], shapes=[];
            Tab1.data.forEach(p => {
                let dx = p[0]-res.mean[0], dy = p[1]-res.mean[1];
                let scalar = dx*Math.cos(res.angle) + dy*Math.sin(res.angle);
                let projX = res.mean[0] + scalar*Math.cos(res.angle);
                let projY = res.mean[1] + scalar*Math.sin(res.angle);
                let dist = Math.sqrt(Math.pow(p[0]-projX, 2) + Math.pow(p[1]-projY, 2));
                let isAnom = dist > thresh;
                if(isAnom) { anomX.push(p[0]); anomY.push(p[1]); }
                else { normX.push(p[0]); normY.push(p[1]); }
                shapes.push({
                    type: 'line', x0: p[0], y0: p[1], x1: projX, y1: projY,
                    line: { color: isAnom?'#e74c3c':'#2ecc71', width: isAnom?2:1, dash: isAnom?'solid':'dot' }
                });
            });
            let pcLine = {
                x: [res.mean[0] - Math.cos(res.angle)*10, res.mean[0] + Math.cos(res.angle)*10],
                y: [res.mean[1] - Math.sin(res.angle)*10, res.mean[1] + Math.sin(res.angle)*10],
                mode: 'lines', name: 'PC1 (Trend)', line: {color:'#27ae60', width: 3}
            };
            Plotly.newPlot('plot1', [
                {x: normX, y: normY, mode:'markers', name:'Normal Data', marker:{color:'#3498db', size:9}},
                {x: anomX, y: anomY, mode:'markers', name:'Detected Anomaly', marker:{color:'#e74c3c', size:13, symbol:'x'}},
                pcLine
            ], { 
                title: '–ü—Ä–æ–µ–∫—Ü—ñ—è –Ω–∞ –ø—ñ–¥–ø—Ä–æ—Å—Ç—ñ—Ä (PCA)', shapes: shapes, margin:{t:40,b:40,l:40,r:20},
                xaxis: {range:[-12,12], title: 'Variable X', showgrid: true}, 
                yaxis: {range:[-12,12], title: 'Variable Y', scaleanchor: "x", scaleratio: 1, showgrid: true} 
            });
        }
    };

    // === TAB 2: LIVE ECG ===
    const Tab2 = {
        isRunning: false,
        dataQ: [],
        beats: [],
        time: 0,
        activeAnomaly: null,
        currentBeatIsAnomaly: false,
        phase: 0,
        cycleLen: 80,
        currentBeatRand: 0, 
        init: () => {
            Tab2.currentBeatRand = Math.random();
            for(let i=0; i<300; i++) Tab2.step();
            Tab2.draw();
        },
        reset: () => {
            Tab2.isRunning = false;
            document.getElementById('btn-ecg-start').innerText = "‚ñ∂ –°—Ç–∞—Ä—Ç";
            Tab2.dataQ = [];
            Tab2.beats = [];
            Tab2.time = 0;
            Tab2.phase = 0;
            Tab2.activeAnomaly = null;
            Tab2.init();
        },
        toggle: () => {
            Tab2.isRunning = !Tab2.isRunning;
            document.getElementById('btn-ecg-start').innerText = Tab2.isRunning ? "‚è∏ –ü–∞—É–∑–∞" : "‚ñ∂ –°—Ç–∞—Ä—Ç";
            if(Tab2.isRunning) Tab2.loop();
        },
        injectPathology: () => {
            Tab2.activeAnomaly = document.getElementById('t2-pathology-type').value;
        },
        step: () => {
            Tab2.time++;
            Tab2.phase++;
            if(Tab2.phase === 1) {
                Tab2.currentBeatIsAnomaly = (Tab2.activeAnomaly !== null);
                Tab2.currentBeatRand = (Math.random() - 0.5); 
            }
            let y = 0;
            let t = Tab2.phase;
            let rand = Tab2.currentBeatRand; 
            y += (Math.random()-0.5) * 0.05;
            let ampMod = 1.0 + rand * 0.3; 
            
            if(Tab2.activeAnomaly === 'noise') {
                if(t > 30 && t < 50) y += (Math.random()-0.5) * 3.0; 
                else y += (Math.random()-0.5) * 0.2;
            } else if (Tab2.activeAnomaly === 'pvc') {
                if (t > 20 && t < 60) {
                     y += 2.0 * Math.exp(-Math.pow(t-40, 2)/50); 
                     y -= 0.5 * Math.exp(-Math.pow(t-60, 2)/30);
                }
            } else {
                if(t > 10 && t < 25) y += 0.15 * Math.exp(-Math.pow(t-18, 2)/10);
                if(t > 30 && t < 40) {
                     y -= 0.1 * ampMod * Math.exp(-Math.pow(t-32, 2)/2);
                     y += 1.5 * ampMod * Math.exp(-Math.pow(t-35, 2)/2);
                     y -= 0.2 * ampMod * Math.exp(-Math.pow(t-38, 2)/2);
                }
                if(Tab2.activeAnomaly === 'stElev' && t >= 37 && t < 60) y += 0.5; 
                let tAmp = 0.25 * ampMod; 
                if(t > 50 && t < 75) {
                    if(Tab2.activeAnomaly === 'invertedT') y -= 0.4 * Math.exp(-Math.pow(t-60, 2)/40);
                    else y += tAmp * Math.exp(-Math.pow(t-60, 2)/40);
                }
            }
            Tab2.dataQ.push({x: Tab2.time, y: y});
            if(Tab2.dataQ.length > 300) Tab2.dataQ.shift();
            if(Tab2.phase >= Tab2.cycleLen) {
                Tab2.processLastBeat();
                Tab2.phase = 0;
                Tab2.activeAnomaly = null; 
            }
        },
        processLastBeat: () => {
            let rawBeat = Tab2.dataQ.slice(Tab2.dataQ.length - Tab2.cycleLen).map(p => p.y);
            if(rawBeat.length < Tab2.cycleLen) return;
            let rPeak = Math.max(...rawBeat);
            let tStart = Math.floor(Tab2.cycleLen * 0.6);
            let tSum = rawBeat.slice(tStart).reduce((a,b)=>a+b,0);
            let widthBase = 10 - (Tab2.currentBeatRand * 2); 
            let width = widthBase + (Math.random()-0.5);
            if(Tab2.currentBeatIsAnomaly && document.getElementById('t2-pathology-type').value === 'pvc') {
                width = 25; 
            }
            let mode = document.getElementById('t2-features-select').value;
            let features = (mode === 'rt') ? [rPeak, tSum] : [rPeak, width];
            Tab2.beats.push({ features: features, time: Tab2.time, isAnomaly: Tab2.currentBeatIsAnomaly });
            if(Tab2.beats.length > 50) Tab2.beats.shift();
        },
        loop: () => {
            if(!Tab2.isRunning) return;
            const speed = parseInt(document.getElementById('t2-speed').value);
            for(let i=0; i<speed; i++) Tab2.step(); 
            Tab2.draw();
            requestAnimationFrame(Tab2.loop);
        },
        draw: () => {
            let xData = Tab2.dataQ.map(p => p.x);
            let yData = Tab2.dataQ.map(p => p.y);
            let thresh = parseFloat(document.getElementById('t2-thresh').value);
            let mode = document.getElementById('t2-features-select').value;
            let normalBeats = Tab2.beats.filter(b => !b.isAnomaly);
            let trainingSet = normalBeats.length > 2 ? normalBeats : Tab2.beats; 
            let pca = MathCore.pca2D(trainingSet.map(b => b.features));
            let shapes = [];
            if(pca) {
                Tab2.beats.forEach(b => {
                     if(b.time > xData[0] && b.time < xData[xData.length-1] + 100) {
                         let dx = b.features[0]-pca.mean[0], dy = b.features[1]-pca.mean[1];
                         let tx = dx*Math.cos(pca.angle) + dy*Math.sin(pca.angle);
                         let ty = -dx*Math.sin(pca.angle) + dy*Math.cos(pca.angle);
                         let L1 = Math.abs(pca.L1) < 0.001 ? 0.001 : Math.abs(pca.L1);
                         let L2 = Math.abs(pca.L2) < 0.001 ? 0.001 : Math.abs(pca.L2);
                         let distSq = (tx*tx)/L1 + (ty*ty)/L2;
                         if(distSq > thresh) {
                             shapes.push({
                                 type: 'rect', x0: b.time - Tab2.cycleLen, x1: b.time, 
                                 y0: -2, y1: 3, fillcolor: 'rgba(231, 76, 60, 0.3)', line: {width:0}
                             });
                         }
                     }
                });
            }
            Plotly.react('plot2-signal', [{
                x: xData, y: yData, mode: 'lines', line: {color: '#2c3e50', width: 2}
            }], {
                title: 'Live ECG Signal', margin: {t:30,b:20,l:30,r:10},
                xaxis: { showticklabels: false }, yaxis: { range: [-1.5, 3.0] },
                shapes: shapes
            });
            if(!pca) return;
            let normX=[], normY=[], anomX=[], anomY=[];
            let ellipse = MathCore.getEllipse(pca.mean, pca.L1, pca.L2, pca.angle, Math.sqrt(thresh));
            Tab2.beats.forEach(b => {
                 let dx = b.features[0]-pca.mean[0], dy = b.features[1]-pca.mean[1];
                 let tx = dx*Math.cos(pca.angle) + dy*Math.sin(pca.angle);
                 let ty = -dx*Math.sin(pca.angle) + dy*Math.cos(pca.angle);
                 let L1 = Math.abs(pca.L1) < 0.001 ? 0.001 : Math.abs(pca.L1);
                 let L2 = Math.abs(pca.L2) < 0.001 ? 0.001 : Math.abs(pca.L2);
                 let distSq = (tx*tx)/L1 + (ty*ty)/L2;
                 if(distSq > thresh) { anomX.push(b.features[0]); anomY.push(b.features[1]); }
                 else { normX.push(b.features[0]); normY.push(b.features[1]); }
            });
            let xTitle = mode === 'rt' ? 'R-Peak Amplitude' : 'QRS Amplitude';
            let yTitle = mode === 'rt' ? 'T-Wave Energy' : 'QRS Width (ms)';
            Plotly.react('plot2-features', [
                {x: normX, y: normY, mode:'markers', name:'Normal', marker:{color:'#3498db', size:6}},
                {x: anomX, y: anomY, mode:'markers', name:'Pathology', marker:{color:'red', size:10, symbol:'x'}},
                {x: ellipse.x, y: ellipse.y, mode:'lines', name:'Boundary', line:{color:'#f39c12', dash:'dot'}}
            ], {
                title: 'Feature Space', margin: {t:30,b:40,l:50,r:10}, 
                showlegend: false, xaxis: {title: xTitle}, yaxis: {title: yTitle}
            });
        }
    };

    // === TAB 3: IMAGE DEFECTS (PERSISTENT STATE) ===
    const Tab3 = {
        size: 30,
        original: [],
        recon: [],
        diff: [],
        
        // Persist anomaly state independently
        state: { defectType: 0, defX: 15, defY: 15 },

        generateNewDefect: () => {
            // Randomize state only when this is called
            Tab3.state.defectType = Math.floor(Math.random() * 3);
            Tab3.state.defX = 5 + Math.floor(Math.random() * 20);
            Tab3.state.defY = 5 + Math.floor(Math.random() * 20);
            Tab3.recalc();
        },

        recalc: () => {
            const k = parseInt(document.getElementById('t3-components').value);
            const noiseLvl = parseFloat(document.getElementById('t3-noise').value);
            const type = document.getElementById('t3-texture-type').value;
            document.getElementById('t3-kval').innerText = k;

            // 1. GENERATE TEXTURE using saved state for defect
            Tab3.original = [];
            for(let i=0; i<Tab3.size; i++) {
                let row = [];
                for(let j=0; j<Tab3.size; j++) {
                    let bg = 0;
                    // --- Textures with different Rank complexities ---
                    if(type === 'waves') {
                        // Rank ~1
                        bg = (i+j)/Tab3.size + Math.sin(i/4)*0.5;
                    } else if (type === 'grid') {
                        // Rank ~2 (sin(i) + sin(j))
                        bg = Math.sin(i/2) + Math.sin(j/2);
                    } else if (type === 'stripes') {
                        // Rank > 2 (Mixed Diagonal Frequencies)
                        bg = Math.sin((i+j)/3) + Math.sin((i-j)/5)*0.5;
                    } else if (type === 'wood') {
                        bg = (i+j)/20 + Math.random()*0.2;
                    }

                    // --- Apply Saved Defect ---
                    let isDefect = false;
                    let { defectType, defX, defY } = Tab3.state;
                    
                    if(defectType === 0) { // Spot
                         isDefect = (Math.pow(i-defX,2) + Math.pow(j-defY,2) < 9);
                    } else if (defectType === 1) { // Horizontal/Vertical Line
                         isDefect = (Math.abs(i-defX) < 1 && Math.abs(j-defY) < 6);
                    } else { // Block/Cluster
                         isDefect = (Math.abs(i-defX) < 3 && Math.abs(j-defY) < 3);
                    }

                    let defectVal = isDefect ? 2.5 : 0; 
                    let noise = (Math.random()-0.5) * noiseLvl * 10; 
                    row.push(bg + defectVal + noise);
                }
                Tab3.original.push(row);
            }

            // 2. PCA Logic
            let data = Tab3.original;
            let meanVec = new Array(Tab3.size).fill(0);
            for(let j=0; j<Tab3.size; j++) {
                let s=0; for(let i=0; i<Tab3.size; i++) s+=data[i][j];
                meanVec[j] = s/Tab3.size;
            }
            let centered = data.map(row => row.map((v,j) => v - meanVec[j]));

            let cov = Array(Tab3.size).fill(0).map(()=>Array(Tab3.size).fill(0));
            for(let i=0; i<Tab3.size; i++) {
                for(let j=i; j<Tab3.size; j++) {
                    let s=0; for(let r=0; r<Tab3.size; r++) s+=centered[r][i]*centered[r][j];
                    cov[i][j] = cov[j][i] = s/(Tab3.size-1);
                }
            }

            let vectors = [];
            let vals = [];
            let currCov = JSON.parse(JSON.stringify(cov));

            for(let comp=0; comp<k; comp++) {
                let v = Array(Tab3.size).fill(0).map(()=>Math.random());
                for(let iter=0; iter<30; iter++) {
                    let nv = Array(Tab3.size).fill(0);
                    for(let r=0; r<Tab3.size; r++) 
                        for(let c=0; c<Tab3.size; c++) nv[r]+=currCov[r][c]*v[c];
                    let mag = Math.sqrt(nv.reduce((a,b)=>a+b*b,0));
                    if(mag < 1e-9) break;
                    v = nv.map(x=>x/mag);
                }
                let lambda = 0;
                for(let r=0; r<Tab3.size; r++) {
                    let rs=0; for(let c=0; c<Tab3.size; c++) rs+=currCov[r][c]*v[c];
                    lambda += v[r]*rs;
                }
                vectors.push(v);
                vals.push(lambda);
                for(let r=0; r<Tab3.size; r++)
                    for(let c=0; c<Tab3.size; c++) currCov[r][c] -= lambda*v[r]*v[c];
            }

            // 3. RECONSTRUCT
            Tab3.recon = [];
            Tab3.diff = [];
            for(let i=0; i<Tab3.size; i++) {
                let row = centered[i];
                let recRow = new Array(Tab3.size).fill(0);
                for(let vk=0; vk<k; vk++) {
                    let vec = vectors[vk];
                    let dot = row.reduce((s,x,idx)=>s+x*vec[idx],0);
                    for(let j=0; j<Tab3.size; j++) recRow[j] += dot*vec[j];
                }
                let finalRec = recRow.map((x,j) => x + meanVec[j]);
                Tab3.recon.push(finalRec);
                let diffRow = [];
                for(let j=0; j<Tab3.size; j++) diffRow.push(Math.abs(data[i][j] - finalRec[j]));
                Tab3.diff.push(diffRow);
            }
            Tab3.eigenvalues = vals;
            Tab3.updateViz();
        },

        updateViz: () => {
            const thresh = parseFloat(document.getElementById('t3-thresh').value);
            let displayDiff = Tab3.diff.map(row => row.map(v => v > thresh ? v : 0));

            const layout = { margin: {t:25,b:0,l:0,r:0}, xaxis:{visible:false}, yaxis:{visible:false, scaleanchor:"x"} };
            
            Plotly.newPlot('plot3-orig', [{z: Tab3.original, type: 'heatmap', colorscale: 'Viridis', showscale:false}], { ...layout, title: {text:'1. Input', font:{size:12}, y:0.95}});
            
            Plotly.newPlot('plot3-recon', [{z: Tab3.recon, type: 'heatmap', colorscale: 'Viridis', showscale:false}], { ...layout, title: {text:'2. Background Model', font:{size:12}, y:0.95}});
            
            Plotly.newPlot('plot3-diff', [{z: displayDiff, type: 'heatmap', colorscale: 'Jet', showscale:false, zmin:0, zmax:3}], { ...layout, title: {text:'3. Defect Map', font:{size:12}, y:0.95}});
            
            Plotly.newPlot('plot3-scree', [{
                x: Tab3.eigenvalues.map((_,i)=>'PC'+(i+1)), y: Tab3.eigenvalues, type:'bar', marker:{color:'#3498db'}
            }], { margin:{t:25,b:20,l:25,r:10}, xaxis:{title:''}, title: {text:'4. Variance', font:{size:12}, y:0.95} });
        }
    };

    window.onload = () => {
        Tab1.generate();
        Tab2.init();
        Tab3.generateNewDefect(); // Init first defect
    };
</script>
</body>
</html>
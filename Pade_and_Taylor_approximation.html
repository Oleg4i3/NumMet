<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—ó –¢–µ–π–ª–æ—Ä–∞ —Ç–∞ –ü–∞–¥–µ (–î–∏–Ω–∞–º—ñ—á–Ω–∏–π —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            padding: 20px; background-color: #f4f7f6; color: #333;
        }
        .main-container { width: 100%; max-width: 1200px; }
        .chart-container { 
            width: 100%; 
            margin-bottom: 20px;
            height: 75vh; 
        }
        .controls-container {
            display: flex; justify-content: space-between; width: 100%;
            flex-wrap: wrap; gap: 20px; padding: 20px; background-color: #fff;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px;
        }
        .control-group {
            display: flex; flex-direction: column; gap: 10px;
            flex-grow: 1; min-width: 220px; 
        }
        .formula-container {
            width: 100%; background-color: #fff; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); padding: 20px; margin-bottom: 20px;
        }
        .formula-display { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px; }
        .formula-item { flex-basis: 45%; font-size: 1.1em; line-height: 1.8; }
        .mjx-container { margin: 5px 0; }
        label { font-weight: 600; }
        input[type="range"] { width: 100%; }
        select, input[type="number"] {
            padding: 8px 12px; font-size: 1em; border: 1px solid #ccc; border-radius: 4px;
        }
        #orderValue { font-weight: 700; font-size: 1.2em; color: #007bff; }
        
        .accuracy-display {
            padding: 8px 0;
            font-size: 0.9em;
            line-height: 1.5;
        }
        #accuracyTitle {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        details {
            width: 100%; background-color: #fff; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-top: 20px;
        }
        summary {
            font-size: 1.3em; font-weight: 600; padding: 20px;
            cursor: pointer; color: #0056b3;
        }
        .theory-content {
            padding: 0 20px 20px 20px; line-height: 1.6;
            border-top: 1px solid #eee;
        }
    </style>
</head>
<body>

    <div class="main-container">

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="controls-container">
            <div class="control-group">
                <label for="functionSelect">1. –û–±–µ—Ä—ñ—Ç—å —Ñ—É–Ω–∫—Ü—ñ—é:</label>
                <select id="functionSelect">
                    <option value="atan">atan(x)</option>
                    <option value="sin">sin(x)</option>
                    <option value="cos">cos(x)</option>
                    <option value="exp"selected>exp(x)</option>
                    <option value="ln1px">ln(1+x)</option>
                    <option value="cbrt1px">‚àõ(1+x)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="orderSlider">2. –û–±–µ—Ä—ñ—Ç—å –ø–æ—Ä—è–¥–æ–∫ –ü–∞–¥–µ [k, k] (k): <span id="orderValue">4</span></label>
                <input type="range" id="orderSlider" min="1" max="5" value="4" step="1">
            </div>
            
            <div class="control-group">
                <label for="precisionInput">3. –¢–æ—á–Ω—ñ—Å—Ç—å $\epsilon = 10^{-p}$ (–≤–≤–µ–¥—ñ—Ç—å p):</label>
                <input type="number" id="precisionInput" value="3" min="1" max="15">
            </div>
            <div class="control-group accuracy-display">
                <div id="accuracyTitle">–Ü–Ω—Ç–µ—Ä–≤–∞–ª —Ç–æ—á–Ω–æ—Å—Ç—ñ $\epsilon = 10^{-3}$</div>
                <div id="accuracyResult">–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...</div>
            </div>
        </div>

        <div class="formula-container">
            <h3>–ê–Ω–∞–ª—ñ—Ç–∏—á–Ω–∏–π –≤–∏–≥–ª—è–¥ (–ü–æ—Ä—è–¥–æ–∫ k = <span id="formulaOrder">1</span>)</h3>
            <div class="formula-display">
                <div class="formula-item">
                    <strong>–†–æ–∑–∫–ª–∞–¥ –¢–µ–π–ª–æ—Ä–∞ $T_{2k}(x)$:</strong>
                    <div id="taylorFormula">$x$</div>
                </div>
                <div class="formula-item">
                    <strong>–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –ü–∞–¥–µ $P_{k,k}(x)$:</strong>
                    <div id="padeFormula">$x$</div>
                </div>
            </div>
        </div>
        
        <details>
            <summary>üìò –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –¥–æ–≤—ñ–¥–∫–∞: –†—è–¥–∏ –¢–µ–π–ª–æ—Ä–∞ —Ç–∞ –ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—ó –ü–∞–¥–µ</summary>
            <div class="theory-content">
                <h3>–†—è–¥ –¢–µ–π–ª–æ—Ä–∞</h3>
                <p>
                    –†—è–¥ –¢–µ–π–ª–æ—Ä–∞ ‚Äî —Ü–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è —Ñ—É–Ω–∫—Ü—ñ—ó —É –≤–∏–≥–ª—è–¥—ñ –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–æ—ó —Å—É–º–∏ —Å—Ç–µ–ø–µ–Ω—ñ–≤, —á–ª–µ–Ω–∏ —è–∫–æ—ó –æ–±—á–∏—Å–ª—é—é—Ç—å—Å—è –∑—ñ –∑–Ω–∞—á–µ–Ω—å –ø–æ—Ö—ñ–¥–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ—ó –≤ –æ–¥–Ω—ñ–π —Ç–æ—á—Ü—ñ (–∑–∞–∑–≤–∏—á–∞–π, $x=0$ - —Ü–µ –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è <strong>—Ä—è–¥–æ–º –ú–∞–∫–ª–æ—Ä–µ–Ω–∞</strong>).
                </p>
                <p>
                    –§–æ—Ä–º—É–ª–∞ –¥–ª—è —Ä—è–¥—É –ú–∞–∫–ª–æ—Ä–µ–Ω–∞:
                    $$ f(x) = \sum_{k=0}^{\infty} \frac{f^{(k)}(0)}{k!} x^k = f(0) + f'(0)x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + \dots $$
                </p>
                <p>
                    <strong>–ü–æ–ª—ñ–Ω–æ–º –¢–µ–π–ª–æ—Ä–∞ $T_n(x)$</strong> ‚Äî —Ü–µ —á–∞—Å—Ç–∫–æ–≤–∞ —Å—É–º–∞ —Ü—å–æ–≥–æ —Ä—è–¥—É (–¥–æ $n$-–≥–æ —á–ª–µ–Ω–∞). –í—ñ–Ω —î <strong>–Ω–∞–π–∫—Ä–∞—â–æ—é –ø–æ–ª—ñ–Ω–æ–º—ñ–∞–ª—å–Ω–æ—é</strong> –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—î—é —Ñ—É–Ω–∫—Ü—ñ—ó –ø–æ–±–ª–∏–∑—É —Ç–æ—á–∫–∏ $x=0$.
                </p>
                <ul>
                    <li><strong>–ü–µ—Ä–µ–≤–∞–≥–∏:</strong> –õ–µ–≥–∫–æ –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è, —è–∫—â–æ –ø–æ—Ö—ñ–¥–Ω—ñ –≤—ñ–¥–æ–º—ñ. –î—É–∂–µ —Ç–æ—á–Ω–∏–π –±—ñ–ª—è —Ü–µ–Ω—Ç—Ä—É —Ä–æ–∑–∫–ª–∞–¥—É ($x=0$).</li>
                    <li><strong>–ù–µ–¥–æ–ª—ñ–∫–∏:</strong> –ü–æ–≥–∞–Ω–æ –∞–ø—Ä–æ–∫—Å–∏–º—É—î —Ñ—É–Ω–∫—Ü—ñ—é –¥–∞–ª–µ–∫–æ –≤—ñ–¥ —Ü–µ–Ω—Ç—Ä—É. –Ø–∫ –ø–æ–ª—ñ–Ω–æ–º, –≤—ñ–Ω –Ω–µ –º–æ–∂–µ –º–æ–¥–µ–ª—é–≤–∞—Ç–∏ –Ω–µ-–ø–æ–ª—ñ–Ω–æ–º—ñ–∞–ª—å–Ω—É –ø–æ–≤–µ–¥—ñ–Ω–∫—É, —Ç–∞–∫—É —è–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ñ –∞—Å–∏–º–ø—Ç–æ—Ç–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —É `atan(x)`).</li>
                </ul>
                <hr>
                <h3>–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –ü–∞–¥–µ</h3>
                <p>
                    –ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –ü–∞–¥–µ ‚Äî —Ü–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è —Ñ—É–Ω–∫—Ü—ñ—ó —É –≤–∏–≥–ª—è–¥—ñ <strong>—Ä–∞—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó</strong> (–≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è –¥–≤–æ—Ö –ø–æ–ª—ñ–Ω–æ–º—ñ–≤) $R_{L,M}(x)$:
                    $$ R_{L,M}(x) = \frac{P_L(x)}{Q_M(x)} = \frac{a_0 + a_1 x + \dots + a_L x^L}{1 + b_1 x + \dots + b_M x^M} $$
                    (–ó–∞–∑–≤–∏—á–∞–π $b_0$ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—é—Ç—å –≤ 1 –¥–ª—è —É–Ω—ñ–∫–∞–ª—å–Ω–æ—Å—Ç—ñ).
                </p>
                
                <p>
                    <b>–Ø–∫ –∑–Ω–∞—Ö–æ–¥—è—Ç—å:</b>
                    <ol>
                        <li>—Ä—è–¥ –¢–µ–π–ª–æ—Ä–∞ $f(x) \approx c_0 + c_1 x + \dots + c_{L+M} x^{L+M}$.</li>
                        <li>–ú–∏ —à—É–∫–∞—î–º–æ –ø–æ–ª—ñ–Ω–æ–º–∏ $P_L(x)$ —Ç–∞ $Q_M(x)$ —Ç–∞–∫—ñ, —â–æ:
                            $$ (c_0 + c_1 x + \dots) \cdot (1 + b_1 x + \dots + b_M x^M) \approx (a_0 + a_1 x + \dots + a_L x^L) $$
                            ...–ø—Ä–∏—á–æ–º—É —Ä—ñ–≤–Ω—ñ—Å—Ç—å –º–∞—î –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏—Å—å –¥–ª—è –≤—Å—ñ—Ö –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤ –¥–æ —Å—Ç–µ–ø–µ–Ω—è $x^{L+M}$.
                        </li>
                        <li>–¶–µ –ø—Ä–∏–∑–≤–æ–¥–∏—Ç—å –¥–æ <b>—Å–∏—Å—Ç–µ–º–∏ –ª—ñ–Ω—ñ–π–Ω–∏—Ö –∞–ª–≥–µ–±—Ä–∞—ó—á–Ω–∏—Ö —Ä—ñ–≤–Ω—è–Ω—å (–°–õ–ê–†)</b> –¥–ª—è –Ω–µ–≤—ñ–¥–æ–º–∏—Ö –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤.</li>

                    </ol>
                </p>
                <ul>
                    <li><strong>–ü–µ—Ä–µ–≤–∞–≥–∏:</strong> –ß–∞—Å—Ç–æ –¥–∞—î –∫—Ä–∞—â—É –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—é, –Ω—ñ–∂ —Ä—è–¥ –¢–µ–π–ª–æ—Ä–∞, –ø—Ä–∏ —Ç—ñ–π —Å–∞–º—ñ–π –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤. –ú–æ–∂–µ –º–æ–¥–µ–ª—é–≤–∞—Ç–∏ –∞—Å–∏–º–ø—Ç–æ—Ç–∏ —Ç–∞ –ø–æ–ª—é—Å–∏, —â–æ —Ä–æ–±–∏—Ç—å –π–æ–≥–æ –Ω–∞–±–∞–≥–∞—Ç–æ –ø–æ—Ç—É–∂–Ω—ñ—à–∏–º –¥–ª—è –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—ó –ø–æ–∑–∞ –º–∞–ª–∏–º –æ–∫–æ–ª–æ–º.</li>
                    <li><strong>–ù–µ–¥–æ–ª—ñ–∫–∏:</strong> –û–±—á–∏—Å–ª–µ–Ω–Ω—è –∫–æ–µ—Ñ—ñ—Ü—ñ—ñ—î–Ω—Ç—ñ–≤ —Å–∫–ª–∞–¥–Ω—ñ—à–µ, –Ω—ñ–∂ –¥–ª—è –¢–µ–π–ª–æ—Ä–∞ (–≤–∏–º–∞–≥–∞—î —Ä–æ–∑–≤'—è–∑–∞–Ω–Ω—è –°–õ–ê–†).</li>
                </ul>
                <hr>
                <h3> –ü—Ä–∏–∫–ª–∞–¥–Ω–∏–π –∞—Å–ø–µ–∫—Ç: –ù–∞–≤—ñ—â–æ —Ü–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ?</h3>
                <p>
                    –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∏–π –ø—Ä–æ—Ü–µ—Å–æ—Ä (CPU) –≤–º—ñ—î –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ –ª–∏—à–µ –±–∞–∑–æ–≤—ñ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó: <strong>–¥–æ–¥–∞–≤–∞–Ω–Ω—è, –≤—ñ–¥–Ω—ñ–º–∞–Ω–Ω—è, –º–Ω–æ–∂–µ–Ω–Ω—è —Ç–∞ –¥—ñ–ª–µ–Ω–Ω—è</strong>. –í—ñ–Ω –Ω–µ –º–∞—î –≤–±—É–¥–æ–≤–∞–Ω–æ—ó "–º–∞–≥—ñ—á–Ω–æ—ó" —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Å–∏–Ω—É—Å—ñ–≤, –ª–æ–≥–∞—Ä–∏—Ñ–º—ñ–≤ —á–∏ –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç.
                </p>
                <p>
                    –°–∞–º–µ —Ç—É—Ç –ø–æ—Ç—Ä—ñ–±–Ω—ñ –ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—ó. –ö–æ–ª–∏ –≤–∏–∫–ª–∏–∫–∞—é—Ç—å <code>Math.sin(x)</code> —É JavaScript –∞–±–æ <code>sin(x)</code> —É C++ –∑ math.h, –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –Ω–∞—Å—Ç—É–ø–Ω–µ:
                </p>
                <ol>
                    <li>
                        <strong>–ó–≤–µ–¥–µ–Ω–Ω—è –¥—ñ–∞–ø–∞–∑–æ–Ω—É:</strong> –í—Ö—ñ–¥–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (–∞—Ä–≥—É–º–µ–Ω—Ç) <code>x</code> —Å–ø–æ—á–∞—Ç–∫—É –∑–≤–æ–¥–∏—Ç—å—Å—è –¥–æ –º–∞–ª–æ–≥–æ, –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –¥—ñ–∞–ø–∞–∑–æ–Ω—É. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è <code>sin(1000)</code>, –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ —Å–ø–æ—á–∞—Ç–∫—É –∑–Ω–∞–π–¥–µ –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è –≤ –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ $[-\pi, \pi]$.
                    </li>
                    <li>
                        <strong>–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è:</strong> –ü–æ—Ç—ñ–º –¥–æ —Ü—å–æ–≥–æ –∑–≤–µ–¥–µ–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç—É –∑–∞—Å—Ç–æ—Å–æ–≤—É—î—Ç—å—Å—è <strong>—Ä–∞—Ü—ñ–æ–Ω–∞–ª—å–Ω–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è</strong> (–¥—É–∂–µ —Å—Ö–æ–∂–∞ –Ω–∞ –ü–∞–¥–µ, –∞–±–æ —ñ–Ω—à—ñ –≤–∞—Ä—ñ–∞—Ü—ñ—ó, —è–∫-–æ—Ç –ø–æ–ª—ñ–Ω–æ–º–∏ –ß–µ–±–∏—à–µ–≤–∞), —è–∫–∞ –±—É–ª–∞ —Ä–æ–∑—Ä–∞—Ö–æ–≤–∞–Ω–∞ –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å.
                    </li>
                    <li>
                        <strong>–†–µ–∑—É–ª—å—Ç–∞—Ç:</strong> –¶—è –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –¥–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ—é —Ç–æ—á–Ω—ñ—Å—Ç—é (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–æ 15-–≥–æ –∑–Ω–∞–∫–∞ –ø—ñ—Å–ª—è –∫–æ–º–∏ –¥–ª—è 64-–±—ñ—Ç–Ω–∏—Ö —á–∏—Å–µ–ª) –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –ª–∏—à–µ –æ–ø–µ—Ä–∞—Ü—ñ—ó <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>.
                    </li>
                </ol>
            </div>
        </details>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            Chart.register(ChartZoom); 

            const ctx = document.getElementById('mainChart').getContext('2d');
            
            // --- –ï–ª–µ–º–µ–Ω—Ç–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è ---
            const functionSelect = document.getElementById('functionSelect');
            const slider = document.getElementById('orderSlider');
            const orderValue = document.getElementById('orderValue');
            const formulaOrder = document.getElementById('formulaOrder');
            const precisionInput = document.getElementById('precisionInput');
            const accuracyResultDiv = document.getElementById('accuracyResult');
            const accuracyTitle = document.getElementById('accuracyTitle');
            const taylorFormulaDiv = document.getElementById('taylorFormula');
            const padeFormulaDiv = document.getElementById('padeFormula');

            // --- –ü–ª–∞–≤–Ω—ñ—Å—Ç—å –≥—Ä–∞—Ñ—ñ–∫–∞ ---
            const xMin = -5;
            const xMax = 5;
            const numPoints = 500; 
            const xStep = (xMax - xMin) / (numPoints - 1);
            const xValues = Array.from({length: numPoints}, (_, i) => xMin + i * xStep);

            // --- –î–û–ü–û–ú–Ü–ñ–ù–Ü –§–£–ù–ö–¶–Ü–á ---
            function factorial(n) {
                if (n < 0) return Infinity; if (n === 0 || n === 1) return 1;
                let result = 1; for (let i = 2; i <= n; i++) { result *= i; }
                return result;
            }
            function solveLinearSystem(A, b) {
                const n = A.length;
                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) { if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) { maxRow = k; } }
                    [A[i], A[maxRow]] = [A[maxRow], A[i]]; [b[i], b[maxRow]] = [b[maxRow], b[i]]; 
                    let pivot = A[i][i]; if (Math.abs(pivot) < 1e-15) continue; 
                    for (let j = i; j < n; j++) { A[i][j] /= pivot; }
                    b[i] /= pivot;
                    for (let k = 0; k < n; k++) {
                        if (k !== i) {
                            let factor = A[k][i];
                            for (let j = i; j < n; j++) { A[k][j] -= factor * A[i][j]; }
                            b[k] -= factor * b[i];
                        }
                    }
                } return b;
            }
            function calculatePadeCoefficients(c, L, M) {
                if (M === 0) { return { a: c.slice(0, L + 1), b: [1] }; }
                let A = Array(M).fill(0).map(() => Array(M).fill(0)); let b_vec = Array(M).fill(0);
                for (let i = 0; i < M; i++) {
                    let k = L + 1 + i;
                    for (let j = 0; j < M; j++) { let c_index = k - (j + 1); A[i][j] = (c[c_index] || 0); }
                    b_vec[i] = -(c[k] || 0);
                }
                const b_coeffs = solveLinearSystem(A, b_vec); const B = [1, ...b_coeffs]; 
                let A_coeffs = Array(L + 1).fill(0);
                for (let k = 0; k <= L; k++) {
                    let sum = 0;
                    for (let j = 0; j <= k; j++) { if (j > M) continue; sum += (c[k - j] || 0) * B[j]; }
                    A_coeffs[k] = sum;
                } return { a: A_coeffs, b: B };
            }
            function createPolynomial(coeffs) {
                return (x) => {
                    let sum = 0;
                    for (let i = coeffs.length - 1; i >= 0; i--) { sum = sum * x + coeffs[i]; }
                    return sum;
                }
            }
            function createPadeFunction(padeCoeffs) {
                const P = createPolynomial(padeCoeffs.a); const Q = createPolynomial(padeCoeffs.b);
                return (x) => P(x) / Q(x);
            }
            function createPolynomialString(coeffs, N_max, useDecimals = false) {
                let terms = [];
                for (let i = 0; i <= N_max; i++) {
                    let c = coeffs[i] || 0; if (Math.abs(c) < 1e-10) continue; 
                    let sign = (c > 0) ? '+' : '-'; let val = Math.abs(c); let term = '';
                    if (i === 0) { term = (c > 0 ? '' : '-') + val.toFixed(3); } 
                    else {
                        let c_str = '';
                        if (Math.abs(val - 1) > 1e-3) {
                            c_str = useDecimals ? val.toFixed(3) : `c_{${i}}`; 
                        }
                        let x_str = (i === 1) ? 'x' : `x^{${i}}`;
                        term = ` ${sign} ${c_str} ${x_str} `;
                    }
                    if (i > 0 || terms.length > 0) terms.push(term);
                    else if (i===0) terms.push(term);
                }
                if (terms.length === 0) return '$0$';
                let str = terms.join('').trim();
                if (str.startsWith('+')) str = str.substring(1).trim();
                return `$${str}$`;
            }

            // --- –ë–ê–ó–ê –î–ê–ù–ò–• –§–£–ù–ö–¶–Ü–ô ---
            // –í–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å yRange –≤–∏–¥–∞–ª–µ–Ω–æ, –æ—Å–∫—ñ–ª—å–∫–∏ –º–∞—Å—à—Ç–∞–± —Ç–µ–ø–µ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π
            const functionDatabase = {
                'atan': {
                    label: 'atan(x)', sliderMax: 6,
                    func: (x) => Math.atan(x),
                    getTaylorCoefficients: (N) => {
                        let c = Array(N + 1).fill(0);
                        for (let k = 0; k <= N; k++) { if (k % 2 === 1) { c[k] = Math.pow(-1, (k - 1) / 2) / k; } } return c;
                    }
                },
                'sin': {
                    label: 'sin(x)', sliderMax: 6,
                    func: (x) => Math.sin(x),
                    getTaylorCoefficients: (N) => {
                        let c = Array(N + 1).fill(0);
                        for (let k = 0; k <= N; k++) { if (k % 2 === 1) { c[k] = Math.pow(-1, (k - 1) / 2) / factorial(k); } } return c;
                    }
                },
                'cos': {
                    label: 'cos(x)', sliderMax: 6,
                    func: (x) => Math.cos(x),
                    getTaylorCoefficients: (N) => {
                        let c = Array(N + 1).fill(0);
                        for (let k = 0; k <= N; k++) { if (k % 2 === 0) { c[k] = Math.pow(-1, k / 2) / factorial(k); } } return c;
                    }
                },
                'exp': {
                    label: 'exp(x)', sliderMax: 5,
                    func: (x) => Math.exp(x),
                    getTaylorCoefficients: (N) => {
                        let c = Array(N + 1).fill(0);
                        for (let k = 0; k <= N; k++) { c[k] = 1 / factorial(k); } return c;
                    }
                },
                'ln1px': {
                    label: 'ln(1+x)', sliderMax: 6,
                    func: (x) => (x > -1) ? Math.log(1 + x) : NaN,
                    getTaylorCoefficients: (N) => {
                        let c = Array(N + 1).fill(0);
                        for (let k = 1; k <= N; k++) { c[k] = Math.pow(-1, k - 1) / k; } return c;
                    }
                },
                'cbrt1px': {
                    label: '‚àõ(1+x)', sliderMax: 5,
                    func: (x) => (x > -1) ? Math.cbrt(1 + x) : NaN,
                    getTaylorCoefficients: (N) => {
                        let c = Array(N + 1).fill(0);
                        const alpha = 1/3; c[0] = 1; 
                        for (let k = 1; k <= N; k++) { c[k] = c[k - 1] * (alpha - (k - 1)) / k; } 
                        return c;
                    }
                }
            };
            
            // --- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≥—Ä–∞—Ñ—ñ–∫–∞ ---
            const chartConfig = {
                type: 'line', 
                data: { 
                    datasets: [
                        { label: '–û—Ä–∏–≥—ñ–Ω–∞–ª', data: [], borderColor: 'rgba(0, 0, 255, 0.3)', borderWidth: 3, pointRadius: 0, order: 0 },
                        { label: '–¢–µ–π–ª–æ—Ä', data: [], borderColor: 'rgba(255, 0, 0, 0.7)', borderWidth: 2, pointRadius: 0, borderDash: [5, 5], order: 1 },
                        { label: '–ü–∞–¥–µ', data: [], borderColor: 'rgba(0, 150, 0, 0.7)', borderWidth: 2, pointRadius: 0, borderDash: [10, 5], order: 2 }
                    ]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        x: { type: 'linear', title: { display: true, text: 'x' } }, 
                        y: { title: { display: true, text: 'y' } } 
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: { mode: 'index', intersect: false },
                        zoom: {
                            zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy', },
                            pan: { enabled: true, mode: 'xy', }
                        },
                        annotation: {
                            annotations: {
                                taylorNeg: { type: 'line', scaleID: 'x', value: 0, borderColor: 'red', borderWidth: 2, borderDash: [5, 5], display: false },
                                taylorPos: { type: 'line', scaleID: 'x', value: 0, borderColor: 'red', borderWidth: 2, borderDash: [5, 5], display: false },
                                padeNeg:   { type: 'line', scaleID: 'x', value: 0, borderColor: 'green', borderWidth: 2, borderDash: [5, 5], display: false },
                                padePos:   { type: 'line', scaleID: 'x', value: 0, borderColor: 'green', borderWidth: 2, borderDash: [5, 5], display: false }
                            }
                        }
                    },
                    animation: { duration: 0 }
                }
            };
            const myChart = new Chart(ctx, chartConfig);

            // --- –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ –¥–ª—è —Ñ—É–Ω–∫—Ü—ñ–π ---
            let currentTaylorFunc = (x) => x;
            let currentPadeFunc = (x) => x;
            let currentOriginalFunc = (x) => x;

            // --- –ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è ---
            function updatePlotAndFormulas() {
                let funcKey = functionSelect.value;
                let k = parseInt(slider.value); 
                
                const dbEntry = functionDatabase[funcKey];
                
                slider.max = dbEntry.sliderMax;
                if (k > dbEntry.sliderMax) { k = dbEntry.sliderMax; slider.value = k; }
                const N_taylor = 2 * k; 
                
                orderValue.textContent = k;
                formulaOrder.textContent = k;

                const taylorCoeffs = dbEntry.getTaylorCoefficients(N_taylor + 4); 
                const padeCoeffs = calculatePadeCoefficients(taylorCoeffs, k, k);

                currentOriginalFunc = dbEntry.func;
                currentTaylorFunc = createPolynomial(taylorCoeffs.slice(0, N_taylor + 1));
                currentPadeFunc = createPadeFunction(padeCoeffs);

                const isDomainLimited = (funcKey === 'ln1px' || funcKey === 'cbrt1px');
                
                const originalData = xValues.map(x => ({ x: x, y: currentOriginalFunc(x) }));
                myChart.data.datasets[0].data = originalData;
                
                myChart.data.datasets[1].data = xValues.map(x => {
                    if (isDomainLimited && x <= -1) return { x: x, y: NaN }; 
                    return { x: x, y: currentTaylorFunc(x) };
                });
                myChart.data.datasets[2].data = xValues.map(x => {
                    if (isDomainLimited && x <= -1) return { x: x, y: NaN }; 
                    return { x: x, y: currentPadeFunc(x) };
                });
                
                // === –í–ò–ó–ù–ê–ß–ï–ù–ù–Ø –ú–ê–°–®–¢–ê–ë–£ Y –ó–ê –°–ò–ù–¨–û–Æ –õ–Ü–ù–Ü–Ñ–Æ ===
                const yValues = originalData.map(d => d.y).filter(y => isFinite(y) && y !== null);
                let yMin = Math.min(...yValues);
                let yMax = Math.max(...yValues);
                const yPadding = (yMax - yMin) * 0.1; // 10% –≤—ñ–¥—Å—Ç—É–ø

                if (yPadding === 0) { // –í–∏–ø–∞–¥–æ–∫, —è–∫—â–æ –ª—ñ–Ω—ñ—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞
                    yMin -= 0.5;
                    yMax += 0.5;
                }

                myChart.options.scales.y.min = yMin - yPadding;
                myChart.options.scales.y.max = yMax + yPadding;
                // =============================================
                
                Object.values(myChart.options.plugins.annotation.annotations).forEach(ann => ann.display = false);

                if (myChart.isZoomedOrPanned()) {
                    myChart.update('none'); 
                } else {
                    myChart.resetZoom('none'); 
                    myChart.update('none');
                }
                
                const useDecimals = true; 
                taylorFormulaDiv.innerHTML = createPolynomialString(taylorCoeffs, N_taylor, useDecimals);
                padeFormulaDiv.innerHTML = `$$ \\frac{${createPolynomialString(padeCoeffs.a, k, useDecimals).slice(1,-1)}}{${createPolynomialString(padeCoeffs.b, k, useDecimals).slice(1,-1)}} $$`;
                
                if (window.MathJax) {
                    MathJax.typesetPromise([taylorFormulaDiv, padeFormulaDiv]).catch(console.error);
                }
                
                calculateAccuracy();
            }

            // --- –§—É–Ω–∫—Ü—ñ—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ç–æ—á–Ω–æ—Å—Ç—ñ ---
            let accuracyTimeout; 
            function calculateAccuracy() {
                clearTimeout(accuracyTimeout);
                
                accuracyTimeout = setTimeout(() => {
                    const p = parseInt(precisionInput.value);
                    if (isNaN(p)) return;
                    
                    const epsilon = Math.pow(10, -p);
                    const funcKey = functionSelect.value;
                    
                    accuracyTitle.innerHTML = `–Ü–Ω—Ç–µ—Ä–≤–∞–ª —Ç–æ—á–Ω–æ—Å—Ç—ñ $\epsilon = 10^{-${p}}$`;
                    if (window.MathJax) { MathJax.typesetPromise([accuracyTitle]).catch(console.error); }
                    accuracyResultDiv.innerHTML = "–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...";

                    setTimeout(() => {
                        const searchStep = 0.001;
                        const searchLimit = xMax;
                        
                        let x_taylor_pos = 0;
                        for (let x = 0; x <= searchLimit; x += searchStep) {
                            const error = Math.abs(currentOriginalFunc(x) - currentTaylorFunc(x));
                            if (error > epsilon || isNaN(error)) break; x_taylor_pos = x;
                        }
                        let x_taylor_neg = 0;
                        for (let x = 0; x >= -searchLimit; x -= searchStep) {
                            if ((funcKey === 'ln1px' || funcKey === 'cbrt1px') && x <= -1 + searchStep) break;
                            const error = Math.abs(currentOriginalFunc(x) - currentTaylorFunc(x));
                            if (error > epsilon || isNaN(error)) break; x_taylor_neg = x;
                        }
                        
                        let x_pade_pos = 0;
                        for (let x = 0; x <= searchLimit; x += searchStep) {
                            const error = Math.abs(currentOriginalFunc(x) - currentPadeFunc(x));
                            if (error > epsilon || isNaN(error)) break; x_pade_pos = x;
                        }
                        let x_pade_neg = 0;
                        for (let x = 0; x >= -searchLimit; x -= searchStep) {
                            if ((funcKey === 'ln1px' || funcKey === 'cbrt1px') && x <= -1 + searchStep) break;
                            const error = Math.abs(currentOriginalFunc(x) - currentPadeFunc(x));
                            if (error > epsilon || isNaN(error)) break; x_pade_neg = x;
                        }
                        
                        accuracyResultDiv.innerHTML = `
                            <span style="color: red;">‚ñ† –¢–µ–π–ª–æ—Ä: [${x_taylor_neg.toFixed(3)}, ${x_taylor_pos.toFixed(3)}]</span><br>
                            <span style="color: green;">‚ñ† –ü–∞–¥–µ: [${x_pade_neg.toFixed(3)}, ${x_pade_pos.toFixed(3)}]</span>
                        `;
                        
                        const ann = myChart.options.plugins.annotation.annotations;
                        ann.taylorNeg.value = x_taylor_neg; ann.taylorNeg.display = true;
                        ann.taylorPos.value = x_taylor_pos; ann.taylorPos.display = true;
                        ann.padeNeg.value = x_pade_neg;     ann.padeNeg.display = true;
                        ann.padePos.value = x_pade_pos;     ann.padePos.display = true;
                        
                        myChart.update('none'); 

                    }, 0); 
                }, 100); 
            }

            // --- –û–±—Ä–æ–±–Ω–∏–∫–∏ –ø–æ–¥—ñ–π ---
            slider.addEventListener('input', updatePlotAndFormulas);
            functionSelect.addEventListener('change', updatePlotAndFormulas);
            precisionInput.addEventListener('input', calculateAccuracy);

            // --- –ü–µ—Ä—à–∏–π –∑–∞–ø—É—Å–∫ ---
            updatePlotAndFormulas(); 
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice CNN Snake: Attention & Absolute Control</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #0f172a; --panel: #1e293b; --text: #f1f5f9; 
            --accent: #8b5cf6; /* Purple accent for new version */
            --success: #10b981; --danger: #ef4444; --warn: #f59e0b;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        header { padding: 10px 20px; background: var(--panel); border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; font-size: 1.2rem; color: var(--accent); }
        
        .workspace { display: grid; grid-template-columns: 320px 1fr 300px; gap: 10px; padding: 10px; height: calc(100vh - 60px); }
        
        .panel { background: var(--panel); border-radius: 8px; padding: 15px; overflow-y: auto; border: 1px solid #334155; display: flex; flex-direction: column; gap: 10px; }
        .panel h3 { margin-top: 0; border-bottom: 1px solid #475569; padding-bottom: 5px; font-size: 1rem; color: #94a3b8; }

        button { padding: 10px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; background: #334155; color: white; transition: 0.2s; }
        button:hover { background: #475569; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-rec { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; border: 1px solid #475569; }
        .btn-rec.recording { background: #fee2e2; color: #b91c1c; border-color: #ef4444; animation: pulse 1s infinite; }
        .count-badge { background: #0f172a; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }

        .btn-primary { background: var(--accent); } .btn-primary:hover { background: #7c3aed; }
        .btn-success { background: var(--success); color: #000; } .btn-success:hover { background: #059669; }
        .btn-warn { background: var(--warn); color: #000; }
        
        canvas { background: black; border-radius: 4px; width: 100%; }
        #spectrogramCanvas { height: 120px; image-rendering: pixelated; }
        #snakeCanvas { flex: 1; border: 2px solid #334155; }
        
        .pred-row { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; font-size: 0.9em; }
        .bar-bg { flex: 1; height: 8px; background: #334155; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s; }
        .pred-row.active .bar-fill { background: var(--success); }
        .pred-row.active { font-weight: bold; color: var(--success); }
        .pred-row.disabled { opacity: 0.3; }

        input[type=range] { width: 100%; accent-color: var(--accent); }
        select { width: 100%; padding: 8px; background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        .io-group { display: flex; gap: 5px; }
        .io-group button { flex: 1; font-size: 0.8em; }
    </style>
</head>
<body>

<header>
    <h1>üß† Voice Snake: Temporal Attention</h1>
    <div style="font-size: 0.8rem; color: #94a3b8;">Bottleneck=2 | Absolute Controls</div>
</header>

<div class="workspace">
    <div class="panel">
        <h3>1. –ü–∞—Ä–∞–º–µ—Ç—Ä–∏</h3>
        <label style="font-size: 0.8rem;">–§—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó:</label>
        <select id="actType">
            <option value="tanh" selected>Tanh (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)</option>
            <option value="relu">ReLU</option>
            <option value="linear">Linear</option>
        </select>

        <h3>2. –ó–±—ñ—Ä –∫–æ–º–∞–Ω–¥ (–ê–±—Å–æ–ª—é—Ç–Ω—ñ)</h3>
        
        <button id="btnRec0" class="btn-rec" onmousedown="startRec(0)" onmouseup="stopRec()" ontouchstart="startRec(0)" ontouchend="stopRec()">
            <span>‚¨ÜÔ∏è "–í–≥–æ—Ä—É"</span> <span id="cnt0" class="count-badge">0</span>
        </button>
        <button id="btnRec1" class="btn-rec" onmousedown="startRec(1)" onmouseup="stopRec()" ontouchstart="startRec(1)" ontouchend="stopRec()">
            <span>‚¨áÔ∏è "–í–Ω–∏–∑"</span> <span id="cnt1" class="count-badge">0</span>
        </button>
        <button id="btnRec2" class="btn-rec" onmousedown="startRec(2)" onmouseup="stopRec()" ontouchstart="startRec(2)" ontouchend="stopRec()">
            <span>‚¨ÖÔ∏è "–õ—ñ–≤–æ—Ä—É—á"</span> <span id="cnt2" class="count-badge">0</span>
        </button>
        <button id="btnRec3" class="btn-rec" onmousedown="startRec(3)" onmouseup="stopRec()" ontouchstart="startRec(3)" ontouchend="stopRec()">
            <span>‚û°Ô∏è "–ü—Ä–∞–≤–æ—Ä—É—á"</span> <span id="cnt3" class="count-badge">0</span>
        </button>
        
        <div style="margin-top: 5px;">
            <canvas id="spectrogramCanvas" width="32" height="32"></canvas>
        </div>

        <h3>3. –ù–∞–≤—á–∞–Ω–Ω—è (Attention)</h3>
        <button id="btnTrain" class="btn-primary" onclick="trainNetwork()">üöÄ –ù–∞–≤—á–∏—Ç–∏</button>
        
        <div id="latent-plot" style="height: 180px; margin-top:5px; border:1px solid #334155; border-radius:4px;"></div>
        <div id="loss-plot" style="height: 60px; margin-top:5px;"></div>
        
        <div class="io-group" style="margin-top:10px;">
            <button onclick="saveNetwork()" class="btn-success">üíæ Save</button>
            <button onclick="document.getElementById('fileInput').click()" style="background:#475569;">üìÇ Load</button>
            <input type="file" id="fileInput" style="display:none" onchange="loadNetwork(this)">
        </div>
    </div>

    <div class="panel" style="padding: 0; overflow: hidden; position: relative;">
        <canvas id="snakeCanvas"></canvas>
        <div id="gameOverlay" style="position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;">
            <h2 style="color: var(--accent);">–ü–∞—É–∑–∞</h2>
            <p>–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–°—Ç–∞—Ä—Ç/–ü–∞—É–∑–∞"</p>
        </div>
        <div style="position: absolute; top: 10px; right: 10px; font-size: 1.5rem; font-weight: bold; color: rgba(255,255,255,0.5);">
            Score: <span id="scoreVal" style="color:white">0</span>
        </div>
        <div style="position: absolute; bottom: 10px; left: 10px; font-size: 0.9rem; color: #94a3b8;">
            Speed: <span id="speedVal" style="color:white">0</span> | Friction: <span id="fricVal">5%</span>
        </div>
    </div>

    <div class="panel">
        <h3>üîç –ö–æ–Ω—Ç—Ä–æ–ª—å</h3>
        <button id="btnPause" class="btn-warn" onclick="togglePause()">‚èØÔ∏è –°—Ç–∞—Ä—Ç / –ü–∞—É–∑–∞</button>
        
        <div style="margin-top: 15px; border-top:1px solid #334155; padding-top:10px;">
            <label style="font-size:0.9rem; display:flex; justify-content:space-between;">
                <span>Noise Gate</span> <span id="gateVal">10%</span>
            </label>
            <input type="range" id="noiseGate" min="0" max="100" value="10" oninput="document.getElementById('gateVal').innerText = this.value + '%'">
            
            <label style="font-size:0.9rem; display:flex; justify-content:space-between; margin-top:10px;">
                <span>–¢–µ—Ä—Ç—è (Friction)</span> <span id="fricDisp">5%</span>
            </label>
            <input type="range" id="frictionSlider" min="1" max="20" value="5" oninput="updateFrictionUI(this.value)">

            <div style="height: 5px; background: #334155; border-radius: 2px; margin-top: 15px; overflow: hidden;">
                <div id="volBar" style="height: 100%; width: 0%; background: #ef4444; transition: width 0.1s;"></div>
            </div>
        </div>

        <div id="predictions" style="margin-top: 10px;"></div>
        <div style="margin-top: auto; border-top: 1px solid #334155; padding-top: 10px;">
            <div style="font-size: 0.8rem; color: #94a3b8;">CMD: <span id="lastCmd" style="color: var(--accent); font-weight: bold;">-</span></div>
        </div>
    </div>
</div>

<script>
/**
 * === MATH & LAYERS ===
 */
const Activations = {
    tanh: { fw: x => Math.tanh(x), bw: y => 1 - y * y },
    relu: { fw: x => x > 0 ? x : 0, bw: y => y > 0 ? 1 : 0 },
    sigmoid: { fw: x => 1 / (1 + Math.exp(-x)), bw: y => y * (1 - y) },
    linear: { fw: x => x, bw: y => 1 }
};

class Layer { constructor() { this.input=null; this.output=null; } forward(x){return x;} backward(g){return g;} }

/**
 * NEW: Temporal Attention Layer
 * Input: {w: Time, h: Freq, d: Channels, data: Float32Array}
 * Converts (Time x Features) -> (Features) using learnable attention weights over Time.
 */
class TemporalAttention extends Layer {
    constructor(featureDim) {
        super();
        // featureDim is h * d from the previous layer (flattened vertical slice)
        this.fDim = featureDim;
        // Learnable attention vector (query)
        this.attW = new Float32Array(featureDim).map(()=>Math.random()*0.1 - 0.05);
        this.attBias = 0;
        
        this.gradW = new Float32Array(featureDim);
        this.gradBias = 0;
    }

    forward(input) {
        this.input = input; // {w, h, d, data}
        const { w: timeSteps, h, d } = input;
        const sliceSize = h * d; // Size of one time column
        
        // 1. Calculate Score for each time step
        // Score[t] = Dot(Slice[t], W) + b
        this.scores = new Float32Array(timeSteps);
        let maxScore = -Infinity;

        for(let t=0; t<timeSteps; t++) {
            let dot = this.attBias;
            for(let i=0; i<sliceSize; i++) {
                dot += input.data[t*sliceSize + i] * this.attW[i];
            }
            this.scores[t] = dot;
            if(dot > maxScore) maxScore = dot;
        }

        // 2. Softmax over time (Stable)
        let sumExp = 0;
        this.weights = new Float32Array(timeSteps);
        for(let t=0; t<timeSteps; t++) {
            const ex = Math.exp(this.scores[t] - maxScore);
            this.weights[t] = ex;
            sumExp += ex;
        }
        for(let t=0; t<timeSteps; t++) this.weights[t] /= sumExp;

        // 3. Weighted Sum
        this.output = new Float32Array(sliceSize).fill(0);
        for(let t=0; t<timeSteps; t++) {
            const w = this.weights[t];
            for(let i=0; i<sliceSize; i++) {
                this.output[i] += input.data[t*sliceSize + i] * w;
            }
        }
        return this.output; // Returns 1D array of size sliceSize
    }

    backward(gradOutput) {
        // gradOutput is size sliceSize
        const { w: timeSteps, h, d } = this.input;
        const sliceSize = h * d;

        // 1. Gradient w.r.t Input and Attention Scores
        const gradInput = new Float32Array(this.input.data.length).fill(0);
        const gradScores = new Float32Array(timeSteps).fill(0);

        // dL/dSlice[t] = gradOutput * weight[t]
        // dL/dWeight[t] = dot(gradOutput, Slice[t])
        for(let t=0; t<timeSteps; t++) {
            let dotGradSlice = 0;
            for(let i=0; i<sliceSize; i++) {
                // Gradient flow to input features
                gradInput[t*sliceSize + i] += gradOutput[i] * this.weights[t];
                // Accumulate for dWeight/dScore calculation
                dotGradSlice += gradOutput[i] * this.input.data[t*sliceSize + i];
            }
            // Softmax derivative part 1 (pre-jacobian)
            gradScores[t] = dotGradSlice; 
        }

        // 2. Softmax Backward (Jacobian)
        // dL/dScore[i] = w[i] * ( dL/dw[i] - sum(dL/dw[k] * w[k]) )
        let sumGradW = 0;
        for(let t=0; t<timeSteps; t++) sumGradW += gradScores[t] * this.weights[t];
        
        const finalGradScores = new Float32Array(timeSteps);
        for(let t=0; t<timeSteps; t++) {
            finalGradScores[t] = this.weights[t] * (gradScores[t] - sumGradW);
        }

        // 3. Gradients for Parameters (W, b) and add Score grad to Input
        this.gradBias += finalGradScores.reduce((a,b)=>a+b, 0);
        
        for(let t=0; t<timeSteps; t++) {
            const scoreG = finalGradScores[t];
            for(let i=0; i<sliceSize; i++) {
                this.gradW[i] += this.input.data[t*sliceSize + i] * scoreG;
                // Add contribution from attention mechanism back to input
                gradInput[t*sliceSize + i] += this.attW[i] * scoreG; 
            }
        }

        return { ...this.input, data: gradInput };
    }
}

class Conv2D extends Layer {
    constructor(inChannels, outChannels, kernelSize=3) {
        super();
        this.inChannels = inChannels; this.outChannels = outChannels; this.k = kernelSize;
        const scale = Math.sqrt(2.0 / (inChannels * kernelSize * kernelSize));
        this.filters = new Float32Array(outChannels * inChannels * kernelSize * kernelSize).map(() => (Math.random() - 0.5) * 2 * scale);
        this.biases = new Float32Array(outChannels).fill(0);
        this.gradFilters = new Float32Array(this.filters.length); this.gradBiases = new Float32Array(this.biases.length);
        this.act = Activations.relu; 
    }
    forward(input) {
        this.input = input; const { w, h, d } = input;
        const outW = w - this.k + 1; const outH = h - this.k + 1;
        this.output = { w: outW, h: outH, d: this.outChannels, data: new Float32Array(outW * outH * this.outChannels) };
        for (let oc = 0; oc < this.outChannels; oc++) {
            for (let y = 0; y < outH; y++) {
                for (let x = 0; x < outW; x++) {
                    let sum = this.biases[oc];
                    for (let ic = 0; ic < d; ic++) {
                        for (let ky = 0; ky < this.k; ky++) {
                            for (let kx = 0; kx < this.k; kx++) {
                                sum += input.data[(ic * h + y + ky) * w + x + kx] * this.filters[((oc * d + ic) * this.k + ky) * this.k + kx];
                            }
                        }
                    }
                    this.output.data[(oc * outH + y) * outW + x] = this.act.fw(sum);
                }
            }
        }
        return this.output;
    }
    backward(gradOutput) {
        const { w: inW, h: inH, d: inD } = this.input; const { w: outW, h: outH, d: outD } = this.output;
        const gradInput = new Float32Array(inD * inH * inW).fill(0);
        this.gradFilters.fill(0); this.gradBiases.fill(0);
        for (let oc = 0; oc < outD; oc++) {
            for (let y = 0; y < outH; y++) {
                for (let x = 0; x < outW; x++) {
                    const idx = (oc * outH + y) * outW + x; const chain = gradOutput.data[idx] * this.act.bw(this.output.data[idx]);
                    this.gradBiases[oc] += chain;
                    for (let ic = 0; ic < inD; ic++) {
                        for (let ky = 0; ky < this.k; ky++) {
                            for (let kx = 0; kx < this.k; kx++) {
                                const inIdx = (ic * inH + y + ky) * inW + x + kx; const fIdx = ((oc * inD + ic) * this.k + ky) * this.k + kx;
                                this.gradFilters[fIdx] += this.input.data[inIdx] * chain; gradInput[inIdx] += this.filters[fIdx] * chain;
                            }
                        }
                    }
                }
            }
        }
        return { w: inW, h: inH, d: inD, data: gradInput };
    }
}

class MaxPool2x2 extends Layer {
    forward(input) {
        this.input = input; const { w, h, d } = input;
        const outW = Math.floor(w / 2); const outH = Math.floor(h / 2);
        this.output = { w: outW, h: outH, d: d, data: new Float32Array(outW * outH * d) };
        this.mask = new Int32Array(outW * outH * d); 
        for (let c = 0; c < d; c++) {
            for (let y = 0; y < outH; y++) {
                for (let x = 0; x < outW; x++) {
                    let maxVal = -Infinity; let maxIdx = -1;
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            const idx = (c * h + y * 2 + dy) * w + x * 2 + dx;
                            const val = input.data[idx]; if (val > maxVal) { maxVal = val; maxIdx = idx; }
                        }
                    }
                    const outIdx = (c * outH + y) * outW + x; this.output.data[outIdx] = maxVal; this.mask[outIdx] = maxIdx;
                }
            }
        }
        return this.output;
    }
    backward(gradOutput) {
        const gradInput = new Float32Array(this.input.data.length).fill(0);
        for (let i = 0; i < gradOutput.data.length; i++) gradInput[this.mask[i]] = gradOutput.data[i];
        return { ...this.input, data: gradInput };
    }
}

class Dense extends Layer {
    constructor(inSize, outSize, actName = 'relu') {
        super();
        this.inSize = inSize; this.outSize = outSize;
        const scale = Math.sqrt(2.0 / inSize);
        this.weights = new Float32Array(inSize * outSize).map(() => (Math.random() - 0.5) * 2 * scale);
        this.biases = new Float32Array(outSize).fill(0);
        this.gradW = new Float32Array(this.weights.length); this.gradB = new Float32Array(this.biases.length);
        this.setActivation(actName);
    }
    setActivation(name) { this.act = Activations[name] || Activations.relu; }
    forward(input) {
        this.input = input; this.output = new Float32Array(this.outSize);
        for (let i = 0; i < this.outSize; i++) {
            let sum = this.biases[i];
            for (let j = 0; j < this.inSize; j++) sum += input[j] * this.weights[i * this.inSize + j];
            this.output[i] = this.act.fw(sum);
        }
        return this.output;
    }
    backward(grad) {
        const gradIn = new Float32Array(this.inSize).fill(0);
        this.gradW.fill(0); this.gradB.fill(0);
        for (let i = 0; i < this.outSize; i++) {
            const chain = grad[i] * this.act.bw(this.output[i]); this.gradB[i] += chain;
            for (let j = 0; j < this.inSize; j++) {
                this.gradW[i * this.inSize + j] += this.input[j] * chain; gradIn[j] += this.weights[i * this.inSize + j] * chain;
            }
        }
        return gradIn;
    }
}

class SoftmaxLayer extends Layer {
    forward(input) {
        this.input = input; const max = Math.max(...input);
        const exps = input.map(v => Math.exp(v - max)); const sum = exps.reduce((a, b) => a + b, 0);
        this.output = exps.map(v => v / sum); return this.output;
    }
    backward(labelIndex) { const grad = new Float32Array(this.output); grad[labelIndex] -= 1; return grad; }
}

/**
 * === CNN MANAGER ===
 */
class CNN {
    constructor() { this.resetLayers('tanh'); this.learningRate = 0.01; }

    resetLayers(actName) {
        // Architecture: Conv -> Pool -> TemporalAttention -> Dense(2) -> Dense(4) -> Softmax
        // Input: 32x32. Conv(k=3): 30x30x4. Pool: 15x15x4.
        // Temporal Attention aggregates along the Time axis (15). 
        // Result size: 15(Freq) * 4(Channels) = 60 features.
        
        this.layers = [
            new Conv2D(1, 4, 3),        // 32x32 -> 30x30x4
            new MaxPool2x2(),           // 30x30 -> 15x15x4
            new TemporalAttention(60),  // Aggregates 15 steps -> 60 features (15h * 4d)
            new Dense(60, 2, actName),  // Latent (2)
            new Dense(2, 4, actName),   // Output (4)
            new SoftmaxLayer()
        ];
    }

    forward(inputData, returnLatent = false) {
        let x = { w: 32, h: 32, d: 1, data: inputData };
        x = this.layers[0].forward(x);
        x = this.layers[1].forward(x);
        x = this.layers[2].forward(x); // Returns 1D array (60)
        
        const latent = this.layers[3].forward(x);
        if (returnLatent) return latent;
        
        x = this.layers[4].forward(latent);
        return this.layers[5].forward(x);
    }

    train(inputData, labelIndex) {
        const output = this.forward(inputData);
        let grad = labelIndex;
        for (let i = this.layers.length - 1; i >= 0; i--) grad = this.layers[i].backward(grad);
        
        // Update weights
        for (const layer of this.layers) {
            if (layer.weights) {
                for (let i=0; i<layer.weights.length; i++) layer.weights[i] -= layer.gradW[i]*this.learningRate;
                for (let i=0; i<layer.biases.length; i++) layer.biases[i] -= layer.gradB[i]*this.learningRate;
            }
            if (layer.filters) {
                for (let i=0; i<layer.filters.length; i++) layer.filters[i] -= layer.gradFilters[i]*this.learningRate;
                for (let i=0; i<layer.biases.length; i++) layer.biases[i] -= layer.gradBiases[i]*this.learningRate;
            }
            if (layer.attW) { // Temporal Attention params
                for(let i=0; i<layer.attW.length; i++) layer.attW[i] -= layer.gradW[i]*this.learningRate;
                layer.attBias -= layer.gradBias*this.learningRate;
            }
        }
        return -Math.log(output[labelIndex] + 1e-7);
    }
}

/**
 * === AUDIO & APP STATE ===
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 64; 
analyser.smoothingTimeConstant = 0.4;

let net = new CNN();
let isPaused = true; // Start in paused state
let isRecording = false; 
let samples = []; 
// NEW LABELS
const labels = ["–í–≥–æ—Ä—É ‚¨ÜÔ∏è", "–í–Ω–∏–∑ ‚¨áÔ∏è", "–õ—ñ–≤–æ—Ä—É—á ‚¨ÖÔ∏è", "–ü—Ä–∞–≤–æ—Ä—É—á ‚û°Ô∏è"];
const labelColors = ['#ef4444', '#3b82f6', '#f59e0b', '#22c55e'];
const SPECTRO_SIZE = 32;
let spectroBuffer = []; 
let currentVolume = 0;
let lastCommandTime = 0; // For debounce

async function initAudio() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser);
        drawSpectrogramLoop();
        
        Plotly.newPlot('latent-plot', [], {
            title: 'Latent Space (2 Neurons)',
            margin: {t:30,l:30,r:10,b:30},
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            xaxis: {title: 'N1', color:'#94a3b8'},
            yaxis: {title: 'N2', color:'#94a3b8'},
            showlegend: true,
            legend: {font:{color:'white'}}
        });
    } catch (e) { alert("–ü–æ–º–∏–ª–∫–∞ –º—ñ–∫—Ä–æ—Ñ–æ–Ω—É: " + e); }
}

function getAudioFrame() {
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    let sum=0; for(let i=0; i<data.length; i++) sum+=data[i]*data[i];
    currentVolume = Math.sqrt(sum/data.length)/255.0;
    
    const bar = document.getElementById('volBar');
    if(bar) bar.style.width = Math.min(100, currentVolume*400) + "%";
    return Float32Array.from(data).map(v => v/255);
}

function drawSpectrogramLoop() {
    requestAnimationFrame(drawSpectrogramLoop);
    const frame = getAudioFrame();
    
    // Logic: If Paused, do nothing but draw single line
    if (isPaused && !isRecording) {
         drawSpectroCanvas([frame], true);
         return;
    }

    if (isRecording) {
        spectroBuffer.push(frame);
        if(spectroBuffer.length > SPECTRO_SIZE*2) spectroBuffer.shift();
        drawSpectroCanvas(spectroBuffer);
    } 
    else {
        // Listening Mode
        spectroBuffer.push(frame);
        if(spectroBuffer.length > SPECTRO_SIZE) spectroBuffer.shift();
        drawSpectroCanvas(spectroBuffer);
        
        // Predict occasionally if buffer full
        if(spectroBuffer.length === SPECTRO_SIZE && Math.random() < 0.2) predictLive();
    }
}

function drawSpectroCanvas(buffer, isSingleLine=false) {
    const cvs = document.getElementById('spectrogramCanvas');
    const ctx = cvs.getContext('2d');
    const w = cvs.width; const h = cvs.height;
    ctx.clearRect(0,0,w,h);
    if(isSingleLine) {
       const col = buffer[0];
       for(let i=0; i<col.length; i++) {
           const val = col[i]*255; ctx.fillStyle = `rgb(${val},${val},${val})`; ctx.fillRect(0, h-i, w, 1);
       }
       return;
    }
    const cellW = w/SPECTRO_SIZE; const cellH = h/32; 
    const startIdx = Math.max(0, buffer.length - SPECTRO_SIZE);
    for (let t = 0; t < Math.min(buffer.length, SPECTRO_SIZE); t++) {
        const col = buffer[startIdx + t];
        for (let f = 0; f < col.length; f++) {
             const val = col[f]*255; ctx.fillStyle = `rgb(${val}, ${255-val}, 100)`;
             ctx.fillRect(t*cellW, h-(f*cellH), cellW, cellH);
        }
    }
}

// REC logic
function startRec(labelId) {
    if(isPaused) togglePause(); // Force unpause to record
    isRecording = true; spectroBuffer = []; 
    document.getElementById(`btnRec${labelId}`).classList.add('recording');
}
function stopRec() {
    if (!isRecording) return;
    isRecording = false;
    let labelId = -1;
    for(let i=0; i<4; i++) {
        const btn = document.getElementById(`btnRec${i}`);
        if(btn.classList.contains('recording')) { btn.classList.remove('recording'); labelId = i; }
    }
    if (labelId !== -1 && spectroBuffer.length >= 10) {
        const fullData = new Float32Array(SPECTRO_SIZE * 32).fill(0);
        const len = Math.min(spectroBuffer.length, SPECTRO_SIZE);
        const start = spectroBuffer.length - len;
        for(let t=0; t<len; t++) {
            const targetT = SPECTRO_SIZE - len + t; 
            for(let f=0; f<32; f++) fullData[targetT * 32 + f] = spectroBuffer[start + t][f];
        }
        samples.push({ data: fullData, label: labelId });
        document.getElementById(`cnt${labelId}`).innerText = samples.filter(s => s.label === labelId).length;
    }
}

async function trainNetwork() {
    if (samples.length < 4) { alert("–ó–∞–ø–∏—à—ñ—Ç—å –¥–∞–Ω—ñ!"); return; }
    const actType = document.getElementById('actType').value;
    net.resetLayers(actType);

    const btn = document.getElementById('btnTrain');
    btn.disabled = true; btn.innerText = "–ù–∞–≤—á–∞–Ω–Ω—è...";
    const EPOCHS = 50;
    const lossHistory = [];

    for (let e = 0; e < EPOCHS; e++) {
        let totalLoss = 0;
        samples.sort(() => Math.random() - 0.5);
        for (const s of samples) totalLoss += net.train(s.data, s.label);
        lossHistory.push(totalLoss / samples.length);
        
        if (e % 5 === 0) {
            Plotly.newPlot('loss-plot', [{ y: lossHistory, type: 'scatter', mode: 'lines', line: {color:'#8b5cf6'} }], 
            { margin: {t:10,l:30,r:10,b:20}, height: 60, paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', xaxis:{visible:false}, yaxis:{visible:false} });
            updateLatentPlot();
            await new Promise(r => setTimeout(r, 10));
        }
    }
    updateLatentPlot();
    btn.disabled = false; btn.innerText = "üöÄ –ù–∞–≤—á–∏—Ç–∏";
    alert("–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ!");
}

function updateLatentPlot() {
    const traces = {};
    labels.forEach((l, i) => {
        traces[i] = { x: [], y: [], mode: 'markers', type: 'scatter', name: l, marker: {color: labelColors[i], size: 8} };
    });
    for(const s of samples) {
        const latent = net.forward(s.data, true);
        traces[s.label].x.push(latent[0]);
        traces[s.label].y.push(latent[1]);
    }
    Plotly.react('latent-plot', Object.values(traces), {
        title: 'Latent Space', margin: {t:30,l:30,r:10,b:30},
        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
        xaxis: {color:'#94a3b8'}, yaxis: {color:'#94a3b8'}, showlegend: false
    });
}

function predictLive() {
    // 1. Cooldown check
    if (Date.now() - lastCommandTime < 200) return; // 0.2s delay

    const gateVal = parseInt(document.getElementById('noiseGate').value) / 100.0;
    const normalizedVol = Math.min(1.0, currentVolume * 4); 

    if (normalizedVol < gateVal) {
        updatePredUI(new Float32Array(4).fill(0), true);
        return;
    }

    const input = new Float32Array(SPECTRO_SIZE * 32).fill(0);
    const snippet = spectroBuffer.slice(spectroBuffer.length - SPECTRO_SIZE);
    for(let t=0; t<SPECTRO_SIZE; t++) {
        for(let f=0; f<32; f++) input[t * 32 + f] = snippet[t][f];
    }
    
    const probs = net.forward(input);
    updatePredUI(probs, false);
    
    const maxIdx = probs.indexOf(Math.max(...probs));
    if (probs[maxIdx] > 0.75) {
        handleVoiceCommand(maxIdx);
        lastCommandTime = Date.now(); // Set cooldown
    }
}

function updatePredUI(probs, isSilence) {
    const container = document.getElementById('predictions');
    container.innerHTML = '';
    if(isSilence) {
        labels.forEach(l => {
             const row = document.createElement('div');
             row.className = `pred-row disabled`;
             row.innerHTML = `<span style="width:70px">${l.split(' ')[0]}</span><div class="bar-bg"></div>`;
             container.appendChild(row);
        });
        return;
    }
    const maxIdx = probs.indexOf(Math.max(...probs));
    probs.forEach((p, i) => {
        const row = document.createElement('div');
        row.className = `pred-row ${i === maxIdx && p > 0.75 ? 'active' : ''}`;
        row.innerHTML = `<span style="width:70px">${labels[i].split(' ')[0]}</span><div class="bar-bg"><div class="bar-fill" style="width:${p*100}%"></div></div>`;
        container.appendChild(row);
    });
}

function saveNetwork() {
    const data = { w:[], b:[], f:[], attW:[], attBias:0, act: document.getElementById('actType').value };
    net.layers.forEach(l => {
        if(l.weights) data.w.push(Array.from(l.weights));
        if(l.biases) data.b.push(Array.from(l.biases));
        if(l.filters) data.f.push(Array.from(l.filters));
        if(l.attW) { data.attW = Array.from(l.attW); data.attBias = l.attBias; }
    });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], {type:'application/json'}));
    a.download = 'voice-snake-attention.json'; a.click();
}

function loadNetwork(input) {
    const r = new FileReader();
    r.onload = e => {
        const d = JSON.parse(e.target.result);
        if(d.act) document.getElementById('actType').value = d.act;
        net.resetLayers(d.act || 'relu');
        let wi=0, bi=0, fi=0;
        net.layers.forEach(l => {
            if(l.weights) l.weights.set(d.w[wi++]);
            if(l.biases) l.biases.set(d.b[bi++]);
            if(l.filters) l.filters.set(d.f[fi++]);
            if(l.attW && d.attW) { l.attW.set(d.attW); l.attBias = d.attBias; }
        });
        alert("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!");
    };
    r.readAsText(input.files[0]);
}

/**
 * === GAME LOGIC (UPDATED) ===
 */
const cvs = document.getElementById('snakeCanvas');
const ctx = cvs.getContext('2d');
let snake = [{x: 10, y: 10}];
let food = {x: 15, y: 15};
// Physics
let velocity = {x: 0, y: 0}; 
let friction = 0.05; 
const GRID = 20;
let score = 0;
let posAccumulator = {x: 0, y: 0}; // To handle sub-pixel movement logic

window.onresize = () => { cvs.width = cvs.parentElement.clientWidth; cvs.height = cvs.parentElement.clientHeight; };
window.onresize();

function updateFrictionUI(val) {
    friction = val / 100.0;
    document.getElementById('fricDisp').innerText = val + "%";
}

function gameLoop() {
    if (isPaused) {
        requestAnimationFrame(gameLoop);
        return;
    }

    // 1. Apply Friction
    velocity.x *= (1 - friction);
    velocity.y *= (1 - friction);
    
    // Stop if too slow
    if(Math.abs(velocity.x) < 0.01) velocity.x = 0;
    if(Math.abs(velocity.y) < 0.01) velocity.y = 0;

    // Display speed
    const speed = Math.sqrt(velocity.x**2 + velocity.y**2);
    document.getElementById('speedVal').innerText = (speed*100).toFixed(0);

    // 2. Accumulate position
    posAccumulator.x += velocity.x;
    posAccumulator.y += velocity.y;

    // 3. Move Grid Step if accumulator > 1
    if (Math.abs(posAccumulator.x) >= 1 || Math.abs(posAccumulator.y) >= 1) {
        let stepX = 0;
        let stepY = 0;

        if (Math.abs(posAccumulator.x) >= 1) {
            stepX = Math.sign(posAccumulator.x);
            posAccumulator.x -= stepX;
        }
        if (Math.abs(posAccumulator.y) >= 1) {
            stepY = Math.sign(posAccumulator.y);
            posAccumulator.y -= stepY;
        }

        // Only move if we have a valid grid step
        if (stepX !== 0 || stepY !== 0) {
            moveSnakeStep(stepX, stepY);
        }
    }

    drawGame();
    requestAnimationFrame(gameLoop);
}

function moveSnakeStep(dx, dy) {
    const head = {x: snake[0].x + dx, y: snake[0].y + dy};
    const tw = Math.floor(cvs.width/GRID), th = Math.floor(cvs.height/GRID);
    
    if (head.x < 0) head.x = tw - 1; if (head.x >= tw) head.x = 0;
    if (head.y < 0) head.y = th - 1; if (head.y >= th) head.y = 0;
    
    // Self collision
    if (snake.some(s => s.x===head.x && s.y===head.y)) {
        resetGame();
        return;
    }

    snake.unshift(head);
    if (head.x===food.x && head.y===food.y) {
        score++; document.getElementById('scoreVal').innerText = score;
        food = {x: Math.floor(Math.random()*tw), y: Math.floor(Math.random()*th)};
        // Boost speed slightly on eat
        velocity.x *= 1.1; velocity.y *= 1.1;
    } else {
        snake.pop();
    }
}

function drawGame() {
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,cvs.width,cvs.height);
    
    // Grid (optional, faint)
    ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
    // ... drawing grid is expensive, skip for perf

    // Food
    ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(food.x*GRID+GRID/2,food.y*GRID+GRID/2,GRID/2-2,0,7); ctx.fill();
    
    // Snake
    ctx.fillStyle = '#10b981'; 
    snake.forEach((s, i) => {
        if(i > 0) ctx.fillRect(s.x*GRID+1,s.y*GRID+1,GRID-2,GRID-2);
    });

    // Head
    const head = snake[0];
    const cx = head.x*GRID + GRID/2;
    const cy = head.y*GRID + GRID/2;
    
    ctx.save();
    ctx.translate(cx, cy);
    // Determine angle from velocity (if moving) or just default
    let angle = 0;
    if (Math.abs(velocity.x) > Math.abs(velocity.y)) {
        angle = velocity.x > 0 ? Math.PI/2 : -Math.PI/2;
    } else if (Math.abs(velocity.y) > 0) {
        angle = velocity.y > 0 ? Math.PI : 0;
    }
    
    ctx.rotate(angle);
    ctx.fillStyle = '#4ade80'; 
    ctx.beginPath(); ctx.moveTo(0, -GRID/2+2); ctx.lineTo(GRID/2-2, GRID/2-2); ctx.lineTo(-GRID/2+2, GRID/2-2); ctx.fill();
    ctx.restore();
}

function resetGame() {
    snake = [{x:10,y:10}]; velocity={x:0,y:0}; score=0;
    document.getElementById('scoreVal').innerText=0;
    togglePause(true); 
}

function togglePause(forcePause = false) {
    if (forcePause) isPaused = false; 
    isPaused = !isPaused;
    
    const btn = document.getElementById('btnPause');
    const overlay = document.getElementById('gameOverlay');
    
    if (isPaused) {
        btn.innerHTML = "‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç";
        btn.classList.remove('btn-warn'); btn.classList.add('btn-success');
        overlay.style.display = 'block';
        if(audioCtx.state === 'running') audioCtx.suspend();
    } else {
        btn.innerHTML = "‚è∏Ô∏è –ü–∞—É–∑–∞";
        btn.classList.remove('btn-success'); btn.classList.add('btn-warn');
        overlay.style.display = 'none';
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }
}

// 0:Up, 1:Down, 2:Left, 3:Right
function handleVoiceCommand(i) {
    if (isPaused) return;

    document.getElementById('lastCmd').innerText = labels[i].split(' ')[0];
    
    // Absolute control + Acceleration boost
    const PUSH = 0.5; // How much speed to add per command
    
    if (i === 0) { // Up
        velocity.x = 0; 
        velocity.y = (velocity.y < 0 ? velocity.y : 0) - PUSH; 
    }
    else if (i === 1) { // Down
        velocity.x = 0; 
        velocity.y = (velocity.y > 0 ? velocity.y : 0) + PUSH; 
    }
    else if (i === 2) { // Left
        velocity.y = 0; 
        velocity.x = (velocity.x < 0 ? velocity.x : 0) - PUSH; 
    }
    else if (i === 3) { // Right
        velocity.y = 0; 
        velocity.x = (velocity.x > 0 ? velocity.x : 0) + PUSH; 
    }
    
    // Cap max speed
    const MAX_SPEED = 1.2;
    if (velocity.x > MAX_SPEED) velocity.x = MAX_SPEED;
    if (velocity.x < -MAX_SPEED) velocity.x = -MAX_SPEED;
    if (velocity.y > MAX_SPEED) velocity.y = MAX_SPEED;
    if (velocity.y < -MAX_SPEED) velocity.y = -MAX_SPEED;
}

initAudio();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
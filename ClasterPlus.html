<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HDBSCAN 3D Master Class</title>
    
    <script>
    MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
      }
    </script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #f0f2f5; }
        
        /* --- –ü–ê–ù–ï–õ–Ü --- */
        .panel {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }

        /* –ü—Ä–∞–≤–∞ –ø–∞–Ω–µ–ª—å - –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ */
        #right-panel {
            top: 10px;
            right: 10px;
            width: 270px;
        }

        /* –õ—ñ–≤–∞ –ø–∞–Ω–µ–ª—å - –ù–∞–≤—á–∞–Ω–Ω—è */
        #left-panel {
            top: 10px;
            left: 10px;
            width: 300px; /* –¢—Ä–æ—Ö–∏ —à–∏—Ä—à–µ –¥–ª—è —Ç–µ–∫—Å—Ç—É */
            border-left: 5px solid #3498db;
        }

        h2 { margin-top: 0; font-size: 1.1rem; color: #2c3e50; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        h3 { margin: 10px 0 5px; font-size: 1rem; color: #34495e; }
        p { font-size: 0.9rem; color: #555; line-height: 1.4; margin-bottom: 10px; }
        ul { padding-left: 20px; margin: 5px 0; font-size: 0.85rem; color: #555; }
        li { margin-bottom: 4px; }

        /* –ï–ª–µ–º–µ–Ω—Ç–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è */
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 600; font-size: 0.85rem; }
        input[type="range"] { width: 100%; cursor: pointer; }
        select, button { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; margin-top: 5px;}
        
        button.primary { background: #3498db; color: white; border: none; font-weight: bold; transition: 0.2s; }
        button.primary:hover { background: #2980b9; }
        
        button.theory-btn { background: #8e44ad; color: white; border: none; margin-top: 15px; }
        button.theory-btn:hover { background: #732d91; }

        .step-controls { display: flex; gap: 5px; margin-top: 15px; }
        .step-btn { flex: 1; padding: 10px; background: #eee; border: none; font-weight: bold; }
        .step-btn:hover { background: #ddd; }
        .step-btn.active { background: #27ae60; color: white; }

        /* –°–ø–æ–π–ª–µ—Ä–∏ (Details) */
        details.theory-spoiler {
            background: #f1f8ff;
            border: 1px solid #cceeff;
            border-radius: 4px;
            padding: 8px;
            margin-top: 10px;
            font-size: 0.85rem;
        }
        details.theory-spoiler summary {
            cursor: pointer;
            color: #2980b9;
            font-weight: bold;
            outline: none;
        }
        details.theory-spoiler p { margin-bottom: 5px; margin-top: 5px; color: #333; }
        details.theory-spoiler code { background: #fff; padding: 2px 4px; border-radius: 3px; font-family: monospace; }

        /* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */
        .stat-box { background: #f8f9fa; padding: 10px; border-radius: 4px; border: 1px solid #eee; margin-top: 10px; font-size: 0.85rem; }
        .stat-row { display: flex; justify-content: space-between; }
        .noise-badge { color: #e74c3c; font-weight: bold; }

        /* --- –ú–û–î–ê–õ–¨–ù–ï –í–Ü–ö–ù–û --- */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #modal-content {
            background: white;
            width: 70%;
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            padding: 30px;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .close-btn {
            position: absolute; top: 15px; right: 20px;
            font-size: 24px; cursor: pointer; color: #888;
        }
        .close-btn:hover { color: #333; }
        .theory-section { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .theory-section:last-child { border: none; }
        
        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="tooltip"></div>

    <div id="modal-overlay" onclick="closeModal(event)">
        <div id="modal-content">
            <span class="close-btn" onclick="document.getElementById('modal-overlay').style.display='none'">&times;</span>
            <h2 style="font-size: 1.8rem; border-color: #8e44ad;">–¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –¥–æ–≤—ñ–¥–∫–∞: HDBSCAN</h2>
            
<div class="theory-section" style="background: #f0f7fb; padding: 15px; border-radius: 8px; border: 1px solid #cceeff; margin-top: 20px;">
                <h3 style="color: #2c3e50;">–°—Ü–µ–Ω–∞—Ä—ñ–π 1: DevOps / SRE (–ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –∫–ª–∞—Å—Ç–µ—Ä–∞)</h3>
                <p><strong>–í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ:</strong> 50+ –º–µ—Ç—Ä–∏–∫ –∑ –∫–æ–∂–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ (CPU, RAM, Disk I/O, Network, Errors), –∑—Ç–∏—Å–Ω—É—Ç—ñ —á–µ—Ä–µ–∑ PCA –¥–æ 3-—Ö –≤–∏–º—ñ—Ä—ñ–≤.</p>
                
                <p><strong>–Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è –û—Å–µ–π:</strong></p>
                <ul style="margin-bottom: 10px;">
                    <li><strong>PC1 (–í—ñ—Å—å X):</strong> –ó–∞–≥–∞–ª—å–Ω–µ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (CPU + RAM).</li>
                    <li><strong>PC2 (–í—ñ—Å—å Y):</strong> –Ü–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –¥–∏—Å–∫–æ–≤–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π (Disk I/O).</li>
                    <li><strong>PC3 (–í—ñ—Å—å Z):</strong> –°—Ç–∞–±—ñ–ª—å–Ω—ñ—Å—Ç—å (Error Rate + Latency).</li>
                </ul>

                <p><strong>–©–æ –º–∏ —à—É–∫–∞—î–º–æ —É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ?</strong></p>
                <ul style="list-style-type: none; padding-left: 5px;">
                    <li>üü¢ <strong>1. –í–µ–ª–∏–∫–∏–π —â—ñ–ª—å–Ω–∏–π –∫–ª–∞—Å—Ç–µ—Ä:</strong> 95% —Å–µ—Ä–≤–µ—Ä—ñ–≤, —â–æ –ø—Ä–∞—Ü—é—é—Ç—å —É —à—Ç–∞—Ç–Ω–æ–º—É —Ä–µ–∂–∏–º—ñ (—Å–µ—Ä–µ–¥–Ω—î –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è, –º—ñ–Ω—ñ–º—É–º –ø–æ–º–∏–ª–æ–∫).</li>
                    <li>üîµ <strong>2. –ú–µ–Ω—à–∏–π —â—ñ–ª—å–Ω–∏–π –∫–ª–∞—Å—Ç–µ—Ä:</strong> –°–µ—Ä–≤–µ—Ä–∏, —â–æ –≤–∏–∫–æ–Ω—É—é—Ç—å –ø–ª–∞–Ω–æ–≤–∏–π –±–µ–∫–∞–ø –∞–±–æ –≤–∞–∂–∫—ñ —Ñ–æ–Ω–æ–≤—ñ –∑–∞–¥–∞—á—ñ (–º–∞—é—Ç—å –≤–∏—Å–æ–∫–∏–π PC2/–í—ñ—Å—å Y —á–µ—Ä–µ–∑ –∞–∫—Ç–∏–≤–Ω–∏–π –¥–∏—Å–∫). –¶–µ –Ω–æ—Ä–º–∞, –Ω–µ –∞–Ω–æ–º–∞–ª—ñ—è.</li>
                    <li>‚ö´ <strong>3. –®—É–º (Noise / –í—ñ–¥—ñ—Ä–≤–∞–Ω—ñ —Ç–æ—á–∫–∏):</strong> –¶–µ –Ω–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–µ! –û–¥–∏–Ω–æ–∫—ñ —á–æ—Ä–Ω—ñ —Ç–æ—á–∫–∏. 
                        <br><em>–ü—Ä–∏–∫–ª–∞–¥–∏:</em> "–ó–∞–≤–∏—Å–ª–∏–π" –ø—Ä–æ—Ü–µ—Å (–≤–∏—Å–æ–∫–∏–π X, –Ω—É–ª—å–æ–≤–∏–π Y) –∞–±–æ –ø–æ—á–∞—Ç–æ–∫ DDoS-–∞—Ç–∞–∫–∏ (–∞–Ω–æ–º–∞–ª—å–Ω–∏–π Z). HDBSCAN –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Ñ–∞—Ä–±—É—î —ó—Ö —É "—à—É–º", –≤–∫–∞–∑—É—é—á–∏ –∞–¥–º—ñ–Ω—É –Ω–∞ –ø—Ä–æ–±–ª–µ–º—É.</li>
                </ul>
            </div>

            <div class="theory-section" style="background: #fff8f0; padding: 15px; border-radius: 8px; border: 1px solid #fae5cd; margin-top: 15px;">
                <h3 style="color: #d35400;">üõí –°—Ü–µ–Ω–∞—Ä—ñ–π 2: E-commerce (–°–µ–≥–º–µ–Ω—Ç–∞—Ü—ñ—è –ø–æ–∫—É–ø—Ü—ñ–≤)</h3>
                <p><strong>–í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ:</strong> –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ–∫—É–ø–æ–∫, —á–∞—Å –Ω–∞ —Å–∞–π—Ç—ñ, –∫–ª—ñ–∫–∏, —Å–µ—Ä–µ–¥–Ω—ñ–π —á–µ–∫, –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è —Ç–æ–≤–∞—Ä—ñ–≤.</p>

                <p><strong>–Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è –û—Å–µ–π:</strong></p>
                <ul style="margin-bottom: 10px;">
                    <li><strong>PC1 (–í—ñ—Å—å X):</strong> "–ü–ª–∞—Ç–æ—Å–ø—Ä–æ–º–æ–∂–Ω—ñ—Å—Ç—å" (–¶—ñ–Ω–∞ —Ç–æ–≤–∞—Ä—ñ–≤, VIP —Å—Ç–∞—Ç—É—Å).</li>
                    <li><strong>PC2 (–í—ñ—Å—å Y):</strong> "–ó–∞–ª—É—á–µ–Ω—ñ—Å—Ç—å" (–ß–∞—Å –Ω–∞ —Å–∞–π—Ç—ñ, –≥–ª–∏–±–∏–Ω–∞ –ø–µ—Ä–µ–≥–ª—è–¥—É).</li>
                    <li><strong>PC3 (–í—ñ—Å—å Z):</strong> "–Ü–º–ø—É–ª—å—Å–∏–≤–Ω—ñ—Å—Ç—å" (–®–≤–∏–¥–∫—ñ—Å—Ç—å –ø—Ä–∏–π–Ω—è—Ç—Ç—è —Ä—ñ—à–µ–Ω–Ω—è).</li>
                </ul>

                <p><strong>–¢–∏–ø–æ–≤—ñ –∫–ª–∞—Å—Ç–µ—Ä–∏ (–ì—Ä—É–ø–∏):</strong></p>
                <ul style="list-style-type: none; padding-left: 5px;">
                    <li>üê¢ <strong>"Loiterers" (–ó–µ–≤–∞–∫–∏):</strong> –í–∏—Å–æ–∫–∏–π Y (–¥–æ–≤–≥–æ –¥–∏–≤–ª—è—Ç—å—Å—è), –Ω–∏–∑—å–∫–∏–π X (–º–∞–ª–æ –∫—É–ø—É—é—Ç—å).</li>
                    <li>üêã <strong>"Whales" (–ö–∏—Ç–∏):</strong> –í–∏—Å–æ–∫–∏–π X (–≤–µ–ª–∏–∫–∏–π —á–µ–∫), –≤–∏—Å–æ–∫–∏–π Z (—à–≤–∏–¥–∫—ñ –ø–æ–∫—É–ø–∫–∏).</li>
                    <li>ü¶ä <strong>"Bargain Hunters":</strong> –û–∫—Ä–µ–º–∞ –≥—Ä—É–ø–∞, —â–æ –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –ø—ñ–¥ —á–∞—Å —Ä–æ–∑–ø—Ä–æ–¥–∞–∂—ñ–≤.</li>
                </ul>

                <p><strong>–ù–∞–≤—ñ—â–æ —Ç—É—Ç "–†–æ–∑—Ä—ñ–∑–∞–Ω–Ω—è –¥–µ—Ä–µ–≤–∞" (Slider)?</strong></p>
                <p>–†—É—Ö–∞—é—á–∏ —Å–ª–∞–π–¥–µ—Ä –ø–æ—Ä–æ–≥—É ($\epsilon$) –≤–ª—ñ–≤–æ, –≤–∏ –±–∞—á–∏—Ç–µ, —è–∫ –≤–µ–ª–∏–∫–∏–π –∫–ª–∞—Å—Ç–µ—Ä "–ó–∞–≤—Å—ñ–¥–Ω–∏–∫–∏ —Ä–æ–∑–ø—Ä–æ–¥–∞–∂—ñ–≤" —Ä–æ–∑–ø–∞–¥–∞—î—Ç—å—Å—è –Ω–∞ –ø—ñ–¥–≥—Ä—É–ø–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, "–õ—é–±–∏—Ç–µ–ª—ñ –≥–∞–¥–∂–µ—Ç—ñ–≤" –≤—ñ–¥–æ–∫—Ä–µ–º–ª—é—é—Ç—å—Å—è –≤—ñ–¥ "–ú–æ–¥–Ω–∏–∫—ñ–≤"). –¶–µ –¥–æ–ø–æ–º–∞–≥–∞—î –º–∞—Ä–∫–µ—Ç–æ–ª–æ–≥–∞–º –≤–∏—Ä—ñ—à–∏—Ç–∏: —Ä–æ–±–∏—Ç–∏ –æ–¥–Ω—É –∑–∞–≥–∞–ª—å–Ω—É —Ä–æ–∑—Å–∏–ª–∫—É —á–∏ –¥–≤—ñ —Ä—ñ–∑–Ω—ñ.</p>
            </div>
            
            
            <div class="theory-section">
                <h3>üîç –ö–æ–Ω—Ç–µ–∫—Å—Ç Big Data</h3>
                <p>–ö–ª–∞—Å–∏—á–Ω—ñ –∞–ª–≥–æ—Ä–∏—Ç–º–∏, —è–∫ K-means, –ø–æ–≥–∞–Ω–æ –ø—Ä–∞—Ü—é—é—Ç—å –∑ –≤–µ–ª–∏–∫–∏–º–∏ –¥–∞–Ω–∏–º–∏, —è–∫—ñ –º–∞—é—Ç—å:</p>
                <ul>
                    <li>–®—É–º —Ç–∞ –≤–∏–∫–∏–¥–∏ (Outliers).</li>
                    <li>–ö–ª–∞—Å—Ç–µ—Ä–∏ –¥–æ–≤—ñ–ª—å–Ω–æ—ó –≥–µ–æ–º–µ—Ç—Ä–∏—á–Ω–æ—ó —Ñ–æ—Ä–º–∏ (–Ω–µ —Ç—ñ–ª—å–∫–∏ —Å—Ñ–µ—Ä–∏).</li>
                    <li>–†—ñ–∑–Ω—É —â—ñ–ª—å–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö.</li>
                </ul>
                <p><strong>HDBSCAN</strong> (Hierarchical Density-Based Spatial Clustering of Applications with Noise) –≤–∏—Ä—ñ—à—É—î —Ü—ñ –ø—Ä–æ–±–ª–µ–º–∏, –ø–æ—î–¥–Ω—É—é—á–∏ —ñ–¥–µ—ó DBSCAN —Ç–∞ —ñ—î—Ä–∞—Ä—Ö—ñ—á–Ω–æ—ó –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—ó.</p>
            </div>

            <div class="theory-section">
                <h3>üìè –ö—Ä–æ–∫ 1: Core Distance ($d_{core}$)</h3>
                <p>–î–ª—è –∫–æ–∂–Ω–æ—ó —Ç–æ—á–∫–∏ $x$ –∑–Ω–∞—Ö–æ–¥–∏–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–æ —ó—ó $k$-–≥–æ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Å—É—Å—ñ–¥–∞ (–¥–µ $k = m_{pts}$).</p>
                <p>$$ d_{core}(x) = dist(x, k\text{-th neighbor}) $$</p>
                <p>–¶–µ –º—ñ—Ä–∞ "—Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω–æ—Å—Ç—ñ". –£ —â—ñ–ª—å–Ω–∏—Ö —Ä–µ–≥—ñ–æ–Ω–∞—Ö $d_{core}$ –º–∞–ª–∞, —É —Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω–∏—Ö (—à—É–º) ‚Äî –≤–µ–ª–∏–∫–∞.</p>
            </div>

            <div class="theory-section">
                <h3>ü§ù –ö—Ä–æ–∫ 2: Mutual Reachability Distance ($d_{mreach}$)</h3>
                <p>–©–æ–± "–≤—ñ–¥—Å—É–Ω—É—Ç–∏" —à—É–º–æ–≤—ñ —Ç–æ—á–∫–∏ –¥–∞–ª—ñ –≤—ñ–¥ –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤, –º–∏ –≤–≤–æ–¥–∏–º–æ –Ω–æ–≤—É –º–µ—Ç—Ä–∏–∫—É:</p>
                <p>$$ d_{mreach}(a, b) = \max \{ d_{core}(a), d_{core}(b), d(a, b) \} $$</p>
                <p>–Ø–∫—â–æ —Ö–æ—á–∞ –± –æ–¥–Ω–∞ –∑ —Ç–æ—á–æ–∫ –º–∞—î –≤–µ–ª–∏–∫—É $d_{core}$ (—î —à—É–º–æ–º), –≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –Ω–∏–º–∏ —Å—Ç–∞—î –≤–µ–ª–∏–∫–æ—é. –¶–µ —Å—Ç–∞–±—ñ–ª—ñ–∑—É—î –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—é.</p>
            </div>

            <div class="theory-section">
                <h3>üå≥ –ö—Ä–æ–∫ 3: –ü–æ–±—É–¥–æ–≤–∞ MST (–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–µ –û—Å—Ç–æ–≤–Ω–µ –î–µ—Ä–µ–≤–æ)</h3>
                <p>–ú–∏ –±—É–¥—É—î–º–æ –≥—Ä–∞—Ñ, –¥–µ –≤–µ—Ä—à–∏–Ω–∏ ‚Äî —Ü–µ —Ç–æ—á–∫–∏, –∞ –≤–∞–≥–∞ —Ä–µ–±–µ—Ä ‚Äî $d_{mreach}$. –ê–ª–≥–æ—Ä–∏—Ç–º (—Ç–∞–∫–∏–π —è–∫ –ü—Ä—ñ–º–∞ –∞–±–æ –ö—Ä—É—Å–∫–∞–ª–∞) –∑–Ω–∞—Ö–æ–¥–∏—Ç—å –¥–µ—Ä–µ–≤–æ, —â–æ –∑'—î–¥–Ω—É—î –≤—Å—ñ —Ç–æ—á–∫–∏ –∑ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ—é —Å—É–º–∞—Ä–Ω–æ—é –≤–∞–≥–æ—é.</p>
                <p>–¶–µ –¥–µ—Ä–µ–≤–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î —ñ—î—Ä–∞—Ä—Ö—ñ—é –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤.</p>
            </div>

            <div class="theory-section">
                <h3>‚úÇÔ∏è –ö—Ä–æ–∫ 4: –†–æ–∑—Ä—ñ–∑–∞–Ω–Ω—è –¥–µ—Ä–µ–≤–∞ (Extract Clusters)</h3>
                <p>–ú–∏ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø–æ—Ä—ñ–≥ $\epsilon$. –í–∏–¥–∞–ª—è—î–º–æ –≤—Å—ñ —Ä–µ–±—Ä–∞, –≤–∞–≥–∞ —è–∫–∏—Ö $> \epsilon$.</p>
                <ul>
                    <li>–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –∑–≤'—è–∑–Ω–æ—Å—Ç—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –Ω–∞ –∫–ª–∞—Å—Ç–µ—Ä–∏.</li>
                    <li>–Ø–∫—â–æ —Ä–æ–∑–º—ñ—Ä –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –º–µ–Ω—à–∏–π –∑–∞ $m_{pts}$, —Ü—ñ —Ç–æ—á–∫–∏ –≤–≤–∞–∂–∞—é—Ç—å—Å—è <strong>—à—É–º–æ–º</strong> (Noise).</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="left-panel" class="panel">
        <h2>üéì –ö—Ä–æ–∫–∏ –∞–ª–≥–æ—Ä–∏—Ç–º—É</h2>
        
        <div id="step-desc-0" class="step-content">
            <h3>0. –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –¥–∞–Ω–∏—Ö</h3>
            <p>–ó–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ –Ω–∞–±—ñ—Ä —Ç–æ—á–æ–∫. –î–µ—è–∫—ñ —É—Ç–≤–æ—Ä—é—é—Ç—å —â—ñ–ª—å–Ω—ñ –≥—Ä—É–ø–∏, —ñ–Ω—à—ñ —Ä–æ–∑–∫–∏–¥–∞–Ω—ñ —Ö–∞–æ—Ç–∏—á–Ω–æ (—à—É–º).</p>
            <p>–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å <strong>"–î–∞–ª—ñ"</strong>, —â–æ–± –ø–æ—á–∞—Ç–∏ –∞–Ω–∞–ª—ñ–∑.</p>
        </div>
        
        <div id="step-desc-1" class="step-content" style="display:none">
            <h3>1. Core Distance</h3>
            <p>–î–ª—è –∫–æ–∂–Ω–æ—ó —Ç–æ—á–∫–∏ —Ä–∞—Ö—É—î–º–æ —Ä–∞–¥—ñ—É—Å, —â–æ –æ—Ö–æ–ø–ª—é—î $m_{pts}$ —Å—É—Å—ñ–¥—ñ–≤.</p>
            <p><em>–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è:</em> –ñ–æ–≤—Ç—ñ —Å—Ñ–µ—Ä–∏ –ø–æ–∫–∞–∑—É—é—Ç—å $d_{core}$. –í–µ–ª–∏–∫—ñ —Å—Ñ–µ—Ä–∏ = –Ω–∏–∑—å–∫–∞ —â—ñ–ª—å–Ω—ñ—Å—Ç—å = –π–º–æ–≤—ñ—Ä–Ω–∏–π —à—É–º.</p>
        </div>
        
        <div id="step-desc-2" class="step-content" style="display:none">
            <h3>2. Mutual Reachability</h3>
            <p>–ü–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—ñ –º—ñ–∂ —É—Å—ñ–º–∞ –ø–∞—Ä–∞–º–∏ —Ç–æ—á–æ–∫ –∑–∞ —Ñ–æ—Ä–º—É–ª–æ—é:</p>
            <p style="background:#fff; padding:5px; border-radius:4px; border:1px solid #eee;">$d_{mr}(a,b) = \max(d_{core}(a), d_{core}(b), d(a,b))$</p>
            <p>–¶–µ "—Ä–æ–∑–¥—É–≤–∞—î" –ø—Ä–æ—Å—Ç—ñ—Ä —É —Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω–∏—Ö –∑–æ–Ω–∞—Ö.</p>
            
            <details class="theory-spoiler">
                <summary>üìê –î–µ—Ç–∞–ª—å–Ω—ñ—à–µ –ø—Ä–æ –ú–µ—Ç—Ä–∏–∫–∏</summary>
                <p><strong>1. –ï–≤–∫–ª—ñ–¥–æ–≤–∞ ($L_2$):</strong> $$d(x,y) = \sqrt{\sum(x_i-y_i)^2}$$</p>
                <p><em>Use-case:</em> –§—ñ–∑–∏—á–Ω—ñ –æ–±'—î–∫—Ç–∏, –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ.</p>
                <hr style="border-top:1px dashed #ccc; margin:5px 0;">
                <p><strong>2. –ö–æ—Å–∏–Ω—É—Å–Ω–∞:</strong> $$d_{cos} = 1 - \frac{x \cdot y}{\|x\|\|y\|}$$</p>
                <p><em>Use-case:</em> –¢–µ–∫—Å—Ç–æ–≤–∏–π –∞–Ω–∞–ª—ñ–∑ (NLP), –¥–µ –≤–∞–∂–ª–∏–≤–∏–π –Ω–∞–ø—Ä—è–º–æ–∫ (—Ç–µ–º–∞), –∞ –Ω–µ –¥–æ–≤–∂–∏–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞.</p>
                <hr style="border-top:1px dashed #ccc; margin:5px 0;">
                <p><strong>–ù—é–∞–Ω—Å –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó:</strong></p>
                <p>–Ø–∫—â–æ –º–∏ –Ω–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –≤–µ–∫—Ç–æ—Ä–∏ (–≤—Å—ñ —Ç–æ—á–∫–∏ –ª–µ–∂–∞—Ç—å –Ω–∞ —Å—Ñ–µ—Ä—ñ –æ–¥–∏–Ω–∏—á–Ω–æ–≥–æ —Ä–∞–¥—ñ—É—Å—É, $\|x\|=1$), —Ç–æ —ñ—Å–Ω—É—î —á—ñ—Ç–∫–∏–π –∑–≤'—è–∑–æ–∫:</p>
                <p>$$d_{eucl}^2 = 2(1 - \cos \theta)$$</p>
                <p>–¢–æ–±—Ç–æ <strong>–ï–≤–∫–ª—ñ–¥–æ–≤–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –Ω–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –¥–∞–Ω–∏—Ö –º–∞–π–∂–µ –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∞ –ö–æ—Å–∏–Ω—É—Å–Ω—ñ–π</strong> (–∑–±–µ—Ä—ñ–≥–∞—î —Ç–æ–π —Å–∞–º–∏–π –ø–æ—Ä—è–¥–æ–∫ —Å—É—Å—ñ–¥—ñ–≤).</p>
            </details>
        </div>
        
        <div id="step-desc-3" class="step-content" style="display:none">
            <h3>3. –ü–æ–±—É–¥–æ–≤–∞ MST</h3>
            <p>–ë—É–¥—É—î–º–æ –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–µ –û—Å—Ç–æ–≤–Ω–µ –î–µ—Ä–µ–≤–æ (MST), –∑'—î–¥–Ω—É—é—á–∏ —Ç–æ—á–∫–∏ –Ω–∞–π–∫–æ—Ä–æ—Ç—à–∏–º–∏ "–º'—é—á—É–∞–ª" —Ä–µ–±—Ä–∞–º–∏.</p>
            <p><em>–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è:</em> –°—ñ—Ä—ñ –ª—ñ–Ω—ñ—ó –ø–æ–∫–∞–∑—É—é—Ç—å —Å–∫–µ–ª–µ—Ç –¥–∞–Ω–∏—Ö.</p>

            <details class="theory-spoiler">
                <summary>üöÄ Big Data: –Ø–∫ —Ü–µ —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–∞—Ü—é—î?</summary>
                <p>–£ —Ü—å–æ–º—É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ –º–∏ —Ä–∞—Ö—É—î–º–æ MST –Ω–∞ –ø–æ–≤–Ω–æ–º—É –≥—Ä–∞—Ñ—ñ ($O(N^2)$). –î–ª—è 1 –º–ª–Ω —Ç–æ—á–æ–∫ —Ü–µ –∑–∞–π–Ω—è–ª–æ –± —Ç–µ—Ä–∞–±–∞–π—Ç–∏ –ø–∞–º'—è—Ç—ñ!</p>
                <p><strong>–Ø–∫ —Ü–µ —Ä–æ–±–ª—è—Ç—å —É production (–±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ hdbscan):</strong></p>
                <ol>
                    <li>–ù–µ –±—É–¥—É—é—Ç—å –ø–æ–≤–Ω–∏–π –≥—Ä–∞—Ñ. –ó–Ω–∞—Ö–æ–¥—è—Ç—å —Ç—ñ–ª—å–∫–∏ $k$ –Ω–∞–π–±–ª–∏–∂—á–∏—Ö —Å—É—Å—ñ–¥—ñ–≤ (<strong>k-NN graph</strong>).</li>
                    <li>–î–ª—è –ø–æ—à—É–∫—É —Å—É—Å—ñ–¥—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å —à–≤–∏–¥–∫—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏: <strong>KD-Tree</strong> (–º–∞–ª–∞ —Ä–æ–∑–º—ñ—Ä–Ω—ñ—Å—Ç—å) –∞–±–æ <strong>Ball Tree</strong> / <strong>PyNNDescent</strong> (–≤–µ–ª–∏–∫–∞ —Ä–æ–∑–º—ñ—Ä–Ω—ñ—Å—Ç—å, –Ω–∞–±–ª–∏–∂–µ–Ω–∏–π –ø–æ—à—É–∫).</li>
                    <li>MST –±—É–¥—É—é—Ç—å –Ω–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –ü—Ä—ñ–º–∞ —á–∏ –ö—Ä—É—Å–∫–∞–ª–∞, –∞ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º <strong>Boruvka</strong> –∞–±–æ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–º–∏ Dual-Tree –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏.</li>
                </ol>
                <p>–¶–µ –∑–Ω–∏–∂—É—î —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –¥–æ $O(N \log N)$.</p>
            </details>
        </div>
        
        <div id="step-desc-4" class="step-content" style="display:none">
            <h3>4. –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—è (Cut)</h3>
            <p>–ö–µ—Ä—É–π—Ç–µ <strong>–°–ª–∞–π–¥–µ—Ä–æ–º –ü–æ—Ä—ñ–≥</strong> —Å–ø—Ä–∞–≤–∞!</p>
            <p>–ú–∏ –≤–∏–¥–∞–ª—è—î–º–æ —Ä–µ–±—Ä–∞, –¥–æ–≤—à—ñ –∑–∞ –ø–æ—Ä—ñ–≥. –î–µ—Ä–µ–≤–æ —Ä–æ–∑–ø–∞–¥–∞—î—Ç—å—Å—è.</p>
            <ul>
                <li><span style="color:red">‚óè</span> –®—É–º (—á–æ—Ä–Ω—ñ/–¥—Ä—ñ–±–Ω—ñ): –ì—Ä—É–ø–∏ < $m_{pts}$</li>
                <li><span style="color:green">‚óè</span> –ö–ª–∞—Å—Ç–µ—Ä–∏: –†—ñ–∑–Ω–æ–∫–æ–ª—å–æ—Ä–æ–≤—ñ –≥—Ä—É–ø–∏</li>
            </ul>
        </div>

        <div class="step-controls">
            <button class="step-btn" onclick="sim.prevStep()">‚¨Ö –ù–∞–∑–∞–¥</button>
            <button class="step-btn primary" onclick="sim.nextStep()">–î–∞–ª—ñ ‚û°</button>
        </div>
        <p style="text-align:center; margin-top:5px; color:#888;">–ö—Ä–æ–∫: <span id="step-indicator">0</span> / 4</p>
    </div>

    <div id="right-panel" class="panel">
        <h3>–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</h3>

        <div class="control-group">
            <button class="primary" onclick="sim.generateData()">üîÑ –ù–æ–≤—ñ –¥–∞–Ω—ñ</button>
            <button class="theory-btn" onclick="document.getElementById('modal-overlay').style.display='flex'">üìö ? –¢–µ–æ—Ä—ñ—è</button>
        </div>

        <div class="control-group">
            <label>–°—Ç—É–ø—ñ–Ω—å —Å–∫—É–ø—á–µ–Ω–æ—Å—Ç—ñ (Spread):</label>
            <input type="range" id="spreadRange" min="0.5" max="3.0" step="0.1" value="1.5" oninput="sim.generateData()">
        </div>

        <div class="control-group">
            <label>–ú–µ—Ç—Ä–∏–∫–∞ –≤—ñ–¥—Å—Ç–∞–Ω—ñ:</label>
            <select id="metricSelect" onchange="sim.fullRecalculate()">
                <option value="euclidean">–ï–≤–∫–ª—ñ–¥–æ–≤–∞ (L2)</option>
                <option value="cosine">–ö–æ—Å–∏–Ω—É—Å–Ω–∞</option>
            </select>
            <div style="margin-top:5px">
                <input type="checkbox" id="normalizeCheck" onchange="sim.fullRecalculate()"> –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è
            </div>
        </div>

        <hr>

        <div class="control-group">
            <label>Min Points ($m_{pts}$): <span id="mptsVal">4</span></label>
            <input type="range" id="mptsRange" min="2" max="15" value="4" step="1" oninput="sim.fullRecalculate()">
        </div>

        <div class="control-group" id="cut-control" style="opacity: 0.5; pointer-events: none;">
            <label>–ü–æ—Ä—ñ–≥ —Ä–æ–∑—Ä—ñ–∑–∞–Ω–Ω—è ($ \epsilon $): <span id="cutVal">Max</span></label>
            <input type="range" id="cutRange" min="0" max="100" value="100" step="0.01" oninput="sim.cutTree()">
        </div>

        <div class="stat-box">
            <div class="stat-row"><span>–ö–ª–∞—Å—Ç–µ—Ä—ñ–≤:</span> <strong id="clusterCount">0</strong></div>
            <div class="stat-row"><span>–®—É–º:</span> <strong id="noiseCount" class="noise-badge">0</strong></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let pointsMesh, linesMesh, coreSpheresMesh;
        let raycaster, mouse;

        const DATA_COUNT = 200;
        
        // –ü–∞–ª—ñ—Ç—Ä–∞: 0 - –®—É–º (—á–æ—Ä–Ω–∏–π/—Ç–µ–º–Ω–æ-—Å—ñ—Ä–∏–π), 1..N - –ö–ª–∞—Å—Ç–µ—Ä–∏
        const NOISE_COLOR = new THREE.Color(0x2c3e50); 
        const NOISE_COLOR_HEX = 0x2c3e50;
        const PALETTE = [
            0xff0000, 0x00ff00, 0x0000ff, 0xddaa00, 0x11ffff, 
            0xee00dd, 0x1abc9c, 0xd35400, 0x27ae60, 0x2980b9, 0x8e44ad
        ];

        class HDBSCANSim {
            constructor() {
                this.step = 0; // 0..4
                this.rawData = [];
                this.processedData = [];
                this.distMatrix = [];
                this.coreDists = [];
                this.mstEdges = [];
                this.mpts = 4;
                this.maxEdgeWeight = 10;
            }

            init() {
                this.setupScene();
                this.generateData();
                window.addEventListener('resize', this.onResize.bind(this));
                window.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.animate();
            }

            setupScene() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf4f4f9);
                scene.fog = new THREE.Fog(0xf4f4f9, 20, 150);

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(25, 20, 25);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // Light
                const amb = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(amb);
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(10, 30, 10);
                scene.add(dir);

                // Grid
                const grid = new THREE.GridHelper(40, 40, 0xdddddd, 0xeaeaea);
                scene.add(grid);

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
            }

            generateData() {
                this.rawData = [];
                const spread = parseFloat(document.getElementById('spreadRange').value);
                
                // Centers
                const centers = [
                    {x: 8, y: 5, z: 0}, {x: -8, y: -5, z: -2}, 
                    {x: 0, y: -8, z: 5}, {x: -5, y: 8, z: -5}, {x: 0, y: 0, z: 0}
                ];
                
                centers.forEach((c, idx) => {
                    const count = 30 + Math.floor(Math.random() * 20);
                    // –¶–µ–Ω—Ç—Ä 4 (0,0,0) —Ä–æ–±–∏–º–æ —Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω–∏–º "–º—ñ—Å—Ç–∫–æ–º"
                    const localSpread = (idx === 4) ? spread * 2.5 : spread; 

                    for(let i=0; i<count; i++) {
                        this.rawData.push({
                            x: c.x + (Math.random()-0.5)*localSpread*3,
                            y: c.y + (Math.random()-0.5)*localSpread*3,
                            z: c.z + (Math.random()-0.5)*localSpread*3,
                            id: this.rawData.length
                        });
                    }
                });

                // Noise
                for(let i=0; i<40; i++) {
                    this.rawData.push({
                        x: (Math.random()-0.5)*35,
                        y: (Math.random()-0.5)*35,
                        z: (Math.random()-0.5)*35,
                        id: this.rawData.length
                    });
                }

                this.fullRecalculate();
            }

            fullRecalculate() {
                // UI Params
                this.mpts = parseInt(document.getElementById('mptsRange').value);
                document.getElementById('mptsVal').innerText = this.mpts;
                const metric = document.getElementById('metricSelect').value;
                const normalize = document.getElementById('normalizeCheck').checked;

                // 1. Process Data
                this.processedData = this.rawData.map(p => {
                    let v = new THREE.Vector3(p.x, p.y, p.z);
                    if(normalize) v.normalize().multiplyScalar(10);
                    return { vec: v, id: p.id };
                });

                // 2. Dist Matrix
                const n = this.processedData.length;
                this.distMatrix = Array(n).fill().map(() => Array(n).fill(0));
                
                for(let i=0; i<n; i++){
                    for(let j=i+1; j<n; j++){
                        let d;
                        if(metric === 'euclidean') d = this.processedData[i].vec.distanceTo(this.processedData[j].vec);
                        else {
                            const v1 = this.processedData[i].vec;
                            const v2 = this.processedData[j].vec;
                            // Safe cosine dist
                            d = 1.0 - (v1.dot(v2) / (v1.length()*v2.length() + 1e-9));
                        }
                        this.distMatrix[i][j] = d;
                        this.distMatrix[j][i] = d;
                    }
                }

                // 3. Core Dists
                this.coreDists = new Array(n).fill(0);
                for(let i=0; i<n; i++){
                    let row = [...this.distMatrix[i]].sort((a,b)=>a-b);
                    this.coreDists[i] = row[Math.min(this.mpts-1, n-1)];
                }

                // 4. MST (Prim's)
                this.mstEdges = [];
                let visited = new Array(n).fill(false);
                let minEdge = new Array(n).fill(Infinity);
                let parent = new Array(n).fill(-1);
                minEdge[0] = 0;

                for(let i=0; i<n; i++){
                    let u = -1;
                    for(let v=0; v<n; v++){
                        if(!visited[v] && (u===-1 || minEdge[v] < minEdge[u])) u = v;
                    }
                    if(minEdge[u] === Infinity) break;
                    visited[u] = true;
                    
                    if(parent[u] !== -1){
                        this.mstEdges.push({u: parent[u], v: u, weight: minEdge[u]});
                    }

                    for(let v=0; v<n; v++){
                        if(!visited[v]){
                            let d_orig = this.distMatrix[u][v];
                            let mr = Math.max(this.coreDists[u], this.coreDists[v], d_orig);
                            if(mr < minEdge[v]){
                                minEdge[v] = mr;
                                parent[v] = u;
                            }
                        }
                    }
                }
                
                this.mstEdges.sort((a,b) => a.weight - b.weight);
                this.maxEdgeWeight = this.mstEdges.length ? this.mstEdges[this.mstEdges.length-1].weight : 1;
                
                // Update Slider
                const slider = document.getElementById('cutRange');
                slider.max = this.maxEdgeWeight * 1.01;
                slider.value = slider.max;

                this.rebuildSceneObjects();
                this.updateStepUI(); // Refresh visualization based on current step
            }

            rebuildSceneObjects() {
                // Points
                if(pointsMesh) scene.remove(pointsMesh);
                const geom = new THREE.SphereGeometry(0.3, 16, 16);
                // 1. –°—Ç–∞–≤–∏–º–æ –±—ñ–ª–∏–π –∫–æ–ª—ñ—Ä (—â–æ–± –Ω–µ –ø—Ä–∏–≥–ª—É—à—É–≤–∞–≤ —ñ–Ω—à—ñ)
// 2. –ú—ñ–Ω—è—î–º–æ –Ω–∞ PhongMaterial (–¥–æ–¥–∞—î –±–ª—ñ–∫ —ñ –æ–±'—î–º, —Ä–æ–±–∏—Ç—å —Å—Ö–æ–∂–∏–º –Ω–∞ –ø–ª–∞—Å—Ç–∏–∫)
const mat = new THREE.MeshPhongMaterial({ 
    color: 0xffffff, 
    shininess: 50,
    specular: 0x111111 
});
                pointsMesh = new THREE.InstancedMesh(geom, mat, this.processedData.length);
                const dummy = new THREE.Object3D();
                for(let i=0; i<this.processedData.length; i++){
                    dummy.position.copy(this.processedData[i].vec);
                    dummy.updateMatrix();
                    pointsMesh.setMatrixAt(i, dummy.matrix);
                }
                pointsMesh.instanceMatrix.needsUpdate = true;
                scene.add(pointsMesh);

                // Core Spheres (Instanced for performance)
                if(coreSpheresMesh) scene.remove(coreSpheresMesh);
                const sGeom = new THREE.SphereGeometry(1, 16, 16);
                const sMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.15, wireframe: true });
                coreSpheresMesh = new THREE.InstancedMesh(sGeom, sMat, this.processedData.length);
                for(let i=0; i<this.processedData.length; i++){
                    dummy.position.copy(this.processedData[i].vec);
                    let r = this.coreDists[i];
                    dummy.scale.set(r, r, r);
                    dummy.updateMatrix();
                    coreSpheresMesh.setMatrixAt(i, dummy.matrix);
                }
                coreSpheresMesh.visible = false; // Hidden by default
                scene.add(coreSpheresMesh);

                // Lines
                if(linesMesh) scene.remove(linesMesh);
                const lGeom = new THREE.BufferGeometry();
                // Pre-allocate max size
                const positions = new Float32Array(this.mstEdges.length * 6);
                lGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const lMat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.4 });
                linesMesh = new THREE.LineSegments(lGeom, lMat);
                linesMesh.frustumCulled = false; // Always render
                linesMesh.visible = false;
                scene.add(linesMesh);
            }

            // --- Step & Animation Logic ---
            nextStep() { if(this.step < 4) { this.step++; this.updateStepUI(); } }
            prevStep() { if(this.step > 0) { this.step--; this.updateStepUI(); } }

            updateStepUI() {
                // UI Text
                document.getElementById('step-indicator').innerText = this.step;
                for(let i=0; i<=4; i++) {
                    const el = document.getElementById(`step-desc-${i}`);
                    if(el) el.style.display = (i === this.step) ? 'block' : 'none';
                }

                // Scene objects visibility
                if(coreSpheresMesh) coreSpheresMesh.visible = (this.step === 1 || this.step === 2);
                if(linesMesh) linesMesh.visible = (this.step >= 3);
                
                const cutControl = document.getElementById('cut-control');
                if(this.step === 4) {
                    cutControl.style.opacity = '1';
                    cutControl.style.pointerEvents = 'auto';
                    this.cutTree(); // Apply coloring
                } else {
                    cutControl.style.opacity = '0.5';
                    cutControl.style.pointerEvents = 'none';
                    // Reset colors to default grey
                    for(let i=0; i<this.processedData.length; i++) {
                        pointsMesh.setColorAt(i, new THREE.Color(0x999999));
                        // Reset scales (fix noise shrinking)
                        const dummy = new THREE.Object3D();
                        dummy.position.copy(this.processedData[i].vec);
                        dummy.scale.set(1,1,1);
                        dummy.updateMatrix();
                        pointsMesh.setMatrixAt(i, dummy.matrix);
                    }
                    pointsMesh.instanceColor.needsUpdate = true;
                    pointsMesh.instanceMatrix.needsUpdate = true;

                    // If step 3, show full tree
                    if(this.step === 3) this.drawLines(Infinity);
                }
            }

            drawLines(threshold) {
                const positions = linesMesh.geometry.attributes.position.array;
                let idx = 0;
                for(let e of this.mstEdges) {
                    if(e.weight <= threshold) {
                        const p1 = this.processedData[e.u].vec;
                        const p2 = this.processedData[e.v].vec;
                        positions[idx++] = p1.x; positions[idx++] = p1.y; positions[idx++] = p1.z;
                        positions[idx++] = p2.x; positions[idx++] = p2.y; positions[idx++] = p2.z;
                    }
                }
                // Fill rest with 0 to hide
                for(let i=idx; i<positions.length; i++) positions[i] = 0;
                linesMesh.geometry.attributes.position.needsUpdate = true;
            }

            cutTree() {
                if(this.step !== 4) return;
                const thresh = parseFloat(document.getElementById('cutRange').value);
                document.getElementById('cutVal').innerText = thresh.toFixed(2);

                this.drawLines(thresh);

                // Union Find
                const n = this.processedData.length;
                const parent = Array(n).fill(0).map((_,i)=>i);
                const find = i => parent[i] === i ? i : parent[i] = find(parent[i]);
                const union = (i,j) => {
                    let rootI = find(i), rootJ = find(j);
                    if(rootI !== rootJ) parent[rootI] = rootJ;
                };

                for(let e of this.mstEdges) {
                    if(e.weight <= thresh) union(e.u, e.v);
                }

                // Groups & Colors
                const counts = {};
                for(let i=0; i<n; i++) {
                    let r = find(i);
                    counts[r] = (counts[r]||0) + 1;
                }

                let clusterMap = {};
                let colorIdx = 0;
                let clusters = 0, noise = 0;

                const dummy = new THREE.Object3D();

                for(let i=0; i<n; i++) {
                    let r = find(i);
                    let size = counts[r];
                    let col;

                    if(size >= this.mpts) {
                        // Cluster
                        if(!(r in clusterMap)) {
                            clusterMap[r] = PALETTE[colorIdx % PALETTE.length];
                            colorIdx++;
                            clusters++;
                        }
                        col = new THREE.Color(clusterMap[r]);
                        
                        // Normal size
                        dummy.position.copy(this.processedData[i].vec);
                        dummy.scale.set(1, 1, 1);
                        dummy.updateMatrix();
                        pointsMesh.setMatrixAt(i, dummy.matrix);

                    } else {
                        // Noise
                        col = NOISE_COLOR.clone();
                        noise++;

                        // Make noise points smaller
                        dummy.position.copy(this.processedData[i].vec);
                        dummy.scale.set(0.5, 0.5, 0.5); 
                        dummy.updateMatrix();
                        pointsMesh.setMatrixAt(i, dummy.matrix);
                    }
                    pointsMesh.setColorAt(i, col);
                }

                pointsMesh.instanceColor.needsUpdate = true;
                pointsMesh.instanceMatrix.needsUpdate = true;

                // Adjust noise count logic: `clusters` counts unique groups, `noise` counts points
                // Correct logic: `clusters` is num of groups > mpts.
                document.getElementById('clusterCount').innerText = Object.keys(clusterMap).length;
                document.getElementById('noiseCount').innerText = noise;
            }

            onMouseMove(e) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObject(pointsMesh);
                const tooltip = document.getElementById('tooltip');
                
                if(intersects.length > 0) {
                    const id = intersects[0].instanceId;
                    const d = this.coreDists[id].toFixed(3);
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.clientX + 10 + 'px';
                    tooltip.style.top = e.clientY + 10 + 'px';
                    tooltip.innerHTML = `ID: ${id}<br>Core Dist: ${d}`;
                    
                    // Highlight logic if needed
                } else {
                    tooltip.style.display = 'none';
                }
            }

            onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                controls.update();
                renderer.render(scene, camera);
            }
        }

        window.sim = new HDBSCANSim();
        window.sim.init();

        window.closeModal = function(e) {
             if(e.target.id === 'modal-overlay') e.target.style.display = 'none';
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Voice Classifier</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root { 
            --bg: #f8fafc; --panel: #ffffff; --accent: #2563eb; 
            --text: #1e293b; --text-light: #64748b; --border: #e2e8f0; 
            --red: #dc2626; --blue: #2563eb; --green: #16a34a; --purple: #9333ea;
        }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        header { background: #fff; padding: 0 20px; border-bottom: 1px solid var(--border); height: 50px; display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; }
        h1 { font-size: 1.2rem; color: var(--accent); margin: 0; font-weight: 700; }

        .workspace { display: grid; grid-template-columns: 390px 1fr; height: calc(100vh - 50px); }
        .sidebar { background: var(--panel); border-right: 1px solid var(--border); overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px; }
        .main-view { display: grid; grid-template-rows: 1.5fr 1fr; background: #f1f5f9; overflow: hidden; }
        .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; background: var(--border); }
        .chart-container { background: #fff; position: relative; width: 100%; height: 100%; }

        .card { border: 1px solid var(--border); background: #fff; border-radius: 8px; padding: 15px; position: relative; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .card-header { position: absolute; top: -10px; left: 10px; background: var(--accent); color: white; padding: 2px 8px; font-size: 0.7rem; font-weight: bold; border-radius: 4px; text-transform: uppercase; }
        
        button { width: 100%; padding: 8px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85rem; transition: 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 5px; }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); background: #f1f5f9; color: #94a3b8; }
        .btn-gen { background: #e2e8f0; color: #334155; border: 1px solid #cbd5e1; } .btn-gen:hover { background: #cbd5e1; }
        .btn-train { background: var(--accent); color: #fff; } .btn-train:hover { background: #1d4ed8; }
        .btn-train.stop { background: var(--red); } .btn-train.stop:hover { background: #b91c1c; }
        .btn-reset { background: transparent; border: 1px solid var(--red); color: var(--red); } .btn-reset:hover { background: #fef2f2; }
        
        .rec-row { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .rec-chk { width: 20px; height: 20px; accent-color: var(--accent); cursor: pointer; }

        .btn-class { flex: 1; border: 1px solid #cbd5e1; background: #f8fafc; color: #334155; transition: 0.1s; position: relative; overflow: hidden; margin-bottom: 0;}
        .btn-class:hover:not(:disabled) { background: #e2e8f0; }
        .btn-class.recording { animation: pulseRed 1s infinite; border-color: var(--red); background: #fef2f2; color: var(--red); }
        .btn-class .indicator { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        
        .lab-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px; }
        .btn-audio { background: #0f766e; color: #fff; font-size: 0.8rem; } .btn-audio:hover { background: #115e59; }
        .btn-denoise { background: #7c3aed; color: #fff; font-size: 0.8rem; grid-column: 2 / -1; } .btn-denoise:hover { background: #6d28d9; }

        @keyframes pulseRed { 0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4); } 70% { box-shadow: 0 0 0 6px rgba(220, 38, 38, 0); } 100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); } }

        .progress-bar { height: 6px; background: #e2e8f0; border-radius: 3px; overflow: hidden; margin: 5px 0; }
        .progress-fill { height: 100%; background: var(--green); width: 0%; transition: width 0.2s; }
        
        input[type=range] { width: 100%; accent-color: var(--red); margin: 5px 0; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-light); margin-top: 10px;}

        .overlay-label { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; color: #334155; pointer-events: none; z-index: 10; border: 1px solid #e2e8f0; font-weight: bold;}
        .result-panel { text-align: center; margin-top: 5px; padding: 5px; background: #f1f5f9; border-radius: 6px; border: 1px solid #cbd5e1; transition: background 0.2s; }
        
        #net-canvas { width: 100%; height: 120px; background: #0f172a; border-radius: 6px; margin-top: 10px; border: 1px solid #334155; cursor: pointer; transition: transform 0.1s; }
        #net-canvas:hover { transform: scale(1.02); border-color: var(--accent); }
        
        select { width: 100%; padding: 8px; background: #fff; color: #333; border: 1px solid #cbd5e1; border-radius: 6px; margin-bottom: 10px; font-size: 0.85rem; }
        .param-group { border-top: 1px solid #e2e8f0; margin-top: 10px; padding-top: 10px; }

        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.8);
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; color: var(--accent); font-weight: bold;
            z-index: 50; backdrop-filter: blur(2px);
            display: none;
        }

        /* MODAL */
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); backdrop-filter: blur(3px);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: #fff; padding: 20px; border-radius: 8px; width: 80%; max-width: 800px;
            max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .matrix-table { width: 100%; border-collapse: collapse; font-family: monospace; font-size: 0.8rem; margin-bottom: 20px; }
        .matrix-table td, .matrix-table th { border: 1px solid #cbd5e1; padding: 4px; text-align: center; }
        .matrix-table th { background: #f1f5f9; }
        .close-modal { float: right; font-size: 1.5rem; font-weight: bold; cursor: pointer; color: #64748b; }
        .close-modal:hover { color: #000; }

        /* Theory Styles */
        details.theory-spoiler {
            background: #fff; border: 1px solid var(--border);
            border-radius: 8px; margin: 10px 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        details.theory-spoiler summary {
            padding: 10px 15px; cursor: pointer; font-weight: bold;
            color: var(--accent); list-style: none; outline: none;
            display: flex; align-items: center; justify-content: space-between;
        }
        details.theory-spoiler summary::after { content: '+'; font-size: 1.2rem; }
        details.theory-spoiler[open] summary::after { content: '-'; }
        
        .theory-content {
            padding: 15px 20px; border-top: 1px solid var(--border);
            font-size: 0.9rem; line-height: 1.6; color: #334155;
            max-height: 60vh; overflow-y: auto; 
            background: #f8fafc;
        }
        .theory-content h3 { margin-top: 20px; color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; }
        .theory-content h4 { margin-top: 15px; color: #475569; font-weight: 700; }
        .theory-content ul { padding-left: 20px; }
        .theory-content li { margin-bottom: 5px; }
        .math-block { 
            background: #fff; padding: 10px; border-radius: 6px; 
            border: 1px solid #e2e8f0; margin: 10px 0; overflow-x: auto; 
            text-align: center; font-family: 'Times New Roman', serif;
        }
    </style>
    
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true
        },
        svg: { fontCache: 'global' }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<details class="theory-spoiler">
    <summary>üìö –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –î–æ–≤—ñ–¥–∫–∞: –ù–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞-–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ç–æ—Ä (Encoder + Softmax)</summary>
    <div class="theory-content">
        <h3>1. –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ç–æ—Ä</h3>
        <p>
          
            –ú–µ—Ä–µ–∂–∞ –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è –≤—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏ –Ω–∞ –ø–∏—Ç–∞–Ω–Ω—è: <em>"–Ø–∫–∞ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å, —â–æ —Ü–µ –ª—ñ—Ç–µ—Ä–∞ –ê?"</em>.
        </p>

        <h3>2. –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –ú–µ—Ä–µ–∂—ñ</h3>
        <ul>
            <li><strong>Input Layer (12 –Ω–µ–π—Ä–æ–Ω—ñ–≤):</strong> –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ñ –æ–∑–Ω–∞–∫–∏ –∑–≤—É–∫—É $x$.</li>
            <li><strong>Hidden Layer (2 –Ω–µ–π—Ä–æ–Ω–∏):</strong> –¶–µ –Ω–∞—à "—Å—Ç–∏—Å–Ω—É—Ç–∏–π" –ø—Ä–æ—Å—Ç—ñ—Ä (Latent Space). –ú–∏ —Å—Ç–∏—Å–∫–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ–π–Ω—ñ –≤–µ–∫—Ç–æ—Ä–∏ 12-–≤–∏–º—ñ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 12 —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∏—Ö —Å–º—É–≥, –∞–±–æ 12 –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —Ñ–æ—Ä–º–∞–Ω—Ç –≥–æ–ª–æ—Å—É) –¥–æ 2 —á–∏—Å–µ–ª $(z_1, z_2)$, —â–æ –≤—ñ–∑—É–∞–ª—ñ–∑—É—î—Ç—å—Å—è —è–∫ —Ç–æ—á–∫–∞ –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ (–¥–≤–æ–≤–∏–º—ñ—Ä–Ω–æ–º—É –ø—Ä–æ—Å—Ç–æ—Ä—ñ).
                $$ z = \sigma(W^{(1)} x + b^{(1)}) $$
            </li>
            <li><strong>Output Layer (4 –Ω–µ–π—Ä–æ–Ω–∏):</strong> –ü–æ –æ–¥–Ω–æ–º—É –Ω–µ–π—Ä–æ–Ω—É –Ω–∞ –∫–æ–∂–Ω—É –ª—ñ—Ç–µ—Ä—É (A, O, I, U).
                $$ logits = W^{(2)} z + b^{(2)} $$
            </li>
			
			  <p>–¥–µ:</p>
			<ul>
            <li>$W^{(1)}$ ‚Äî –º–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ —Ä–æ–∑–º—ñ—Ä–æ–º $m \times n$ (—É –Ω–∞—Å $2 \times 12$). –í–∞–≥–∏ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ —Å–∏–ª—å–Ω–æ –∫–æ–∂–µ–Ω –≤—Ö—ñ–¥ –≤–ø–ª–∏–≤–∞—î –Ω–∞ –∫–æ–∂–µ–Ω –Ω–µ–π—Ä–æ–Ω –ø—Ä–∏—Ö–æ–≤–∞–Ω–æ–≥–æ —à–∞—Ä—É. –°–∞–º–µ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ñ W –∑–º—ñ–Ω—é—é—Ç—å—Å—è –ø—ñ–¥ —á–∞—Å –Ω–∞–≤—á–∞–Ω–Ω—è, –º–µ—Ä–µ–∂–∞ —à—É–∫–∞—î –Ω–∞–π–∫—Ä–∞—â—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ —Ü—ñ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤</li>
            <li>$b^{(1)}$ ‚Äî –≤–µ–∫—Ç–æ—Ä <strong>–∑—Å—É–≤—É (Bias)</strong>. –í—ñ–Ω –¥–æ–∑–≤–æ–ª—è—î –∑–º—ñ—â—É–≤–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó –≤–ª—ñ–≤–æ/–≤–ø—Ä–∞–≤–æ. –ë–µ–∑ bias –º–µ—Ä–µ–∂–∞ –º–æ–≥–ª–∞ –± –ø—Ä–æ—Ö–æ–¥–∏—Ç–∏ –ª–∏—à–µ —á–µ—Ä–µ–∑ –ø–æ—á–∞—Ç–æ–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç $(0,0)$, —â–æ –æ–±–º–µ–∂—É—î —ó—ó –≥–Ω—É—á–∫—ñ—Å—Ç—å. –¶—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ —Ç–∞–∫–æ–∂ –Ω–∞–≤—á–∞—é—Ç—å—Å—è</li>
            <li>$z$ ‚Äî –ª–∞—Ç–µ–Ω—Ç–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (–ø—Ä–∏—Ö–æ–≤–∞–Ω–∏–π —Å—Ç–∞–Ω). –£ –Ω–∞—à–æ–º—É –≤–∏–ø–∞–¥–∫—É $z \in \mathbb{R}^2$, —â–æ –¥–æ–∑–≤–æ–ª—è—î –∑–æ–±—Ä–∞–∑–∏—Ç–∏ –π–æ–≥–æ –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ.</li>
			 <li>–ê–Ω–∞–ª–æ–≥—ñ—á–Ω–æ –¥–ª—è –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤–µ–∫—Ç–æ—Ä—É –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É (–¥–≤–æ–≤–∏–º—ñ—Ä–Ω–æ–≥–æ) —É –ø—Ä–æ—Å—Ç—ñ—Ä —Å–∏–º–≤–æ–ª—ñ–≤, –≤–∏–∫–æ—Ä–∏—Å—Ç—É–≤—É—î—Ç—å—Å—è –º–∞—Ç—Ä–∏—Ü—è $W^{(2)}$ ‚Äî –º–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ —Ä–æ–∑–º—ñ—Ä–æ–º $k \times m$ (—É –Ω–∞—Å $4 \times 2$, –±–æ –Ω–∞—à–∞ —ñ–≥—Ä–∞—à–∫–æ–≤–∞ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞—î –º–∞–∫—Å–∏–º—É–º 4 –±—É–∫–≤–∏).</li>
		   <li>$\sigma(\cdot)$ ‚Äî <strong>—Ñ—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó</strong>.</li>
			</ul>
			
			 <p>
            –£ –ø—Ä–∏—Ä–æ–¥—ñ –Ω–µ–π—Ä–æ–Ω –Ω–µ –ø—Ä–æ—Å—Ç–æ —Å—É–º—É—î —Å–∏–≥–Ω–∞–ª–∏, –≤—ñ–Ω –º–∞—î –ø–æ—Ä—ñ–≥ –∑–±—É–¥–∂–µ–Ω–Ω—è —ñ "–Ω–∞—Å–∏—á–µ–Ω–Ω—è" (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—É —á–∞—Å—Ç–æ—Ç—É —ñ–º–ø—É–ª—å—Å—ñ–≤). –©–æ–± –∑–º–æ–¥–µ–ª—é–≤–∞—Ç–∏ —Ü–µ, –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–µ–ª—ñ–Ω—ñ–π–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é. –û–¥–Ω–∞ –∑ –Ω–∞–π–ø–æ–ø—É–ª—è—Ä–Ω—ñ—à–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó -—Ü–µ <strong>–°–∏–≥–º–æ—ó–¥–∞ (Sigmoid)</strong>:
        </p>
        <div class="math-block">
            $$ \sigma(u) = \frac{1}{1 + e^{-u}} $$
        </div>
        <p>
            <strong>–ù–∞–≤—ñ—â–æ —Ü–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ?</strong> –Ø–∫–±–∏ –º–∏ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–ª–∏ $\sigma$, –≤—Å—è –º–µ—Ä–µ–∂–∞ $ z = W^{(2)}(W^{(1)}x $ –∑–≤–µ–ª–∞—Å—è –± –¥–æ –æ–¥–Ω—ñ—î—ó –ª—ñ–Ω—ñ–π–Ω–æ—ó –º–∞—Ç—Ä–∏—Ü—ñ $W = W^{(2)}W^{(1)}$. –ù–µ–ª—ñ–Ω—ñ–π–Ω—ñ—Å—Ç—å –¥–æ–∑–≤–æ–ª—è—î –º–µ—Ä–µ–∂—ñ –≤–∏–≤—á–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ –∫—Ä–∏–≤–æ–ª—ñ–Ω—ñ–π–Ω—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö, –∞ –Ω–µ —Ç—ñ–ª—å–∫–∏ –ø–ª–æ—Å–∫—ñ –≥—ñ–ø–µ—Ä–ø–ª–æ—â–∏–Ω–∏.
        </p>
			
        </ul>

        <h3>3. Softmax Activation</h3>
        <p>
            –©–æ–± –ø–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ –≤–∏—Ö—ñ–¥–Ω—ñ —á–∏—Å–ª–∞ (logits) —É –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ (–≤—ñ–¥ 0% –¥–æ 100%), –≤ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞—Ö —á–∞—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å —Ñ—É–Ω–∫—Ü—ñ—é <strong>Softmax</strong>. –í–æ–Ω–∞ –≥–∞—Ä–∞–Ω—Ç—É—î, —â–æ —Å—É–º–∞ –≤—Å—ñ—Ö –≤–∏—Ö–æ–¥—ñ–≤ –¥–æ—Ä—ñ–≤–Ω—é—î 1.
        </p>
        <div class="math-block">
            $$ P(y_i) = \frac{e^{logits_i}}{\sum_{j=1}^{4} e^{logits_j}} $$
        </div>
        <p>–î–µ $P(y_i)$ ‚Äî —Ü–µ –≤–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å –º–µ—Ä–µ–∂—ñ —É –∫–ª–∞—Å—ñ $i$.</p>

        <h3>4. –§—É–Ω–∫—Ü—ñ—è –í—Ç—Ä–∞—Ç: Cross-Entropy</h3>
        <p>
            –û—Å–∫—ñ–ª—å–∫–∏ –º–∏ –º–∞—î–º–æ —Ä–æ–∑–º—ñ—á–µ–Ω—ñ –¥–∞–Ω—ñ (–º–∏ –∑–Ω–∞—î–º–æ, –¥–µ "–ê", –∞ –¥–µ "–û", —Ü–µ –Ω–∞–≤—á–∞–Ω–Ω—è –∑ –≤—á–∏—Ç–µ–ª–µ–º, supervized learning), –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ <strong>Categorical Cross-Entropy Loss</strong> –∑–∞–º—ñ—Å—Ç—å –∑–≤–∏—á–∞–π–Ω–æ—ó —Å–µ—Ä–µ–¥–Ω—å–æ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ—ó –ø–æ–º–∏–ª–∫–∏ (MSE). –¶—è —Ñ—É–Ω–∫—Ü—ñ—è –∫—Ä–æ—Å—Å-–µ–Ω—Ç—Ä–æ–ø—ñ—ó –¥—É–∂–µ —Å–∏–ª—å–Ω–æ "–∫–∞—Ä–∞—î" –º–µ—Ä–µ–∂—É, —è–∫—â–æ –≤–æ–Ω–∞ –≤–ø–µ–≤–Ω–µ–Ω–æ –∫–∞–∂–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å.
        </p>
        <div class="math-block">
            $$ L = - \sum_{i=1}^{4} t_i \cdot \log(p_i) $$
        </div>
        <p>
            –î–µ $t$ ‚Äî —Ü–µ "one-hot" –≤–µ–∫—Ç–æ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ—ó –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è "–ê" —Ü–µ $[1, 0, 0, 0]$), –∞ $p$ ‚Äî –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è –º–µ—Ä–µ–∂—ñ.
        </p>

        <h3>5. –ù–∞–≤—á–∞–Ω–Ω—è (Backpropagation)</h3>
        <p>
            –ü–æ—Ö—ñ–¥–Ω–∞ –≤—ñ–¥ Cross-Entropy + Softmax –≤–∏–≥–ª—è–¥–∞—î –¥—É–∂–µ –ø—Ä–æ—Å—Ç–æ:
            $$ \frac{\partial L}{\partial logits} = p - t $$
            –¢–æ–±—Ç–æ –ø–æ–º–∏–ª–∫–∞ ‚Äî —Ü–µ –ø—Ä–æ—Å—Ç–æ —Ä—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ –ø—Ä–æ–≥–Ω–æ–∑–æ–º (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 0.7) —ñ —ñ—Å—Ç–∏–Ω–æ—é (1.0). –¶–µ–π —Å–∏–≥–Ω–∞–ª –ø–æ–º–∏–ª–∫–∏ –º–∏ –ø–µ—Ä–µ–¥–∞—î–º–æ –Ω–∞–∑–∞–¥ —á–µ—Ä–µ–∑ –º–µ—Ä–µ–∂—É, —â–æ–± –æ–Ω–æ–≤–∏—Ç–∏ –≤–∞–≥–∏ $W^{(1)}$ —Ç–∞ $W^{(2)}$.
        </p>
    </div>
</details>

<div class="workspace">
    <div class="sidebar">
        <div class="card">
            <div class="card-header">1. –ü–∞—Ä–∞–º–µ—Ç—Ä–∏</div>
            <div style="margin-top: 10px;">
                <label style="font-size:0.75rem; color:var(--text-light)">–¢–∏–ø –≤—Ö–æ–¥—É:</label>
                <select id="feat-select" onchange="App.changeFeatureType()">
                    <option value="mel">üìä Mel-Spectrogram (12 —Å–º—É–≥)</option>
                    <option value="formant">üèî Formants (Dual-Band Search)</option>
                </select>

                <button class="btn-gen" id="btn-auto-gen" onclick="App.autoGenerate()">üé∂ –°–∏–Ω—Ç–µ—Ç–∏—á–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—è</button>
                
                <div style="font-size:0.75rem; color:var(--text-light); margin: 15px 0 5px 0; font-weight:bold">–î–∞–Ω—ñ –¥–ª—è –Ω–∞–≤—á–∞–Ω–Ω—è: –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å —ñ —Å–∫–∞–∂—ñ—Ç—å –±—É–∫–≤—É(–∫—Ä–∞—â–µ –ø—Ä–æ—Ç—è–≥–Ω—ñ—Ç—å –¥–æ–≤–≥–æ –ê-–ê-–ê-–ê):</div>
                
                <div class="rec-row">
                    <input type="checkbox" class="rec-chk" id="chk-A" checked onchange="App.toggleBtn('A')">
                    <button class="btn-class" id="btn-rec-A" onclick="App.toggleRec('A')"><span class="indicator" style="background:var(--red)"></span> –ó–∞–ø–∏—Å "–ê" <span id="cnt-A" style="float:right; opacity:0.5">0</span></button>
                </div>
                <div class="rec-row">
                    <input type="checkbox" class="rec-chk" id="chk-O" checked onchange="App.toggleBtn('O')">
                    <button class="btn-class" id="btn-rec-O" onclick="App.toggleRec('O')"><span class="indicator" style="background:var(--blue)"></span> –ó–∞–ø–∏—Å "–û" <span id="cnt-O" style="float:right; opacity:0.5">0</span></button>
                </div>
                <div class="rec-row">
                    <input type="checkbox" class="rec-chk" id="chk-I" checked onchange="App.toggleBtn('I')">
                    <button class="btn-class" id="btn-rec-I" onclick="App.toggleRec('I')"><span class="indicator" style="background:var(--green)"></span> –ó–∞–ø–∏—Å "–Ü" <span id="cnt-I" style="float:right; opacity:0.5">0</span></button>
                </div>
                <div class="rec-row">
                    <input type="checkbox" class="rec-chk" id="chk-U" checked onchange="App.toggleBtn('U')">
                    <button class="btn-class" id="btn-rec-U" onclick="App.toggleRec('U')"><span class="indicator" style="background:var(--purple)"></span> –ó–∞–ø–∏—Å "–£" <span id="cnt-U" style="float:right; opacity:0.5">0</span></button>
                </div>

                <div style="display:flex; gap:5px; margin-top:10px;">
                    <button onclick="App.clearData()" style="flex:1; background:transparent; border:1px solid #cbd5e1; color:#64748b; font-size:0.75rem">üóë –í–∏–¥–∞–ª–∏—Ç–∏</button>
                    <button class="btn-reset" onclick="App.resetModel()" style="flex:1; font-size:0.75rem">üîÑ –°–∫–∏–Ω—É—Ç–∏ –≤—Å–µ</button>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">2. –ù–∞–≤—á–∞–Ω–Ω—è (Supervised)</div>
            <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:var(--text-light); margin-top:5px;">
                <span>–ï–ø–æ—Ö–∏: <span id="val-epoch">0</span></span>
                <span>Loss: <span id="val-loss" style="color:var(--accent)">-</span></span>
            </div>
            <button class="btn-train" id="btn-train" onclick="App.toggleTrain()">üöÄ –°—Ç–∞—Ä—Ç –ù–∞–≤—á–∞–Ω–Ω—è</button>
            <div class="progress-bar"><div class="progress-fill" id="train-prog"></div></div>
            <div style="font-size:0.7rem; color:#64748b; text-align:center;">–ö–ª—ñ–∫–Ω—ñ—Ç—å –Ω–∞ –≥—Ä–∞—Ñ –∑–Ω–∏–∑—É, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –≤–∞–≥–∏</div>
			
			<canvas id="net-canvas" width="320" height="120" title="–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å, —â–æ–± –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ñ"></canvas>

            <div class="param-group">
                <label style="font-size:0.75rem; color:var(--text-light)">–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –ì—Ä–∞–Ω–∏—Ü—å (–≤–∏–±–µ—Ä—ñ—Ç—å –º–µ—Ç–æ–¥):</label>
                <select id="boundary-select" onchange="App.updateLatentPlot(true)">
                   
                    <option value="voronoi">KNN</option>
					 <option value="net">–õ—ñ–Ω—ñ–π–Ω—ñ –∫–ª–∞—Å—Ç–µ—Ä–∏</option>
                </select>
            </div>
        </div>

        <div class="card" style="flex:1; display:flex; flex-direction:column;">
            <div class="card-header">3. –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è</div>
            <button class="btn-class" id="btn-rec-test" onclick="App.toggleTestRec()" style="margin-top:10px">üé§ Live –¢–ï–°–¢</button>
            
            <div class="slider-label"><span>–í—Ö—ñ–¥–Ω–∏–π –®—É–º</span> <span id="val-noise">0%</span></div>
            <input type="range" id="slider-noise" min="0" max="100" value="0" oninput="App.setTestNoise(this.value)">

            <div class="slider-label"><span>–ü–µ—Ä—ñ–æ–¥ —É—Å–µ—Ä–µ–¥–Ω–µ–Ω–Ω—è</span> <span id="val-smooth">5</span></div>
            <input type="range" id="slider-smooth" min="1" max="20" value="5" oninput="App.setSmoothing(this.value)">

            <div class="result-panel">
                <div style="font-size:2rem; font-weight:bold; color:var(--text)" id="res-char">?</div>
                <div style="font-size:0.75rem; color:var(--text-light)" id="res-conf">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</div>
            </div>

            <div class="lab-controls">
                <button class="btn-audio" onclick="App.playOriginal()">üëÇ –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
                <button class="btn-denoise" onclick="App.playReconstructed()">üó£ –°–∏–Ω—Ç–µ–∑ (–∑–∞ –∫–ª–∞—Å–æ–º)</button>
            </div>
        </div>
    </div>

    <div class="main-view">
        <div class="chart-container" style="border-bottom:1px solid var(--border)">
            <div class="overlay-label">–õ–∞—Ç–µ–Ω—Ç–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä (–ü—Ä–∏—Ö–æ–≤–∞–Ω–∏–π —à–∞—Ä)</div>
            <div id="loading-overlay">‚è≥ –û–±—Ä–∞—Ö—É–Ω–æ–∫...</div>
            <div id="plot-latent" style="width:100%; height:100%"></div>
        </div>
        <div class="charts-row">
            <div class="chart-container">
                <div class="overlay-label" style="color:#eab308">–í—Ö—ñ–¥ (–°–ø–µ–∫—Ç—Ä)</div>
                <div id="plot-input" style="width:100%; height:100%"></div>
            </div>
            <div class="chart-container">
                <div class="overlay-label" style="color:#16a34a">–ô–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ –ö–ª–∞—Å—ñ–≤ (Softmax)</div>
                <div id="plot-output" style="width:100%; height:100%"></div>
            </div>
        </div>
    </div>
</div>

<div id="weights-modal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="App.closeModal()">&times;</span>
        <h2 style="color:var(--text)">–ú–∞—Ç—Ä–∏—Ü—ñ –í–∞–≥ –ù–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ</h2>
        
        <h3>Input Layer -> Hidden Layer</h3>
        <p>W1 [2 x 12] (Weights) + B1 [2] (Bias)</p>
        <div id="table-enc"></div>

        <h3>Hidden Layer -> Output (Softmax)</h3>
        <p>W2 [4 x 2] (Weights) + B2 [4] (Bias)</p>
        <div id="table-dec"></div>
    </div>
</div>

<script>
/* =========================================
   AUDIO ENGINE (Unchanged from original)
   ========================================= */
const AudioSys = {
    ctx: null,
    analyser: null,
    micStreamNode: null, 
    masterGain: null,
    noiseBuffer: null,
    oscillators: [],
    
    featureType: 'mel', 
    INPUT_SIZE: 12,     
    
    // Formant Frequencies for synthesis
    vowels: {
        'A': [730, 1090, 2440],
        'O': [570, 840, 2410],
        'I': [270, 2290, 3010],
        'U': [300, 870, 2240]
    },

    async init() {
        if(this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 2048; 
        this.analyser.smoothingTimeConstant = 0.5;
        this.masterGain.connect(this.analyser);

        const bufSize = this.ctx.sampleRate * 2; 
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
        this.noiseBuffer = buffer;
    },

    async initMic() {
        if(this.micStreamNode) return true;
        try {
            await this.ctx.resume();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.micStreamNode = this.ctx.createMediaStreamSource(stream);
            this.micStreamNode.connect(this.analyser);
            return true;
        } catch(e) {
            console.error(e);
            return false;
        }
    },

    startTone(vowel, freq = 0) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        this.stopTone();
        if(!this.vowels[vowel]) return;

        const basePitch = freq || 130; 
        const freqs = this.vowels[vowel];
        const now = this.ctx.currentTime;
        
        freqs.forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(f, now);
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = f;
            filter.Q.value = 4;
            
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime((1.0 / (i + 1)) * 0.3, now + 0.05);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            this.oscillators.push({osc, gain, type: 'tone'});
        });
        
        const createFund = (detuneVal) => {
            const fund = this.ctx.createOscillator();
            fund.type = 'sawtooth';
            fund.frequency.value = basePitch;
            fund.detune.value = detuneVal; 
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            const fundGain = this.ctx.createGain();
            fundGain.gain.setValueAtTime(0, now);
            fundGain.gain.linearRampToValueAtTime(0.08, now + 0.05);
            fund.connect(filter);
            filter.connect(fundGain);
            fundGain.connect(this.masterGain);
            fund.start();
            this.oscillators.push({osc: fund, gain: fundGain, type: 'tone'});
        };
        createFund(-5);
        createFund(5);
    },

    stopTone() {
        const now = this.ctx.currentTime;
        this.oscillators.forEach(o => {
            try {
                 o.gain.gain.cancelScheduledValues(now);
                 o.gain.gain.setValueAtTime(o.gain.gain.value, now);
                 o.gain.gain.linearRampToValueAtTime(0, now + 0.1);
                 o.osc.stop(now + 0.15);
            } catch(e){}
        });
        this.oscillators = [];
    },

    playVowelShot(vowel, duration, pitch) {
        this.startTone(vowel, pitch);
        setTimeout(() => this.stopTone(), duration * 1000);
    },

    playBuffer(buffer, noiseLevel) {
        if(!buffer) return;
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        const master = this.ctx.createGain();
        master.gain.value = 0.8;
        master.connect(this.ctx.destination);
        src.connect(master);
        src.start();

        if(noiseLevel > 0.01) {
            const nSrc = this.ctx.createBufferSource();
            nSrc.buffer = this.noiseBuffer;
            nSrc.loop = true;
            const nGain = this.ctx.createGain();
            nGain.gain.value = noiseLevel * 0.5; 
            nSrc.connect(nGain);
            nGain.connect(master);
            nSrc.start();
            nSrc.stop(this.ctx.currentTime + buffer.duration);
        }
    },

    getFeatures() {
        if(this.featureType === 'mel') return this.getMelFeatures();
        else return this.getFormantFeatures();
    },

    getMelFeatures() {
        const binCount = this.analyser.frequencyBinCount; 
        const data = new Uint8Array(binCount);
        this.analyser.getByteFrequencyData(data);
        const bandWidths = [2, 2, 3, 3, 4, 6, 8, 12, 18, 26, 38, 50]; 
        const features = [];
        let currentBin = 2; 
        for (let i = 0; i < this.INPUT_SIZE; i++) {
            let sum = 0;
            const width = bandWidths[i];
            for (let j = 0; j < width; j++) if (currentBin < binCount) sum += data[currentBin++];
            let val = (sum / width) / 255;
            val = Math.log10(1 + 9 * val); 
            features.push(val);
        }
        return features;
    },

    getFormantFeatures() {
        const binCount = this.analyser.frequencyBinCount;
        const data = new Uint8Array(binCount);
        this.analyser.getByteFrequencyData(data);
        const nyquist = this.ctx.sampleRate / 2;
        
        const smoothed = new Float32Array(binCount);
        const w = 4;
        for(let i=w; i<binCount-w; i++) {
            let sum = 0;
            for(let k=-w; k<=w; k++) sum += data[i+k];
            smoothed[i] = sum / (2*w+1);
        }

        let maxVal1 = 0, maxIdx1 = 0;
        for(let i=0; i<binCount; i++) {
            const freq = i * nyquist / binCount;
            if(freq > 200 && freq < 900) {
                if(smoothed[i] > maxVal1) { maxVal1 = smoothed[i]; maxIdx1 = i; }
            }
        }
        let maxVal2 = 0, maxIdx2 = 0;
        for(let i=0; i<binCount; i++) {
            const freq = i * nyquist / binCount;
            if(freq > 900 && freq < 3000) {
                if(smoothed[i] > maxVal2) { maxVal2 = smoothed[i]; maxIdx2 = i; }
            }
        }

        const vec = new Array(this.INPUT_SIZE).fill(0);
        if(maxVal1 > 10) {
            vec[0] = (maxIdx1 * nyquist / binCount) / 5000;
            vec[1] = maxVal1 / 255;
        }
        if(maxVal2 > 10) {
            vec[2] = (maxIdx2 * nyquist / binCount) / 5000;
            vec[3] = maxVal2 / 255;
        }
        return vec;
    },

    async recordClip(durationMs) {
        await this.initMic();
        const dest = this.ctx.createMediaStreamDestination();
        this.micStreamNode.connect(dest);
        const recorder = new MediaRecorder(dest.stream);
        const chunks = [];
        return new Promise(resolve => {
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = async () => {
                this.micStreamNode.disconnect(dest); 
                const blob = new Blob(chunks, { type: 'audio/webm' });
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                resolve(audioBuffer);
            };
            recorder.start();
            this.activeRecorder = recorder;
            setTimeout(() => this.stopRecorder(), durationMs);
        });
    },
    
    stopRecorder() {
        if(this.activeRecorder && this.activeRecorder.state === 'recording') {
            this.activeRecorder.stop();
        }
    }
};

/* =========================================
   ML ENGINE: CLASSIFIER (Refactored)
   ========================================= */
class Classifier {
    constructor() { 
        this.inputSize = 12; 
        this.latentSize = 2; // Hidden layer
        this.outputSize = 4; // Classes: A, O, I, U
        this.labels = ['A', 'O', 'I', 'U'];
        this.reset(); 
    }
    
    reset() {
        // Xavier/Glorot initialization approximation
        const initLim1 = Math.sqrt(6 / (this.inputSize + this.latentSize));
        const initLim2 = Math.sqrt(6 / (this.latentSize + this.outputSize));
        
        this.W1 = this.rand(this.latentSize, this.inputSize, initLim1); 
        this.b1 = Array(this.latentSize).fill(0);
        
        this.W2 = this.rand(this.outputSize, this.latentSize, initLim2); 
        this.b2 = Array(this.outputSize).fill(0);
        
        this.centroids = null; 
    }
    
    rand(r,c, lim) { return Array(r).fill(0).map(()=>Array(c).fill(0).map(()=>(Math.random()*2-1)*lim)); }
    sigmoid(x) { return 1/(1+Math.exp(-x)); }
    dsigmoid(y) { return y*(1-y); }
    
    // Softmax Activation
    softmax(arr) {
        const max = Math.max(...arr); // Numerical stability
        const exps = arr.map(x => Math.exp(x - max));
        const sum = exps.reduce((a,b) => a+b, 0);
        return exps.map(x => x / sum);
    }

    forward(x) {
        // Layer 1: Encoder/Hidden
        const z_net = this.b1.map((b,i) => b + x.reduce((a,v,j)=>a+v*this.W1[i][j],0));
        const z = z_net.map(val => this.sigmoid(val));
        
        // Layer 2: Output (Logits)
        const logits = this.b2.map((b,i) => b + z.reduce((a,v,j)=>a+v*this.W2[i][j],0));
        
        // Activation: Softmax
        const probs = this.softmax(logits);
        
        return { z, probs };
    }
    
    // Train using Cross-Entropy Loss
    train(input, labelStr, lr=0.1) { 
        const targetIdx = this.labels.indexOf(labelStr);
        if(targetIdx === -1) return 0;

        // One-hot encoding implied: target vector has 1.0 at targetIdx, 0.0 elsewhere
        const {z, probs} = this.forward(input);

        // --- Backpropagation ---
        
        // 1. Error at Output (Cross-Entropy + Softmax derivative is simply P - T)
        const d_scores = probs.map((p, i) => i === targetIdx ? p - 1 : p);
        
        // 2. Error at Hidden Layer
        const d_z = z.map((h,i)=> {
            let s=0; for(let j=0; j<this.outputSize; j++) s+=d_scores[j]*this.W2[j][i];
            return s * this.dsigmoid(h); // Apply activation derivative
        });
        
        // 3. Update Weights & Biases
        
        // Update Layer 2 (Hidden -> Output)
        for(let i=0; i<this.outputSize; i++) {
            this.b2[i] -= lr * d_scores[i];
            for(let j=0; j<this.latentSize; j++) {
                this.W2[i][j] -= lr * d_scores[i] * z[j];
            }
        }
        
        // Update Layer 1 (Input -> Hidden)
        for(let i=0; i<this.latentSize; i++) {
            this.b1[i] -= lr * d_z[i];
            for(let j=0; j<this.inputSize; j++) {
                this.W1[i][j] -= lr * d_z[i] * input[j];
            }
        }
        
        // Calculate Loss: -log(p_target)
        return -Math.log(probs[targetIdx] + 1e-10);
    }

    computeCentroids(dataset) {
        // Just for visualization of "Data Points" on the graph
        const clusters = { 'A':{z:[]}, 'O':{z:[]}, 'I':{z:[]}, 'U':{z:[]} };
        dataset.forEach(d => {
            if(clusters[d.label]) {
                clusters[d.label].z.push(this.forward(d.data).z);
            }
        });
        this.centroids = {};
        for(let k in clusters) {
            if(clusters[k].z.length === 0) continue;
            const N = clusters[k].z.length;
            let sx=0, sy=0;
            clusters[k].z.forEach(p => { sx+=p[0]; sy+=p[1]; });
            this.centroids[k] = { coords: [sx/N, sy/N] };
        }
    }
    
    // Predict via Network (Forward pass)
    predict(z) {
        // Note: z is already computed from W1. We need to manually pass it through W2 + Softmax
        // This is a helper to predict purely from a latent point (x,y) for visualization
        const logits = this.b2.map((b,i) => b + z.reduce((a,v,j)=>a+v*this.W2[i][j],0));
        const probs = this.softmax(logits);
        
        // Find max
        let maxP = -1, maxIdx = 0;
        probs.forEach((p,i) => { if(p>maxP){ maxP=p; maxIdx=i;} });
        
        return { label: this.labels[maxIdx], conf: maxP };
    }
    
    // For manual KNN backup (optional)
    predictKNN(z, dataset, k=5) {
        if(dataset.length === 0) return { label: '?', conf: 0 };
        const dists = dataset.map(d => {
            const lat = this.forward(d.data).z;
            return { l: d.label, d: Math.sqrt((z[0]-lat[0])**2 + (z[1]-lat[1])**2) };
        });
        dists.sort((a,b) => a.d - b.d);
        const top = dists.slice(0, k);
        const counts = { 'A':0, 'O':0, 'I':0, 'U':0 };
        top.forEach(t => { if(counts[t.l] !== undefined) counts[t.l]++; });
        let maxC = 0, label = '?';
        for(let key in counts) {
            if(counts[key] > maxC) { maxC = counts[key]; label = key; }
        }
        return { label, conf: maxC/k };
    }
}

/* =========================================
   APP LOGIC
   ========================================= */
const App = {
    net: new Classifier(),
    dataset: [],
    testSample: { audio: null, features: null, output: null, label: '?' },
    testHistory: [], 
    colors: { 'A': '#dc2626', 'O': '#2563eb', 'I': '#16a34a', 'U': '#9333ea' },
    activeRecLabel: null,
    testRecActive: false,
    testNoiseLevel: 0,
    smoothingFactor: 5, 
    zBuffer: [], 
    
    isTraining: false, 

    async init() {
        await AudioSys.init();
        this.initPlots();
        this.drawNet(); 
        document.getElementById('net-canvas').addEventListener('click', () => this.showWeightsModal());
    },
    
    changeFeatureType() {
        const val = document.getElementById('feat-select').value;
        AudioSys.featureType = val;
        this.clearData(); 
        Plotly.relayout('plot-input', { 'xaxis.title': val === 'mel' ? 'Freq Bands' : 'Formants (F1,A1...)' });
    },

    toggleBtn(label) {
        const chk = document.getElementById(`chk-${label}`);
        const btn = document.getElementById(`btn-rec-${label}`);
        btn.disabled = !chk.checked;
    },

    // VISUALIZE CLASSIFIER STRUCTURE
    drawNet() {
        const cvs = document.getElementById('net-canvas');
        if(!cvs) return;
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        
        const layers = [12, 2, 4]; // 12 Input, 2 Hidden, 4 Output
        const layerX = [30, cvs.width/2, cvs.width - 30];
        
        ctx.lineCap = 'round';
        // Input -> Hidden (W1)
        for(let i=0; i<layers[0]; i++) {
            for(let j=0; j<layers[1]; j++) {
                const w = Math.abs(this.net.W1[j][i]); 
                ctx.beginPath();
                ctx.moveTo(layerX[0], (i+1)*(cvs.height/(layers[0]+1)));
                ctx.lineTo(layerX[1], (j+1)*(cvs.height/(layers[1]+1)));
                ctx.strokeStyle = `rgba(56, 189, 248, ${Math.min(1, w * 0.5 + 0.1)})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        // Hidden -> Output (W2)
        for(let i=0; i<layers[1]; i++) {
             for(let j=0; j<layers[2]; j++) {
                const w = Math.abs(this.net.W2[j][i]);
                ctx.beginPath();
                ctx.moveTo(layerX[1], (i+1)*(cvs.height/(layers[1]+1)));
                ctx.lineTo(layerX[2], (j+1)*(cvs.height/(layers[2]+1)));
                ctx.strokeStyle = `rgba(74, 222, 128, ${Math.min(1, w * 0.5 + 0.1)})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        // Nodes
        layers.forEach((count, lIdx) => {
            for(let i=0; i<count; i++) {
                const x = layerX[lIdx];
                const y = (i+1)*(cvs.height/(count+1));
                ctx.beginPath();
                const rad = lIdx === 1 ? 8 : (lIdx === 2 ? 6 : 3); 
                ctx.arc(x, y, rad, 0, Math.PI*2);
                // Colors: Input(Blue), Hidden(White), Output(Class Colors)
                if(lIdx === 2) {
                     const cols = ['#dc2626', '#2563eb', '#16a34a', '#9333ea'];
                     ctx.fillStyle = cols[i];
                } else {
                     ctx.fillStyle = lIdx === 1 ? '#fff' : '#38bdf8';
                }
                if(lIdx !== 1) ctx.strokeStyle = '#1e293b';
                ctx.fill();
                ctx.stroke();
            }
        });
    },

    autoGenerate() {
        this.clearData();
        let tick = 0;
        const btn = document.getElementById('btn-auto-gen');
        btn.disabled = true;

        const loop = setInterval(() => {
            const labels = ['A', 'O', 'I', 'U'];
            const enabledLabels = labels.filter(l => document.getElementById(`chk-${l}`).checked);
            
            if(enabledLabels.length === 0) {
                 clearInterval(loop);
                 btn.disabled = false;
                 return alert("–£–≤—ñ–º–∫–Ω—ñ—Ç—å —Ö–æ—á–∞ –± –æ–¥–Ω—É –±—É–∫–≤—É!");
            }

            const l = enabledLabels[Math.floor((tick / 25) % enabledLabels.length)];
            const pitch = 130 + Math.sin(tick * 0.1) * 10;
            
            AudioSys.playVowelShot(l, 0.3, pitch);
            
            setTimeout(() => {
                const feats = AudioSys.getFeatures();
                let energy = 0;
                if(AudioSys.featureType === 'mel') energy = feats.reduce((a,b)=>a+b,0);
                else energy = feats[1]; 

                if(energy > 0.01) {
                    this.dataset.push({ label: l, data: feats });
                    this.updateCounts();
                    if(this.dataset.length % 10 === 0) this.updateLatentPlot();
                }
            }, 50);
            
            tick++;
            if(tick >= enabledLabels.length * 25) {
                clearInterval(loop);
                btn.disabled = false;
                this.updateLatentPlot();
            }
        }, 150); 
    },

    toggleRec(label) {
        if(document.getElementById(`btn-rec-${label}`).disabled) return;
        if(this.activeRecLabel === label) this.stopMicRec();
        else {
            if(this.activeRecLabel) this.stopMicRec();
            this.startMicRec(label);
        }
    },

    async startMicRec(label) {
        if(!(await AudioSys.initMic())) return;
        this.activeRecLabel = label;
        document.getElementById(`btn-rec-${label}`).classList.add('recording');
        
        this.micInterval = setInterval(() => {
            const feats = AudioSys.getFeatures();
            let energy = 0;
            if(AudioSys.featureType === 'mel') energy = feats.reduce((a,b)=>a+b,0);
            else energy = feats[1]; 

            if(energy > 0.1) { 
                this.dataset.push({ label: label, data: feats });
                this.updateCounts();
                if(this.dataset.length % 5 === 0) this.updateLatentPlot();
            }
        }, 50);
    },

    stopMicRec() {
        if(!this.activeRecLabel) return;
        document.getElementById(`btn-rec-${this.activeRecLabel}`).classList.remove('recording');
        this.activeRecLabel = null;
        clearInterval(this.micInterval);
        this.updateCounts();
        this.updateLatentPlot();
    },

    updateCounts() {
        ['A','O','I','U'].forEach(l => document.getElementById(`cnt-${l}`).innerText = this.dataset.filter(d=>d.label===l).length);
    },
    
    clearData() {
        this.dataset = [];
        this.updateCounts();
        this.resetModel();
    },
    
    resetModel() {
        this.net.reset();
        this.updateCounts();
        this.drawNet();
        Plotly.restyle('plot-latent', {x:[[],[],[],[]], y:[[],[],[],[]], z:[[]]});
        Plotly.restyle('plot-output', {y:[[0,0,0,0]]});
        document.getElementById('val-loss').innerText = "-";
        document.getElementById('train-prog').style.width = "0%";
        document.getElementById('val-epoch').innerText = "0";
    },

    toggleTrain() {
        if(this.isTraining) {
            this.isTraining = false;
            document.getElementById('btn-train').innerText = "üöÄ –°—Ç–∞—Ä—Ç –ù–∞–≤—á–∞–Ω–Ω—è";
            document.getElementById('btn-train').classList.remove('stop');
            return;
        }

        if(this.dataset.length < 5) return alert("–°–ø–æ—á–∞—Ç–∫—É –¥–æ–¥–∞–π—Ç–µ –¥–∞–Ω—ñ!");
        
        this.isTraining = true;
        const btn = document.getElementById('btn-train');
        btn.innerText = "üõë –°—Ç–æ–ø";
        btn.classList.add('stop');
        
        let ep = 0;
        let prevLoss = Infinity;
        let stagnationCounter = 0;

        const loop = () => {
            if(!this.isTraining) return;

            this.dataset.sort(() => Math.random() - 0.5);
            let loss = 0;
            this.dataset.forEach(d => {
                const noisy = d.data.map(v => Math.max(0, v + (Math.random()-0.5)*0.02));
                // TRAIN STEP: Pass Label instead of data
                loss += this.net.train(noisy, d.label, 0.05);
            });
            loss /= this.dataset.length;
            
            document.getElementById('val-loss').innerText = loss.toFixed(4);
            document.getElementById('val-epoch').innerText = ep;
            document.getElementById('train-prog').style.width = ((ep%100)) + '%';
            
            if(ep % 10 === 0) this.updateLatentPlot();
            
            // Stagnation check
            if(Math.abs(prevLoss - loss) < 0.0001) {
                stagnationCounter++;
            } else {
                stagnationCounter = 0;
            }
            prevLoss = loss;

            if(stagnationCounter > 200) {
                this.toggleTrain(); 
                this.net.computeCentroids(this.dataset);
                this.updateLatentPlot(true);
                this.drawNet();
                alert("–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ (–ó–±—ñ–∂–Ω—ñ—Å—Ç—å Loss)");
            } else {
                ep++;
                requestAnimationFrame(loop);
            }
        };
        loop();
    },

    toggleTestRec() {
        if(this.testRecActive) this.stopTestRec();
        else this.startTestRec();
    },

    async startTestRec() {
        if(!(await AudioSys.initMic())) return;
        this.testRecActive = true;
        this.testHistory = []; 
        this.zBuffer = []; 
        document.getElementById('btn-rec-test').classList.add('recording');
        document.getElementById('btn-rec-test').innerHTML = "üõë –°–¢–û–ü";
        
        this.testVizInterval = setInterval(() => {
            const rawFeats = AudioSys.getFeatures();
            const noisyFeats = rawFeats.map(v => Math.min(1, Math.max(0, v + (Math.random()-0.5) * this.testNoiseLevel)));

            const res = this.net.forward(noisyFeats);
            
            this.zBuffer.push(res.z);
            if(this.zBuffer.length > this.smoothingFactor) this.zBuffer.shift();
            
            let avgZ = [0,0];
            this.zBuffer.forEach(p => { avgZ[0]+=p[0]; avgZ[1]+=p[1]; });
            avgZ[0] /= this.zBuffer.length;
            avgZ[1] /= this.zBuffer.length;
            
            // Determine max class
            let maxP = 0, maxIdx = 0;
            res.probs.forEach((p,i) => { if(p>maxP){maxP=p; maxIdx=i} });
            const predLabel = this.net.labels[maxIdx];

            Plotly.restyle('plot-input', {y: [noisyFeats]});
            // Update Probs Plot (Bar chart of 4)
            Plotly.restyle('plot-output', {y: [res.probs]});
            Plotly.restyle('plot-latent', { x: [[avgZ[0]]], y: [[avgZ[1]]] }, [2]);

            if(maxP > 0.4) {
                 this.testHistory.push(predLabel);
            } else {
                 this.testHistory.push('?'); 
            }

            const elRes = document.getElementById('res-char');
            elRes.innerText = predLabel;
            elRes.style.color = this.colors[predLabel] || '#333';
            document.getElementById('res-conf').innerText = `–í–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å: ${(maxP*100).toFixed(0)}%`;

        }, 80);

        this.testRecordingPromise = AudioSys.recordClip(5000); 
    },

    async stopTestRec() {
        if(!this.testRecActive) return;
        this.testRecActive = false;
        clearInterval(this.testVizInterval);
        AudioSys.stopRecorder(); 
        
        document.getElementById('btn-rec-test').classList.remove('recording');
        document.getElementById('btn-rec-test').innerHTML = "üé§ Live –¢–ï–°–¢";

        const buffer = await this.testRecordingPromise;
        this.testSample.audio = buffer;
    },

    setTestNoise(val) {
        this.testNoiseLevel = val / 100;
        document.getElementById('val-noise').innerText = val + "%";
    },

    setSmoothing(val) {
        this.smoothingFactor = parseInt(val);
        document.getElementById('val-smooth').innerText = val;
    },

    playOriginal() { 
        AudioSys.playBuffer(this.testSample.audio, this.testNoiseLevel); 
    },
    
    async playReconstructed() { 
        if(this.testHistory.length === 0) return;
        
        // Use predictions to synthesize sound
        const segments = [];
        let current = this.testHistory[0];
        let count = 1;

        for(let i=1; i<this.testHistory.length; i++) {
            if(this.testHistory[i] === current) {
                count++;
            } else {
                segments.push({ char: current, dur: count * 0.08 });
                current = this.testHistory[i];
                count = 1;
            }
        }
        segments.push({ char: current, dur: count * 0.08 });

        for(let seg of segments) {
            if(seg.char !== '?' && seg.char !== undefined) {
                 AudioSys.playVowelShot(seg.char, seg.dur);
                 await new Promise(r => setTimeout(r, seg.dur * 1000));
            } else {
                 await new Promise(r => setTimeout(r, seg.dur * 1000));
            }
        }
    },

    initPlots() {
        const base = { margin: {t:10,b:20,l:20,r:10}, paper_bgcolor:'transparent', plot_bgcolor:'transparent' };
        
        // Input Plot
        Plotly.newPlot('plot-input', [{y:Array(12).fill(0), type:'bar', marker:{color:'#eab308'}}], 
            { ...base, xaxis:{title:'Features'}, yaxis:{range:[0,1]} }, {staticPlot:true});
            
        // Output Plot (Probabilities)
        Plotly.newPlot('plot-output', [{
            x: ['A', 'O', 'I', 'U'], 
            y: [0,0,0,0], 
            type:'bar', 
            marker:{color:['#dc2626', '#2563eb', '#16a34a', '#9333ea']}
        }], 
        { ...base, yaxis:{range:[0,1], title:'Probability'} }, {staticPlot:true});

        // Latent Space
        const layoutLatent = {
            margin: { t: 20, b: 20, l: 30, r: 10 },
            paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            xaxis: { gridcolor:'#e2e8f0', title:'Hidden Neuron 1' }, 
            yaxis: { gridcolor:'#e2e8f0', title:'Hidden Neuron 2' },
            showlegend: false
        };
        
        Plotly.newPlot('plot-latent', [
            { 
                x: [], y: [], z: [], type: 'contour', 
                colorscale:[
                    [0, 'rgba(220,38,38,0.2)'], [0.25, 'rgba(220,38,38,0.2)'],     
                    [0.25, 'rgba(37,99,235,0.2)'], [0.5, 'rgba(37,99,235,0.2)'],   
                    [0.5, 'rgba(22,163,74,0.2)'], [0.75, 'rgba(22,163,74,0.2)'],   
                    [0.75, 'rgba(147, 51, 234, 0.2)'], [1, 'rgba(147, 51, 234, 0.2)'] 
                ], 
                zmin: 0, zmax: 3,
                showscale:false, autocontour:false, hoverinfo:'none', line:{width:0} 
            },
            { x: [], y: [], mode: 'markers', type: 'scatter', marker: {size: 6}, name:'Data' },
            { x: [], y: [], mode: 'markers', type: 'scatter', marker: {symbol:'cross', color:'#0f172a', size:15, line:{width:2}}, name:'Test' },
            { x: [], y: [], mode: 'markers+text', type: 'scatter', marker: {size: 20, symbol:'diamond', line:{width:2, color:'#fff'}}, textfont:{size:16, color:'#fff', weight:'bold'} }
        ], layoutLatent);
    },

    updateLatentPlot(drawContours = false) {
        if(drawContours) {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        
        setTimeout(() => {
            const x=[], y=[], c=[];
            let minX=-0.5, maxX=0.5, minY=-0.5, maxY=0.5;
            
            this.dataset.forEach(d => {
                const z = this.net.forward(d.data).z;
                x.push(z[0]); y.push(z[1]); c.push(this.colors[d.label]);
                minX = Math.min(minX, z[0]); maxX = Math.max(maxX, z[0]);
                minY = Math.min(minY, z[1]); maxY = Math.max(maxY, z[1]);
            });
            
            Plotly.restyle('plot-latent', {x:[x], y:[y], 'marker.color':[c]}, [1]);

            if(drawContours) {
                const padX = Math.max((maxX-minX)*0.2, 0.5); 
                const padY = Math.max((maxY-minY)*0.2, 0.5);
                minX -= padX; maxX += padX; minY -= padY; maxY += padY;

                const size = 150; 
                const gridX = [], gridY = [], gridZ = [];
                const stepX = (maxX-minX)/size;
                const stepY = (maxY-minY)/size;
                
                for(let i=0; i<=size; i++) gridX.push(minX + i*stepX);
                for(let j=0; j<=size; j++) gridY.push(minY + j*stepY);
                
                const mode = document.getElementById('boundary-select').value; 

                for(let j=0; j<=size; j++) { 
                    let row = [];
                    for(let i=0; i<=size; i++) { 
                        const point = [gridX[i], gridY[j]];
                        let label = '?';
                        
                        if(mode === 'voronoi') {
                            // Old geometric approach
                            label = this.net.predictKNN(point, this.dataset, 1).label; // KNN(1) ~ Voronoi
                        } else {
                            // New Neural approach (Softmax prediction from Latent)
                            label = this.net.predict(point).label;
                        }
                        
                        let val = -1;
                        if(label === 'A') val = 0.125;  
                        if(label === 'O') val = 0.375;  
                        if(label === 'I') val = 0.625;  
                        if(label === 'U') val = 0.875;  
                        row.push(val);
                    }
                    gridZ.push(row);
                }
                Plotly.restyle('plot-latent', { x:[gridX], y:[gridY], z:[gridZ], contours:{start:0, end:1, size:0} }, [0]);
                
                const cx=[], cy=[], ct=[], cc=[];
                if(this.net.centroids) {
                    for(let k in this.net.centroids) {
                        cx.push(this.net.centroids[k].coords[0]); 
                        cy.push(this.net.centroids[k].coords[1]); 
                        ct.push(k); cc.push(this.colors[k]);
                    }
                }
                Plotly.restyle('plot-latent', { x:[cx], y:[cy], text:[ct], 'marker.color':[cc] }, [3]);
                
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }, 50); 
    },

    showWeightsModal() {
        const modal = document.getElementById('weights-modal');
        modal.style.display = 'flex';
        
        const formatTable = (data, rows, cols) => {
            let html = '<table class="matrix-table"><thead><tr><th></th>';
            for(let c=0; c<cols; c++) html += `<th>${c}</th>`;
            html += '</tr></thead><tbody>';
            for(let r=0; r<rows; r++) {
                html += `<tr><th>${r}</th>`;
                for(let c=0; c<cols; c++) {
                    const val = data[r] && data[r][c] !== undefined ? data[r][c] : data[r];
                    const num = typeof val === 'number' ? val.toFixed(2) : val;
                    const bg = num > 0 ? `rgba(0,0,255,${Math.min(0.5, num)})` : `rgba(255,0,0,${Math.min(0.5, Math.abs(num))})`;
                    html += `<td style="background:${bg}">${num}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody></table>';
            return html;
        };
        
        // Encoder
        let htmlEnc = formatTable(this.net.W1, 2, 12);
        htmlEnc += '<h4>Bias B1</h4>' + formatTable(this.net.b1, 1, 2);
        document.getElementById('table-enc').innerHTML = htmlEnc;

        // Decoder (Classifier)
        let htmlDec = formatTable(this.net.W2, 4, 2);
        htmlDec += '<h4>Bias B2</h4>' + formatTable(this.net.b2, 1, 4);
        document.getElementById('table-dec').innerHTML = htmlDec;
    },
    
    closeModal() {
        document.getElementById('weights-modal').style.display = 'none';
    }
};

window.onload = () => App.init();
</script>
</body>
</html>
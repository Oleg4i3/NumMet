<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Battle: Pro Edition + SGS</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
        }
      }
    </script>
	<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']] 
    }
  };
</script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #2196f3; --text: #e0e0e0; }
        body { 
            font-family: 'Segoe UI', Roboto, sans-serif; margin: 0; 
            background-color: var(--bg); color: var(--text); 
            overflow: hidden; display: flex; height: 100vh;
        }

        /* SIDEBAR STYLES */
        #sidebar {
            width: 360px; background: var(--panel); padding: 0;
            display: flex; flex-direction: column;
            box-shadow: 4px 0 15px rgba(0,0,0,0.6); z-index: 10;
            border-right: 1px solid #333;
        }
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .fixed-bottom { padding: 15px; background: #181818; border-top: 1px solid #333; }

        h2 { margin: 15px 0 8px 0; font-size: 0.95rem; color: var(--accent); text-transform: uppercase; border-bottom: 2px solid #333; padding-bottom: 4px; letter-spacing: 1px; }
        .control-group { margin-bottom: 15px; }
        label { font-size: 0.85rem; display: block; margin-bottom: 5px; color: #bbb; }

        /* Method Item Styles */
        .method-item {
            background: rgba(255,255,255,0.03);
            border-radius: 4px; margin-bottom: 4px;
            border-left: 3px solid transparent;
        }
        .method-header {
            display: flex; align-items: center; padding: 8px;
            cursor: pointer; user-select: none;
        }
        .method-header:hover { background: rgba(255,255,255,0.05); }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        .method-name { flex: 1; font-size: 0.9rem; font-weight: 500; }
        .settings-btn { 
            background: none; border: none; color: #666; cursor: pointer; font-size: 1.1rem; padding: 0 5px; transition: 0.2s;
        }
        .settings-btn:hover { color: var(--text); transform: rotate(45deg); }
        .settings-btn.active { color: var(--accent); transform: rotate(90deg); }

        .method-settings {
            display: none; padding: 10px; background: rgba(0,0,0,0.2);
            border-top: 1px solid #333; font-size: 0.8rem;
        }
        .method-settings.show { display: block; }
        
        .param-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; }
        .param-row input { width: 60px; background: #333; border: none; color: white; padding: 2px 5px; border-radius: 3px; text-align: right; }

        /* General Inputs */
        select, input[type="range"] { width: 100%; background: #2c2c2c; color: white; border: 1px solid #444; padding: 6px; border-radius: 4px; margin-bottom: 5px; }
        input[type="range"] { padding: 0; cursor: pointer; accent-color: var(--accent); }
        

/* –°—Ç–∏–ª—ñ –¥–ª—è –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ —Ä—è–¥–∫–∞ –∫–Ω–æ–ø–æ–∫ */
.btn-row { 
    display: flex; 
    gap: 4px; /* –î—É–∂–µ –º–∞–ª–µ–Ω—å–∫–∏–π –≤—ñ–¥—Å—Ç—É–ø –º—ñ–∂ –∫–Ω–æ–ø–∫–∞–º–∏ */
    margin-bottom: 10px; 
    width: 100%;
}

.btn {
    flex: 1; /* –ö–æ–∂–Ω–∞ –∫–Ω–æ–ø–∫–∞ –∑–∞–π–º–∞—î —Ä—ñ–≤–Ω—É —á–∞—Å—Ç–∏–Ω—É */
    border: none; 
    border-radius: 4px; 
    cursor: pointer; 
    font-weight: bold; 
    text-transform: uppercase;
    transition: filter 0.2s;
    
    /* –ö–æ–º–ø–∞–∫—Ç–Ω—ñ—Å—Ç—å */
    padding: 0; /* –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤—ñ–¥—Å—Ç—É–ø–∏ */
    height: 40px; /* –§—ñ–∫—Å–æ–≤–∞–Ω–∞ –≤–∏—Å–æ—Ç–∞ */
    font-size: 0.7rem; /* –ó–º–µ–Ω—à–µ–Ω–∏–π —à—Ä–∏—Ñ—Ç */
    display: flex; 
    align-items: center; 
    justify-content: center;
    white-space: nowrap; /* –¢–µ–∫—Å—Ç –≤ –æ–¥–∏–Ω —Ä—è–¥–æ–∫ */
}

.btn:hover { filter: brightness(1.1); }
.btn-reset { background: #d32f2f; }


        .btn {
            flex: 1; background: var(--accent); color: white; border: none; padding: 12px;
            border-radius: 4px; cursor: pointer; font-weight: bold; text-transform: uppercase;
            transition: background 0.2s;
        }
        .btn:hover { filter: brightness(1.1); }
        .btn-reset { background: #d32f2f; }

        /* Stats Table */
        #stats-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; margin-top: 10px; }
        #stats-table td { padding: 4px; border-bottom: 1px solid #333; }
        #stats-table td:first-child { font-weight: bold; }
        #stats-table td:last-child { text-align: right; font-family: monospace; color: #aaa; }

        /* Canvas & Overlay */
        #scene-container { flex: 1; position: relative; background: #000; }
        #info-overlay {
            position: absolute; top: 15px; left: 15px; pointer-events: none;
            color: rgba(255,255,255,0.4); font-family: monospace; font-size: 0.8rem;
        }
		
		
		/* --- Modal Styles --- */
.modal-overlay {
    display: none; /* –ü—Ä–∏—Ö–æ–≤–∞–Ω–æ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º */
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 2000; /* –ü–æ–≤–µ—Ä—Ö –≤—Å—å–æ–≥–æ */
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(5px);
}

.modal-content {
    background: #1e1e1e;
    width: 80%;
    max-width: 900px;
    max-height: 90vh;
    border-radius: 8px;
    border: 1px solid #444;
    box-shadow: 0 0 20px rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    position: relative;
}

.modal-header {
    padding: 15px 20px;
    border-bottom: 1px solid #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #252525;
    border-radius: 8px 8px 0 0;
}

.modal-header h2 {
    margin: 0; border: none; padding: 0;
    color: #f1c40f; font-size: 1.2rem;
}

.close-btn {
    background: none; border: none;
    color: #aaa; font-size: 1.5rem; cursor: pointer;
    transition: 0.2s;
}
.close-btn:hover { color: white; transform: scale(1.1); }

.modal-body {
    padding: 25px;
    overflow-y: auto; /* –í–ª–∞—Å–Ω–∏–π —Å–∫—Ä–æ–ª */
    color: #ddd;
    font-size: 0.95rem;
    line-height: 1.7;
}

/* Fix for MathJax in dark mode */
mjx-container { color: #e0e0e0 !important; }

/* Table styling in modal */
.theory-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
.theory-table th, .theory-table td { 
    border: 1px solid #444; padding: 8px; text-align: left; 
}
.theory-table th { background: #333; color: #4fc3f7; }
    </style>
</head>
<body>

    <div id="sidebar">

        <div class="scroll-area">
            <div class="control-group" style="border-left: 3px solid #f1c40f; padding-left: 10px;">
                <label>‚ö° –®–≤–∏–¥–∫—ñ –ü—Ä–µ—Å–µ—Ç–∏</label>
                <select id="presetSelect">
                  
                    <option value="valley_cg">–í—É–∑—å–∫–∏–π –ö–∞–Ω—å–π–æ–Ω</option>
                    <option value="rosenbrock">–†–æ–∑–µ–Ω–±—Ä–æ–∫ </option>
                    <option value="beale">–ü–ª–∞—Ç–æ –ë—ñ–ª–∞</option>
                    <option value="himmelblau">–•—ñ–º–º–µ–ª—å–±–ª–∞—É (4 –º—ñ–Ω—ñ–º—É–º–∏)</option>
                    
                </select>
            </div>

            <h2>–ú–µ—Ç–æ–¥–∏ –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó</h2>
            <div id="methods-list">
                </div>

            <label>–õ–∞–Ω–¥—à–∞—Ñ—Ç</label>
            <select id="funcSelect">
                <option value="valley">–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞ –¥–æ–ª–∏–Ω–∞</option>
                <option value="rosenbrock">–†–æ–∑–µ–Ω–±—Ä–æ–∫ (Banana)</option>
                <option value="beale">–ë—ñ–ª–∞ (Beale)</option>
                <option value="himmelblau">–•—ñ–º–º–µ–ª—å–±–ª–∞—É</option>
                
            </select>

            <label>–®–≤–∏–¥–∫—ñ—Å—Ç—å (–∫—Ä–æ–∫—ñ–≤/–∫–∞–¥—Ä): <span id="speedVal">1</span></label>
            <input type="range" id="speedSlider" min="0.1" max="20" step="0.1" value="1">

            <label>–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π –º–∞—Å—à—Ç–∞–± (Visual): <span id="vScaleVal">1.0</span></label>
            <input type="range" id="vScaleSlider" min="0.01" max="3.0" step="0.1" value="0.2">
        </div>

        <div class="fixed-bottom">
           
            
            <div class="btn-row">
			<button id="btn-theory" class="btn" style="background: #f1c40f; color: #000; ">–¢–ï–û–†–Ü–Ø</button>
                <button id="btn-start" class="btn">‚ñ∂ Go!</button>
                <button id="btn-reset" class="btn btn-reset">‚Ü∫ Reset</button>
				
				<button id="btn-random-pos" class="btn" style="background: #9c27b0;">üé≤ rand.start</button>
            </div>
			 <div style="font-size: 0.8rem; font-weight: bold; margin-bottom: 5px;">–°—Ç–∞—Ç—É—Å</div>
            <table id="stats-table"></table>
        </div>
		
    </div>
	
	

    <div id="scene-container">
        <div id="info-overlay">
            –õ–ö–ú: –û–±–µ—Ä—Ç–∞–Ω–Ω—è | –ü–ö–ú: –ó–º—ñ—â–µ–Ω–Ω—è | –ö–æ–ª–µ—Å–æ: –ó—É–º<br>
            –ü—Ä–∞–ø–æ—Ä–µ—Ü—å = –ì–ª–æ–±–∞–ª—å–Ω–∏–π –ú—ñ–Ω—ñ–º—É–º
        </div>
    </div>

<div id="theoryModal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h2>–ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è</h2>
            <button class="close-btn" onclick="closeModal()">√ó</button>
        </div>
        <div class="modal-body">
            
            <h3 style="color: #4fc3f7;">1. –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫</h3>
            <p>
                –ù–∞—à–∞ –º–µ—Ç–∞ ‚Äî –∑–Ω–∞–π—Ç–∏ –º—ñ–Ω—ñ–º—É–º $f(x)$. –ì—Ä–∞–¥—ñ—î–Ω—Ç $\nabla f$ –ø–æ–∫–∞–∑—É—î –Ω–∞–ø—Ä—è–º–æ–∫ <b>–Ω–∞–π—à–≤–∏–¥—à–æ–≥–æ –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è</b>.
                –ö–ª–∞—Å–∏—á–Ω–∏–π —Å–ø—É—Å–∫ (SGD) –ø—Ä–æ—Å—Ç–æ –π–¥–µ –ø—Ä–æ—Ç–∏ –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞: $x_{new} = x - \eta \nabla f$.
            </p>
			<p style="background: rgba(33, 150, 243, 0.1); padding: 10px; border-left: 3px solid #2196f3; font-size: 0.9em; margin: 10px 0;">
                –õ—ñ—Ç–µ—Ä–∞ $\eta$ ("–µ—Ç–∞") —É —Ñ–æ—Ä–º—É–ª–∞—Ö ‚Äî —Ü–µ —ñ —î –ø–∞—Ä–∞–º–µ—Ç—Ä <b>Learning Rate</b> —É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ. –í–æ–Ω–∞ –≤–∏–∑–Ω–∞—á–∞—î –¥–æ–≤–∂–∏–Ω—É –≤–∞—à–æ–≥–æ –∫—Ä–æ–∫—É.
            </p>

            <h3 style="color: #3388ff;">–©–æ —Ç–∞–∫–µ Momentum (–Ü–Ω–µ—Ä—Ü—ñ—è)?</h3>
            <p>
                –ó–≤–∏—á–∞–π–Ω–∏–π —Å–ø—É—Å–∫ (SGD) –º–∏—Ç—Ç—î–≤–æ –∑—É–ø–∏–Ω—è—î—Ç—å—Å—è, —è–∫—â–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç —Å—Ç–∞—î –Ω—É–ª–µ–º. <b>Momentum</b> –¥–æ–¥–∞—î —Ñ—ñ–∑–∏–∫—É "–≤–∞–∂–∫–æ—ó –∫—É–ª—å–∫–∏".
                –ú–∏ –Ω–∞–∫–æ–ø–∏—á—É—î–º–æ —à–≤–∏–¥–∫—ñ—Å—Ç—å: —è–∫—â–æ –∫—É–ª—å–∫–∞ –¥–æ–≤–≥–æ –∫–æ—Ç–∏—Ç—å—Å—è –≤–Ω–∏–∑, –≤–æ–Ω–∞ —Ä–æ–∑–≥–∞–Ω—è—î—Ç—å—Å—è.
            </p>
            <ul style="margin-bottom: 15px;">
                <li>–¶–µ –¥–æ–∑–≤–æ–ª—è—î <b>–ø—Ä–æ–ª—ñ—Ç–∞—Ç–∏</b> –¥—Ä—ñ–±–Ω—ñ —è–º–∫–∏ (–ª–æ–∫–∞–ª—å–Ω—ñ –º—ñ–Ω—ñ–º—É–º–∏) –∑–∞ —ñ–Ω–µ—Ä—Ü—ñ—î—é.</li>
                <li>–¶–µ –¥–æ–ø–æ–º–∞–≥–∞—î –Ω–µ –∑–∞—Å—Ç—Ä—è–≥–∞—Ç–∏ –Ω–∞ –ø–ª–∞—Å–∫–∏—Ö –¥—ñ–ª—è–Ω–∫–∞—Ö (–ø–ª–∞—Ç–æ), –¥–µ –≥—Ä–∞–¥—ñ—î–Ω—Ç –º–∞–ª–∏–π.</li>
            </ul>
            <p>–°–∞–º–µ —Ç–æ–º—É —Ü–µ–π –ø–∞—Ä–∞–º–µ—Ç—Ä —î –≤ –º–µ—Ç–æ–¥—ñ <i>Momentum</i> —Ç–∞ –≤ <i>Adam</i>.</p>
			
			
            <div style="background: rgba(51, 136, 255, 0.15); border-left: 4px solid #3388ff; padding: 10px; margin: 10px 0; border-radius: 4px;">
                $$ v_{new} = \gamma \cdot v_{old} + \eta \cdot \nabla f(x) $$
                $$ x_{new} = x_{old} - v_{new} $$
            </div>

            <p><b>–Ø–∫ —Ü–µ –ø—Ä–∞—Ü—é—î:</b></p>
            <ul style="margin-bottom: 15px;">
                <li>$\gamma$ (–≥–∞–º–º–∞) ‚Äî —Ü–µ <b>–ø–∞—Ä–∞–º–µ—Ç—Ä Momentum</b> (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ 0.9). –¶–µ "–∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è": –º–∏ –±–µ—Ä–µ–º–æ 90% —Å—Ç–∞—Ä–æ—ó —à–≤–∏–¥–∫–æ—Å—Ç—ñ —ñ –¥–æ–¥–∞—î–º–æ —Ç—Ä–æ—Ö–∏ –Ω–æ–≤–æ–≥–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞.</li>
                <li>–Ø–∫—â–æ $\gamma = 0$, –º–µ—Ç–æ–¥ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–∞ –∑–≤–∏—á–∞–π–Ω–∏–π SGD.</li>
                <li>–¶–µ –¥–æ–∑–≤–æ–ª—è—î <b>–ø—Ä–æ–ª—ñ—Ç–∞—Ç–∏</b> –¥—Ä—ñ–±–Ω—ñ —è–º–∫–∏ —Ç–∞ –ø–ª–∞—Ç–æ –∑–∞ —ñ–Ω–µ—Ä—Ü—ñ—î—é.</li>
            </ul>
			
            <h3 style="color: #ffaa00;">2. –ú–µ—Ç–æ–¥–∏ —Å–ø—Ä—è–∂–µ–Ω–∏—Ö –≥—Ä–∞–¥—ñ—î–Ω—Ç—ñ–≤ (CG)</h3>
            <p>
                –ì–æ–ª–æ–≤–Ω–∞ —ñ–¥–µ—è CG: <i>"–ù–µ –ø—Å—É–π –ø–æ–ø–µ—Ä–µ–¥–Ω—é —Ä–æ–±–æ—Ç—É"</i>. –ó–∞–º—ñ—Å—Ç—å —Ç–æ–≥–æ, —â–æ–± –π—Ç–∏ –ø—Ä–æ—Å—Ç–æ –≤–Ω–∏–∑, –º–∏ —à—É–∫–∞—î–º–æ –Ω–∞–ø—Ä—è–º–æ–∫ $d_{k}$, —è–∫–∏–π —î –∫–æ–º–ø—Ä–æ–º—ñ—Å–æ–º –º—ñ–∂ "–≤–Ω–∏–∑" (–Ω–æ–≤–∏–π –≥—Ä–∞–¥—ñ—î–Ω—Ç) —ñ "–≤–ø–µ—Ä–µ–¥ –∑–∞ —ñ–Ω–µ—Ä—Ü—ñ—î—é" (—Å—Ç–∞—Ä–∏–π –Ω–∞–ø—Ä—è–º–æ–∫).
            </p>
            <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px; text-align:center;">
                $$d_{k+1} = -\nabla f_{k+1} + \beta_k \cdot d_k$$
            </div>
            <p>–í—Å—è –º–∞–≥—ñ—è –≤ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ $\beta_k$ (–±–µ—Ç–∞). –í—ñ–Ω –≤–∏—Ä—ñ—à—É—î, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ —Å–∏–ª—å–Ω–æ –º–∏ "—Å–ª—É—Ö–∞—î–º–æ" —Å—Ç–∞—Ä–∏–π –Ω–∞–ø—Ä—è–º–æ–∫. –†—ñ–∑–Ω—ñ –º–µ—Ç–æ–¥–∏ —Ä–∞—Ö—É—é—Ç—å –π–æ–≥–æ –ø–æ-—Ä—ñ–∑–Ω–æ–º—É:</p>

            <table class="theory-table">
                <tr>
                    <th width="20%">–ú–µ—Ç–æ–¥</th>
                    <th width="40%">–ì–µ–æ–º–µ—Ç—Ä–∏—á–Ω–∞ –Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è</th>
                    <th>–î–ª—è —á–æ–≥–æ –∫—Ä–∞—â–µ?</th>
                </tr>
                <tr>
                    <td>
                        <strong style="color:#ffaa00">FR</strong><br>
                        (Fletcher-Reeves)
                    </td>
                    <td>
                        $$ \beta = \frac{\|\nabla f_{new}\|^2}{\|\nabla f_{old}\|^2} $$
                        <b>"–ú–∞—Å—à—Ç–∞–± –ø–æ –ì—Ä–∞–¥—ñ—î–Ω—Ç—É"</b><br>
                        –ú–∏ –¥–∏–≤–∏–º–æ—Å—å –ª–∏—à–µ –Ω–∞ <i>–¥–æ–≤–∂–∏–Ω—É</i> –≤–µ–∫—Ç–æ—Ä—ñ–≤. –Ø–∫—â–æ —Å—Ö–∏–ª —Å—Ç–∞–≤ –∫—Ä—É—Ç—ñ—à–∏–º ($\|\nabla f\| \uparrow$), –º–∏ –±—ñ–ª—å—à–µ –¥–æ–≤—ñ—Ä—è—î–º–æ —ñ–Ω–µ—Ä—Ü—ñ—ó (—Å—Ç–∞—Ä–æ–º—É $d_k$). –Ø–∫—â–æ –≤–∏–ø–æ–ª–æ–∂—É—î—Ç—å—Å—è ‚Äî –≥–∞–ª—å–º—É—î–º–æ.
                    </td>
                    <td>–Ü–¥–µ–∞–ª—å–Ω—ñ –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω—ñ —á–∞—à—ñ. –í —Å–∫–ª–∞–¥–Ω–∏—Ö —è—Ä–∞—Ö –º–æ–∂–µ "–∑–∞—Ü–∏–∫–ª–∏—Ç–∏—Å—å".</td>
                </tr>
                <tr>
                    <td>
                        <strong style="color:#ffff00">PR</strong><br>
                        (Polak-Ribiere)
                    </td>
                    <td>
                        $$ \beta = \frac{\nabla f_{new}^T (\nabla f_{new} - \nabla f_{old})}{\|\nabla f_{old}\|^2} $$
                        <b>"–†–µ–∞–∫—Ü—ñ—è –Ω–∞ –ø–æ–≤–æ—Ä–æ—Ç"</b><br>
                        –í—Ä–∞—Ö–æ–≤—É—î —Å–∫–∞–ª—è—Ä–Ω–∏–π –¥–æ–±—É—Ç–æ–∫. –Ø–∫—â–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç —Ä—ñ–∑–∫–æ –∑–º—ñ–Ω–∏–≤ –Ω–∞–ø—Ä—è–º–æ–∫ (–æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∏–π —Å—Ç–∞—Ä–æ–º—É), $\beta$ —Å—Ç–∞—î $\approx 0$. –¶–µ –ø—Ä–∞—Ü—é—î —è–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π "—Ä–µ—Å—Ç–∞—Ä—Ç" (–ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤ SGD), —â–æ —Ä—è—Ç—É—î –≤ –∫—Ä–∏–≤–∏—Ö —è—Ä–∞—Ö.
                    </td>
                    <td>–ë—ñ–ª—å—à—ñ—Å—Ç—å –Ω–µ–ª—ñ–Ω—ñ–π–Ω–∏—Ö –∑–∞–¥–∞—á. –ó–æ–ª–æ—Ç–∏–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç CG.</td>
                </tr>
                <tr>
                    <td>
                        <strong style="color:#ff00ff">HS</strong><br>
                        (Hestenes-Stiefel)
                    </td>
                    <td>
                        $$ \beta = \frac{\nabla f_{new}^T (\Delta g)}{d_{old}^T (\Delta g)} $$
                        <b>"–ü—Ä–æ–µ–∫—Ü—ñ—è –Ω–∞ —à–ª—è—Ö"</b><br>
                        –°—Ö–æ–∂–∏–π –Ω–∞ PR, –∞–ª–µ –∑–Ω–∞–º–µ–Ω–Ω–∏–∫ –≤—Ä–∞—Ö–æ–≤—É—î, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ –∑–º—ñ–Ω–∏–≤—Å—è –≥—Ä–∞–¥—ñ—î–Ω—Ç <i>–≤–∑–¥–æ–≤–∂ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ –∫—Ä–æ–∫—É</i>. –¶–µ –¥–∞—î "—á–∏—Å—Ç—ñ—à—É" —Å–ø—Ä—è–∂–µ–Ω—ñ—Å—Ç—å (conjugacy), –∫–æ–ª–∏ —Ñ—É–Ω–∫—Ü—ñ—è –Ω–µ —ñ–¥–µ–∞–ª—å–Ω–æ –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞.
                    </td>
                    <td>–î—É–∂–µ —Å—Ö–æ–∂–∏–π –Ω–∞ PR, –∫—Ä–∞—â–µ —Ç—Ä–∏–º–∞—î "–≥–µ–æ–º–µ—Ç—Ä—ñ—é" —Å–ø—Ä—è–∂–µ–Ω–æ—Å—Ç—ñ.</td>
                </tr>
                <tr>
                    <td>
                        <strong style="color:#00ffff">DY</strong><br>
                        (Dai-Yuan)
                    </td>
                    <td>
                        $$ \beta = \frac{\|\nabla f_{new}\|^2}{d_{old}^T (\Delta g)} $$
                        <b>"–ñ–æ—Ä—Å—Ç–∫–∏–π —Å–ø—É—Å–∫"</b><br>
                        –ì—ñ–±—Ä–∏–¥. –ß–∏—Å–µ–ª—å–Ω–∏–∫ —è–∫ —É FR (–¥–æ–≤–∂–∏–Ω–∞), –∑–Ω–∞–º–µ–Ω–Ω–∏–∫ —è–∫ —É HS (–ø—Ä–æ–µ–∫—Ü—ñ—è).
                        –ì–∞—Ä–∞–Ω—Ç—É—î, —â–æ –º–∏ –∑–∞–≤–∂–¥–∏ —Ä—É—Ö–∞—î–º–æ—Å—å –≤–Ω–∏–∑, –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ —Ñ—É–Ω–∫—Ü—ñ—è –¥—É–∂–µ –≤–∏–ø—É–∫–ª–∞. –ú–µ–Ω—à–µ —Ä–∏–∑–∏–∫—É –ø—ñ—Ç–∏ –≤–≥–æ—Ä—É.
                    </td>
                    <td>–°–∫–ª–∞–¥–Ω—ñ, —Å–∏–ª—å–Ω–æ –≤–∏–ø—É–∫–ª—ñ –∑–∞–¥–∞—á—ñ, –¥–µ FR –ª–∞–º–∞—î—Ç—å—Å—è.</td>
                </tr>
            </table>

            <h3 style="color: #33ff33;">3. –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏</h3>
            <p>
                <strong style="color:#33ff33">Adam</strong> –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î "–±–µ—Ç–∞" –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç—É. –í—ñ–Ω –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É. –í—ñ–Ω –∑–∞–ø–∞–º'—è—Ç–æ–≤—É—î —Å–µ—Ä–µ–¥–Ω—é –∫—Ä—É—Ç–∏–∑–Ω—É —Å—Ö–∏–ª—É (V) —ñ —Å–µ—Ä–µ–¥–Ω—é —à–≤–∏–¥–∫—ñ—Å—Ç—å (m).
                –Ø–∫—â–æ —Å—Ö–∏–ª –∫—Ä—É—Ç–∏–π, –∞–ª–µ –º–∏ —Ç–∞–º —Ä—ñ–¥–∫–æ –±—É–≤–∞—î–º–æ ‚Äî –≤—ñ–Ω —Ä–æ–±–∏—Ç—å –≤–µ–ª–∏–∫–∏–π –∫—Ä–æ–∫. –Ø–∫—â–æ —Å—Ö–∏–ª –ø–æ—Å—Ç—ñ–π–Ω–æ –∫—Ä—É—Ç–∏–π ‚Äî –≤—ñ–Ω –∑–º–µ–Ω—à—É—î –∫—Ä–æ–∫, —â–æ–± –Ω–µ –ø—Ä–æ–ª–µ—Ç—ñ—Ç–∏.
            </p>
			
			<h3 style="color: #aaaabb;">4. –°—Ç–æ—Ö–∞—Å—Ç–∏—á–Ω–∏–π –≥—Ä–∞–¥—ñ—î–Ω—Ç (SGS)</h3>
<p>
    –ö–ª–∞—Å–∏—á–Ω–∏–π —Å–ø—É—Å–∫ –≤–∏—Ä–∞—Ö–æ–≤—É—î —ñ–¥–µ–∞–ª—å–Ω–∏–π –Ω–∞–ø—Ä—è–º–æ–∫ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤—Å—ñ—Ö –¥–∞–Ω–∏—Ö. <b>–°—Ç–æ—Ö–∞—Å—Ç–∏—á–Ω–∏–π —Å–ø—É—Å–∫</b> —ñ–º—ñ—Ç—É—î —Å–∏—Ç—É–∞—Ü—ñ—é, –∫–æ–ª–∏ –º–∏ –±–∞—á–∏–º–æ –ª–∏—à–µ —á–∞—Å—Ç–∏–Ω—É –¥–∞–Ω–∏—Ö (–º—ñ–Ω—ñ-–±–∞—Ç—á), —Ç–æ–º—É –≤–µ–∫—Ç–æ—Ä —Ä—É—Ö—É –º—ñ—Å—Ç–∏—Ç—å <b>–≤–∏–ø–∞–¥–∫–æ–≤–∏–π —à—É–º</b>.
</p>
<p>
    –£ —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ —Ü–µ –≤–∏–≥–ª—è–¥–∞—î —è–∫ "—Ç—Ä–µ–º—Ç—ñ–Ω–Ω—è" –∫—É–ª—å–∫–∏. –•–æ—á–∞ —à–ª—è—Ö –∑–¥–∞—î—Ç—å—Å—è –Ω–µ–∞–∫—É—Ä–∞—Ç–Ω–∏–º, —Ü–µ–π —à—É–º —î –∫–æ—Ä–∏—Å–Ω–æ—é —Ñ—ñ—á–µ—é:
</p>
<ul style="margin-bottom: 15px;">
    <li>–í–∏–ø–∞–¥–∫–æ–≤—ñ –ø–æ—à—Ç–æ–≤—Ö–∏ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –º–µ—Ç–æ–¥—É <b>–≤–∏—Å—Ç—Ä–∏–±—É–≤–∞—Ç–∏</b> –∑ –Ω–µ–≥–ª–∏–±–æ–∫–∏—Ö –ª–æ–∫–∞–ª—å–Ω–∏—Ö –º—ñ–Ω—ñ–º—É–º—ñ–≤ (–ø–∞—Å—Ç–æ–∫).</li>
    <li>–í—ñ–Ω –∫—Ä–∞—â–µ –¥–æ—Å–ª—ñ–¥–∂—É—î –ª–∞–Ω–¥—à–∞—Ñ—Ç, –Ω–µ –∑–∞—Å—Ç—Ä—è–≥–∞—é—á–∏ –≤ –ø–µ—Ä—à—ñ–π –∂–µ —è–º—Ü—ñ.</li>
</ul>
<div style="background: rgba(156, 39, 176, 0.15); border-left: 4px solid #9c27b0; padding: 10px; margin: 10px 0; border-radius: 4px;">
    $$ x_{new} = x - \eta \cdot (\nabla f + \text{Noise}) $$
</div>

        </div>
    </div>
</div>

    <script type="module">
	
	
	// --- Modal Logic ---
const modal = document.getElementById('theoryModal');
const btnTheory = document.getElementById('btn-theory');

// –§—É–Ω–∫—Ü—ñ—è –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è
btnTheory.addEventListener('click', () => {
    modal.style.display = 'flex';
    
    // MAGIC FIX: –ü—Ä–∏–º—É—Å–æ–≤–∏–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Ñ–æ—Ä–º—É–ª
    if (window.MathJax) {
        window.MathJax.typesetPromise([modal]).then(() => {
            console.log('MathJax rendered in modal');
        }).catch((err) => console.log('MathJax error:', err));
    }
});

// –§—É–Ω–∫—Ü—ñ—è –∑–∞–∫—Ä–∏—Ç—Ç—è (–≥–ª–æ–±–∞–ª—å–Ω–∞, —â–æ–± –ø—Ä–∞—Ü—é–≤–∞–ª–∞ –∑ onclick –≤ HTML)
window.closeModal = function() {
    modal.style.display = 'none';
};

// –ó–∞–∫—Ä–∏—Ç—Ç—è –ø–æ –∫–ª—ñ–∫—É –∑–∞ –º–µ–∂–∞–º–∏ –≤—ñ–∫–Ω–∞
window.onclick = function(event) {
    if (event.target == modal) {
        closeModal();
    }
}


        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const METHODS_CONFIG = {
            SGD:      { name: "SGD", color: 0xff3333, defaultLR: 0.2, defaultMom: 0 },
            SGS:      { name: "SGS (–°—Ç–æ—Ö–∞—Å—Ç–∏—á–Ω–∏–π)", color: 0xaaaaaa, defaultLR: 0.15, defaultMom: 2.3 }, // ADDED SGS
            Momentum: { name: "Momentum", color: 0x3388ff, defaultLR: 0.1, defaultMom: 0.9 },
            Adam:     { name: "Adam", color: 0x33ff33, defaultLR: 0.1, defaultMom: 0.9 },
            CG_FR:    { name: "CG (Fletcher-Reeves)", color: 0xffaa00, defaultLR: 0.2, defaultMom: 0 },
            CG_PR:    { name: "CG (Polak-Ribiere)", color: 0xffff00, defaultLR: 0.2, defaultMom: 0 },
            CG_HS:    { name: "CG (Hestenes-Stiefel)", color: 0xff00ff, defaultLR: 0.2, defaultMom: 0 },
            CG_DY:    { name: "CG (Dai-Yuan)", color: 0x444455, defaultLR: 0.15, defaultMom: 0 },
        };

        const GLOBAL_STATE = {
            func: 'valley',
            startPos: { x: -6, y: -2 },
            speed: 1,
            visualScale: 0.05
        };

        let scene, camera, renderer, controls;
        let surfaceMesh, wireframeMesh, targetMarkers = [];
        let optimizers = [];
        let isRunning = false;

        // --- MATH FUNCTIONS ---
        const Functions = {
            valley: (x, y) => {
                // f(x,y) = x^2 + 10y^2. Anisotropic.
                const z = (x*x + 10*y*y) / 20;
                return { z, dx: x/10, dy: y };
            },
            rosenbrock: (x, y) => {
                // f(x,y) = (1-x)^2 + 10(y-x^2)^2. Scaled.
                const a = 1, b = 10;
                const z = (Math.pow(a - y, 2) + b * Math.pow(x - y*y, 2)) / 20;
                const dx = (-2*(a-x) - 4*b*x*(y - x*x)) / 20;
                const dy = (2*b*(y - x*x)) / 20;
                return { z, dx, dy };
            },
            beale: (x, y) => {
                // Beale function mapped. Usually defined on [-4.5, 4.5]
                // f(x,y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2
                const t1 = 1.5 - x + x*y;
                const t2 = 2.25 - x + x*y*y;
                const t3 = 2.625 - x + x*y*y*y;
                const z = (t1**2 + t2**2 + t3**2) / 150; 
                // Analytical gradients are long, doing numerical approx for simplicity & safety here
                // or specific derivation:
                const dx = (2*t1*(y-1) + 2*t2*(y*y-1) + 2*t3*(y*y*y-1)) / 150;
                const dy = (2*t1*(x) + 2*t2*(2*x*y) + 2*t3*(3*x*y*y)) / 150;
                return { z, dx, dy };
            },
            himmelblau: (x, y) => {
                const t1 = x*x + y - 11;
                const t2 = x + y*y - 7;
                const z = (t1*t1 + t2*t2) / 100;
                const dx = (2*t1*2*x + 2*t2) / 100;
                const dy = (2*t1 + 2*t2*2*y) / 100;
                return { z, dx, dy };
            },
            saddle: (x, y) => {
                // x^2 - y^2
                const z = (x*x - y*y) / 10;
                return { z, dx: x/5, dy: -y/5 };
            }
        };

        const GlobalMinima = {
            valley: [{x:0, y:0}],
            rosenbrock: [{x:1, y:1}],
            beale: [{x:3, y:0.5}],
            himmelblau: [{x:3, y:2}, {x:-2.805, y:3.131}, {x:-3.779, y:-3.283}, {x:3.584, y:-1.848}],
            saddle: [{x:0, y:0}] // Actually saddle point, but used as target ref
        };



        // --- OPTIMIZER LOGIC (UPDATED v3.1) ---
        class Optimizer {
            constructor(id, config, startPos) {
                this.id = id;
                this.config = config; 
                this.meta = METHODS_CONFIG[id];
                this.pos = { ...startPos };
                
                this.finished = false;
                this.steps = 0;
                
                this.velocity = {x:0, y:0};
                this.m = {x:0, y:0}; this.v = {x:0, y:0}; this.t = 0;
                this.prevGrad = null; this.prevDir = null;

                this.path = [];
                
                // Visual Setup
                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: this.meta.color, 
                        emissive: this.meta.color, 
                        emissiveIntensity: 0.6 
                    })
                );
                scene.add(this.mesh);

                this.trailGeo = new THREE.BufferGeometry();
                this.trailMat = new THREE.LineBasicMaterial({ color: this.meta.color, linewidth: 2 });
                this.trail = new THREE.Line(this.trailGeo, this.trailMat);
                scene.add(this.trail);

                this.recordPosition();
            }

            step() {
                if (this.finished) return;

                // 1. Get Gradient
                const { z, dx, dy } = Functions[GLOBAL_STATE.func](this.pos.x, this.pos.y);
                
                // 2. Safety Check: If we hit Infinity/NaN, reset or stop
                if (!isFinite(z) || isNaN(dx) || isNaN(dy)) {
                    this.finished = true; // Stop optimization explicitly
                    return;
                }

                // Check convergence (gradient is almost zero)
                // For SGS we loosen this check a bit or keep it same, but noise keeps it moving
                if (Math.sqrt(dx*dx + dy*dy) < 0.001) {
                    this.finished = true; 
                    return;
                }

                const lr = this.config.lr;
                let sx = 0, sy = 0;

                // --- ALGORITHMS ---
                if (this.id === 'SGD') {
                    sx = -lr * dx; sy = -lr * dy;
                }
                else if (this.id === 'SGS') {
                    // ADDED SGS LOGIC
                    // We use 'mom' config parameter as Noise Magnitude
                    const noiseMag = this.config.mom;
                    // Random noise uniform [-1, 1] scaled by magnitude
                    const noiseX = (Math.random() * 2 - 1) * noiseMag;
                    const noiseY = (Math.random() * 2 - 1) * noiseMag;
                    
                    sx = -lr * (dx + noiseX);
                    sy = -lr * (dy + noiseY);
                }
                else if (this.id === 'Momentum') {
                    const gamma = this.config.mom;
                    this.velocity.x = gamma * this.velocity.x + lr * dx;
                    this.velocity.y = gamma * this.velocity.y + lr * dy;
                    sx = -this.velocity.x; sy = -this.velocity.y;
                }
                else if (this.id === 'Adam') {
                    this.t++;
                    const b1 = 0.9, b2 = 0.999, eps = 1e-8;
                    this.m.x = b1*this.m.x + (1-b1)*dx;
                    this.m.y = b1*this.m.y + (1-b1)*dy;
                    this.v.x = b2*this.v.x + (1-b2)*(dx*dx);
                    this.v.y = b2*this.v.y + (1-b2)*(dy*dy);
                    
                    // Bias correction
                    const mH_x = this.m.x / (1 - Math.pow(b1, this.t));
                    const mH_y = this.m.y / (1 - Math.pow(b1, this.t));
                    const vH_x = this.v.x / (1 - Math.pow(b2, this.t));
                    const vH_y = this.v.y / (1 - Math.pow(b2, this.t));
                    
                    sx = -lr * mH_x / (Math.sqrt(vH_x) + eps);
                    sy = -lr * mH_y / (Math.sqrt(vH_y) + eps);
                }
                else if (this.id.startsWith('CG')) {
                    if (!this.prevGrad) {
                        this.prevDir = { x: -dx, y: -dy };
                        this.prevGrad = { x: dx, y: dy };
                    } else {
                        const gTk = dx*dx + dy*dy;
                        const gTk_prev = this.prevGrad.x**2 + this.prevGrad.y**2;
                        const dGx = dx - this.prevGrad.x;
                        const dGy = dy - this.prevGrad.y;
                        
                        let beta = 0;
                        const eps = 1e-8;

                        if (this.id === 'CG_FR') beta = gTk / (gTk_prev + eps);
                        else if (this.id === 'CG_PR') beta = Math.max(0, (dx*dGx + dy*dGy)/(gTk_prev + eps));
                        else if (this.id === 'CG_HS') beta = (dx*dGx + dy*dGy) / (this.prevDir.x*dGx + this.prevDir.y*dGy + eps);
                        else if (this.id === 'CG_DY') beta = gTk / (this.prevDir.x*dGx + this.prevDir.y*dGy + eps);

                        // CG Safety reset
                        const dot = (-dx + beta * this.prevDir.x) * dx + (-dy + beta * this.prevDir.y) * dy;
                        if (dot > 0 || beta > 10 || isNaN(beta)) {
                            beta = 0; // Restart
                            this.prevDir = { x: -dx, y: -dy };
                        } else {
                            this.prevDir = { 
                                x: -dx + beta * this.prevDir.x, 
                                y: -dy + beta * this.prevDir.y 
                            };
                        }
                        this.prevGrad = { x: dx, y: dy };
                    }
                    sx = this.prevDir.x * lr;
                    sy = this.prevDir.y * lr;
                }

                // --- GRADIENT CLIPPING (CRITICAL FIX) ---
                // –ó–∞–ø–æ–±—ñ–≥–∞—î –≤–∏–ª—å–æ—Ç—É –≤ 10^23
                const maxStep = 0.5; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –∑—Å—É–≤ –∑–∞ –æ–¥–∏–Ω —Ç—ñ–∫
                const stepLen = Math.sqrt(sx*sx + sy*sy);
                
                if (stepLen > maxStep) {
                    const ratio = maxStep / stepLen;
                    sx *= ratio;
                    sy *= ratio;
                    
                    // –Ø–∫—â–æ Momentum –Ω–∞–¥—Ç–æ —Ä–æ–∑—ñ–≥–Ω–∞–≤—Å—è - –≥–∞–ª—å–º—É—î–º–æ –π–æ–≥–æ –≤–µ–∫—Ç–æ—Ä —Ç–µ–∂
                    if (this.id === 'Momentum') {
                        this.velocity.x *= ratio;
                        this.velocity.y *= ratio;
                    }
                }

                this.pos.x += sx;
                this.pos.y += sy;
                
                // Bounds Check
                if(Math.abs(this.pos.x) > 20 || Math.abs(this.pos.y) > 20) {
                     this.finished = true;
                }

                this.steps++;
                this.recordPosition();
            }

            // ... (—Ä–µ—à—Ç–∞ –º–µ—Ç–æ–¥—ñ–≤ –∫–ª–∞—Å—É: recordPosition, updateVisuals, getLoss, cleanup –±–µ–∑ –∑–º—ñ–Ω)
            recordPosition() {
                const z = Functions[GLOBAL_STATE.func](this.pos.x, this.pos.y).z;
                this.path.push(new THREE.Vector3(this.pos.x, z, this.pos.y));
            }

            updateVisuals() {
                const scale = GLOBAL_STATE.visualScale;
                const last = this.path[this.path.length-1];
                
                // Safety Display for NaN
                if(!last) return;

                const visualPos = new THREE.Vector3(this.pos.x, last.y * scale + 0.1, this.pos.y);
                this.mesh.position.copy(visualPos);

                if (this.path.length > 1) {
                    const scaledPath = this.path.map(p => new THREE.Vector3(p.x, p.y * scale + 0.05, p.z));
                    this.trailGeo.setFromPoints(scaledPath);
                }
            }

            getLoss() {
                if(this.path.length === 0) return 0;
                return this.path[this.path.length-1].y;
            }
            
            cleanup() {
                scene.remove(this.mesh);
                scene.remove(this.trail);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.trailGeo.dispose();
                this.trailMat.dispose();
            }
        }

        // --- UI GENERATOR ---
        function createMethodsUI() {
            const container = document.getElementById('methods-list');
            container.innerHTML = '';

            Object.keys(METHODS_CONFIG).forEach(key => {
                const cfg = METHODS_CONFIG[key];
                
                // Wrapper
                const div = document.createElement('div');
                div.className = 'method-item';
                div.style.borderLeftColor = '#' + cfg.color.toString(16).padStart(6,'0');

                // Header
                const header = document.createElement('div');
                header.className = 'method-header';
                
                // Checkbox
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = key;
                cb.id = `cb_${key}`;
               // if(['SGD','Momentum'].includes(key)) cb.checked = true;
			   cb.checked = true;
                cb.style.width = 'auto'; cb.style.marginRight = '10px';

                // Label parts
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.style.background = '#' + cfg.color.toString(16).padStart(6,'0');
                
                const name = document.createElement('span');
                name.className = 'method-name';
                name.innerText = cfg.name;

                // Settings Toggle
                const btn = document.createElement('button');
                btn.className = 'settings-btn';
                btn.innerHTML = '‚öôÔ∏è';
                btn.onclick = (e) => {
                    e.stopPropagation();
                    document.getElementById(`settings_${key}`).classList.toggle('show');
                    btn.classList.toggle('active');
                };

                // Append Header
                header.append(cb, dot, name, btn);

                // Settings Panel
                const settings = document.createElement('div');
                settings.className = 'method-settings';
                settings.id = `settings_${key}`;
                
                // Inputs inside settings
                // MODIFIED: Added check for SGS to display second input, and proper label
                settings.innerHTML = `
                    <div class="param-row">
                        <span>Learning Rate:</span>
                        <input type="number" id="lr_${key}" value="${cfg.defaultLR}" step="0.001">
                    </div>
                    ${['Momentum', 'Adam', 'SGS'].includes(key) ? `
                    <div class="param-row">
                        <span>${key === 'SGS' ? '–†—ñ–≤–µ–Ω—å —à—É–º—É:' : 'Momentum:'}</span>
                        <input type="number" id="mom_${key}" value="${cfg.defaultMom}" step="0.1">
                    </div>` : ''}
                `;

                div.append(header, settings);
                container.appendChild(div);
            });
        }

        // --- SCENE SETUP ---
        function init() {
            createMethodsUI();

            const cont = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(cont.clientWidth, cont.clientHeight);
            cont.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212);

            camera = new THREE.PerspectiveCamera(25, cont.clientWidth/cont.clientHeight, 0.1, 100);
            camera.position.set(20, 12, 2);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(5, 10, 5);
            scene.add(dl);

            // Event Listeners
            window.addEventListener('resize', onResize);
            document.getElementById('btn-start').onclick = toggleSim;
            document.getElementById('btn-reset').onclick = resetSim;
            document.getElementById('presetSelect').onchange = applyPreset;
            
            document.getElementById('funcSelect').onchange = (e) => {
                GLOBAL_STATE.func = e.target.value;
                document.getElementById('presetSelect').value = 'custom';
                drawSurface(); resetSim();
            };
            
        document.getElementById('speedSlider').oninput = (e) => {
    // –ë–£–õ–û: GLOBAL_STATE.speed = parseInt(e.target.value);
    // –°–¢–ê–õ–û (parseFloat):
    GLOBAL_STATE.speed = parseFloat(e.target.value);
    document.getElementById('speedVal').innerText = e.target.value;
};

            document.getElementById('vScaleSlider').oninput = (e) => {
                GLOBAL_STATE.visualScale = parseFloat(e.target.value);
                document.getElementById('vScaleVal').innerText = GLOBAL_STATE.visualScale;
                drawSurface(); // Re-draw mesh with new scale
                optimizers.forEach(o => o.updateVisuals()); // Update existing balls
            };
			
			
document.getElementById('btn-random-pos').onclick = () => {
    // –ì–µ–Ω–µ—Ä—É—î–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—ñ X —Ç–∞ Y –≤ –º–µ–∂–∞—Ö –≤—ñ–¥ -6 –¥–æ 6
    // (–ú–µ–∂—ñ –æ–±—Ä–∞–Ω—ñ —Ç–∞–∫, —â–æ–± —Ç–æ—á–∫–∏ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –ø–æ—Ç—Ä–∞–ø–ª—è–ª–∏ —É –≤–∏–¥–∏–º—É –∑–æ–Ω—É –∫–∞–º–µ—Ä–∏)
    const range = 6;
    const rndX = (Math.random() * 2 - 1) * range;
    const rndY = (Math.random() * 2 - 1) * range;

    // –û–Ω–æ–≤–ª—é—î–º–æ –≥–ª–æ–±–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω
    GLOBAL_STATE.startPos = { x: rndX, y: rndY };

    // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é –∑ –Ω–æ–≤–∏–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
    resetSim();
};

            drawSurface();
            resetSim();
            animate();
        }

        function drawSurface() {
            if(surfaceMesh) { scene.remove(surfaceMesh); scene.remove(wireframeMesh); }
            targetMarkers.forEach(m => scene.remove(m));
            targetMarkers = [];

            const N = 100;
            const geo = new THREE.PlaneGeometry(15, 15, N, N);
            const pos = geo.attributes.position;
            const colors = [];

            // 1. Calculate values
            let minZ = Infinity, maxZ = -Infinity;
            for(let i=0; i<pos.count; i++){
                const z = Functions[GLOBAL_STATE.func](pos.getX(i), -pos.getY(i)).z;
                if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
            }

            // 2. Apply Scale and Colors
            for(let i=0; i<pos.count; i++){
                const x = pos.getX(i);
                const y = -pos.getY(i);
                const z = Functions[GLOBAL_STATE.func](x, y).z;
                
                // Apply VISUAL scale to Z (which maps to Y in 3D scene)
                pos.setZ(i, z * GLOBAL_STATE.visualScale);

                // Color based on unscaled Z relative range
                const t = (z - minZ) / (maxZ - minZ + 0.0001);
                const c = new THREE.Color();
                c.setHSL(0.7 - t*0.7, 0.8, 0.4); 
                colors.push(c.r, c.g, c.b);
            }

            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.computeVertexNormals();

            surfaceMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.7, side: THREE.DoubleSide }));
            surfaceMesh.rotation.x = -Math.PI/2;
            scene.add(surfaceMesh);

            // Wireframe
            const wireGeo = new THREE.WireframeGeometry(geo);
            wireframeMesh = new THREE.LineSegments(wireGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.05, transparent: true }));
            wireframeMesh.rotation.x = -Math.PI/2;
            scene.add(wireframeMesh);

            // Minima Flags
          // Minima Flags (–û–ù–û–í–õ–ï–ù–û: –®–∞—Ö–æ–≤–∏–π –ø—Ä–∞–ø–æ—Ä)
            const mins = GlobalMinima[GLOBAL_STATE.func];
            if(mins) {
                // 1. –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–µ–∫—Å—Ç—É—Ä—É —à–∞—Ö—ñ–≤–Ω–∏—Ü—ñ –≤ –ø–∞–º'—è—Ç—ñ
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,64,64); // –ë—ñ–ª–∏–π —Ñ–æ–Ω
                ctx.fillStyle = '#000000'; 
                // –ú–∞–ª—é—î–º–æ —á–æ—Ä–Ω—ñ –∫–≤–∞–¥—Ä–∞—Ç–∏
                ctx.fillRect(0,0,32,32); 
                ctx.fillRect(32,32,32,32);
                
                const checkerTex = new THREE.CanvasTexture(canvas);
                checkerTex.magFilter = THREE.NearestFilter; // –©–æ–± –ø—ñ–∫—Å–µ–ª—ñ –±—É–ª–∏ —á—ñ—Ç–∫–∏–º–∏

                mins.forEach(m => {
                    const mz = Functions[GLOBAL_STATE.func](m.x, m.y).z * GLOBAL_STATE.visualScale;
                    const group = new THREE.Group();

                    // –§–ª–∞–≥—à—Ç–æ–∫ (–°—ñ—Ä–∏–π)
                    const pole = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 2.0), 
                        new THREE.MeshBasicMaterial({color:0xaaaaaa})
                    );
                    pole.position.y = 1.25; // –ü—ñ–¥–Ω—ñ–º–∞—î–º–æ —Ç—Ä–æ—Ö–∏ –≤–∏—â–µ

                    // –°–∞–º –ø—Ä–∞–ø–æ—Ä (–ü–ª–æ—â–∏–Ω–∞ –∑ —Ç–µ–∫—Å—Ç—É—Ä–æ—é)
                    const flagGeo = new THREE.PlaneGeometry(0.8, 0.5);
                    const flagMat = new THREE.MeshBasicMaterial({ 
                        map: checkerTex, 
                        side: THREE.DoubleSide 
                    });
                    const flag = new THREE.Mesh(flagGeo, flagMat);
                    
                    // –ó–º—ñ—â—É—î–º–æ –ø—Ä–∞–ø–æ—Ä, —â–æ–± –≤—ñ–Ω –∫—Ä—ñ–ø–∏–≤—Å—è –±–æ–∫–æ–º –¥–æ –ø–∞–ª–∏—Ü—ñ
                    flag.position.set(0.4, 2.2, 0); 

                    group.add(pole, flag);
                    group.position.set(m.x, mz, m.y);
                    
                    // –¢—Ä–æ—Ö–∏ –Ω–∞—Ö–∏–ª—è—î–º–æ –≤—Å—é –≥—Ä—É–ø—É –¥–ª—è –¥–∏–Ω–∞–º—ñ–∫–∏, —è–∫—â–æ —Ö–æ—á–µ—Ç–µ (–æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ)
                    // group.rotation.z = -0.1; 
                    
                    targetMarkers.push(group);
                    scene.add(group);
                });
            }
        }

        function resetSim() {
            isRunning = false;
            document.getElementById('btn-start').innerText = "‚ñ∂ –°—Ç–∞—Ä—Ç";
            document.getElementById('btn-start').style.background = "#2196f3";
            
            optimizers.forEach(o => o.cleanup());
            optimizers = [];

            // Find Checked
            const checked = document.querySelectorAll('#methods-list input[type="checkbox"]:checked');
            checked.forEach(cb => {
                const key = cb.value;
                const lr = parseFloat(document.getElementById(`lr_${key}`).value);
                const momElem = document.getElementById(`mom_${key}`);
                const mom = momElem ? parseFloat(momElem.value) : 0;
                
                optimizers.push(new Optimizer(key, {lr, mom}, GLOBAL_STATE.startPos));
            });

            updateStats();
        }

        function toggleSim() {
            isRunning = !isRunning;
            const btn = document.getElementById('btn-start');
            if(isRunning) { btn.innerText = "‚ùö‚ùö –ü–∞—É–∑–∞"; btn.style.background = "#ff9800"; }
            else { btn.innerText = "‚ñ∂ –°—Ç–∞—Ä—Ç"; btn.style.background = "#2196f3"; }
        }

        function updateStats() {
            const table = document.getElementById('stats-table');
            // Rebuild stats only if row count differs (simple optim)
            if(table.rows.length !== optimizers.length) {
                table.innerHTML = '';
                optimizers.forEach(opt => {
                    const tr = document.createElement('tr');
                    tr.id = `stat-row-${opt.id}`;
                    tr.style.color = '#' + opt.meta.color.toString(16).padStart(6,'0');
                    tr.innerHTML = `<td>${opt.meta.name.split('(')[0]}</td><td id="stat-val-${opt.id}">0.00</td>`;
                    table.appendChild(tr);
                });
            }

            optimizers.forEach(opt => {
                const el = document.getElementById(`stat-val-${opt.id}`);
                if(el) {
                    el.innerText = `L: ${opt.getLoss().toFixed(4)} | i: ${opt.steps}`;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (isRunning) {
                for(let i=0; i<GLOBAL_STATE.speed; i++) {
                    optimizers.forEach(o => o.step());
                }
                optimizers.forEach(o => o.updateVisuals());
                updateStats();
            }

            renderer.render(scene, camera);
        }

        function applyPreset(e) {
            const v = e.target.value;
            const toggle = (list) => {
                document.querySelectorAll('input[type="checkbox"]').forEach(c => c.checked = false);
                list.forEach(k => {
                    const cb = document.getElementById(`cb_${k}`);
                    if(cb) cb.checked = true;
                });
            };
            const setLR = (k, val) => {
                const inp = document.getElementById(`lr_${k}`);
                if(inp) inp.value = val;
            };

            if (v === 'valley_cg') {
                GLOBAL_STATE.func = 'valley';
                GLOBAL_STATE.startPos = {x: 2, y: -6};
               // toggle(['SGD', 'CG_FR', 'CG_PR']);
                //setLR('SGD', 0.5); setLR('CG_FR', 0.8); setLR('CG_PR', 0.8);
            } 
            else if (v === 'rosenbrock') {
                GLOBAL_STATE.func = 'rosenbrock';
                GLOBAL_STATE.startPos = {x: -2, y: 3};
                //toggle(['Momentum', 'Adam', 'CG_HS']);
                //setLR('Momentum', 0.2); setLR('Adam', 0.5); setLR('CG_HS', 0.2);
            }
            else if (v === 'beale') {
                GLOBAL_STATE.func = 'beale';
                GLOBAL_STATE.startPos = {x: -3, y: 3};
                //toggle(['SGD', 'Adam', 'CG_DY']);
                //setLR('SGD', 0.5); setLR('Adam', 0.1); setLR('CG_DY', 0.5);
            }
            else if (v === 'himmelblau') {
                GLOBAL_STATE.func = 'himmelblau';
                GLOBAL_STATE.startPos = {x: 0, y: 0};
                //toggle(['SGD', 'Momentum', 'Adam', 'CG_PR']); // 4 methods!
            }
            
            document.getElementById('funcSelect').value = GLOBAL_STATE.func;
            drawSurface(); resetSim();
        }

        function onResize() {
            const c = document.getElementById('scene-container');
            camera.aspect = c.clientWidth/c.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(c.clientWidth, c.clientHeight);
        }

        init();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice CNN Snake: 2D Latent</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #0f172a; --panel: #1e293b; --text: #f1f5f9; 
            --accent: #3b82f6; --success: #22c55e; --danger: #ef4444; --warn: #f59e0b;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        header { padding: 10px 20px; background: var(--panel); border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; font-size: 1.2rem; color: var(--accent); }
        
        .workspace { display: grid; grid-template-columns: 350px 1fr 300px; gap: 10px; padding: 10px; height: calc(100vh - 60px); }
        
        .panel { background: var(--panel); border-radius: 8px; padding: 15px; overflow-y: auto; border: 1px solid #334155; display: flex; flex-direction: column; gap: 10px; }
        .panel h3 { margin-top: 0; border-bottom: 1px solid #475569; padding-bottom: 5px; font-size: 1rem; color: #94a3b8; }

        button { padding: 8px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; background: #334155; color: white; transition: 0.2s; }
        button:hover { background: #475569; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-rec { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px; border: 1px solid #475569; padding: 6px 10px; }
        .btn-rec.recording { background: #fee2e2; color: #b91c1c; border-color: #ef4444; animation: pulse 1s infinite; }
        .count-badge { background: #0f172a; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }

        .btn-primary { background: var(--accent); } .btn-primary:hover { background: #2563eb; }
        .btn-success { background: var(--success); color: #000; } .btn-success:hover { background: #16a34a; }
        
        canvas { background: black; border-radius: 4px; width: 100%; }
        #spectrogramCanvas { height: 100px; image-rendering: pixelated; }
        #snakeCanvas { flex: 1; border: 2px solid #334155; }
        
        .pred-row { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; font-size: 0.9em; }
        .bar-bg { flex: 1; height: 8px; background: #334155; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s; }
        .pred-row.active .bar-fill { background: var(--success); }
        .pred-row.disabled { opacity: 0.3; }

        input[type=range] { width: 100%; accent-color: var(--accent); }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        
        /* –ì—Ä–∞—Ñ—ñ–∫–∏ */
        .plot-container { border: 1px solid #334155; border-radius: 4px; background: #0f172a; }
    </style>
</head>
<body>

<header>
    <h1>üß† 2D Bottleneck Voice Snake</h1>
    <div style="font-size: 0.8rem; color: #94a3b8;">Bottleneck: 2 Neurons</div>
</header>

<div class="workspace">
    <div class="panel">
        <h3>1. –î–∞–Ω—ñ</h3>
        <button id="btnRec0" class="btn-rec" onmousedown="startRec(0)" onmouseup="stopRec()" ontouchstart="startRec(0)" ontouchend="stopRec()">
            <span>üõë "–°—Ç–æ–ø"</span> <span id="cnt0" class="count-badge">0</span>
        </button>
        <button id="btnRec1" class="btn-rec" onmousedown="startRec(1)" onmouseup="stopRec()" ontouchstart="startRec(1)" ontouchend="stopRec()">
            <span>‚¨ÜÔ∏è "–í–ø–µ—Ä–µ–¥"</span> <span id="cnt1" class="count-badge">0</span>
        </button>
        <button id="btnRec2" class="btn-rec" onmousedown="startRec(2)" onmouseup="stopRec()" ontouchstart="startRec(2)" ontouchend="stopRec()">
            <span>‚û°Ô∏è "–ü—Ä–∞–≤–æ—Ä—É—á"</span> <span id="cnt2" class="count-badge">0</span>
        </button>
        <button id="btnRec3" class="btn-rec" onmousedown="startRec(3)" onmouseup="stopRec()" ontouchstart="startRec(3)" ontouchend="stopRec()">
            <span>‚¨ÖÔ∏è "–õ—ñ–≤–æ—Ä—É—á"</span> <span id="cnt3" class="count-badge">0</span>
        </button>
        
        <div><canvas id="spectrogramCanvas" width="32" height="32"></canvas></div>

        <h3>2. –ù–∞–≤—á–∞–Ω–Ω—è —Ç–∞ –õ–∞—Ç–µ–Ω—Ç</h3>
        <button id="btnTrain" class="btn-primary" onclick="trainNetwork()">üöÄ –ù–∞–≤—á–∏—Ç–∏ (2D Bottleneck)</button>
        
        <div style="font-size:0.8rem; color:#94a3b8; margin-top:5px;">–ü–æ–º–∏–ª–∫–∞ (Loss):</div>
        <div id="loss-plot" class="plot-container" style="height: 100px;"></div>
        
        <div style="font-size:0.8rem; color:#94a3b8; margin-top:5px;">–õ–∞—Ç–µ–Ω—Ç–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä (2 –Ω–µ–π—Ä–æ–Ω–∏):</div>
        <div id="latent-plot" class="plot-container" style="height: 250px;"></div>

        <div style="display:flex; gap:5px; margin-top:10px;">
            <button onclick="saveNetwork()" class="btn-success" style="flex:1">üíæ Save</button>
            <button onclick="document.getElementById('fileInput').click()" style="background:#475569; flex:1">üìÇ Load</button>
            <input type="file" id="fileInput" style="display:none" onchange="loadNetwork(this)">
        </div>
    </div>

    <div class="panel" style="padding: 0; overflow: hidden; position: relative;">
        <canvas id="snakeCanvas"></canvas>
        <div id="gameOverlay" style="position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; pointer-events: none;">
            <h2 style="color: var(--accent);">–ì–æ–ª–æ—Å–æ–≤–∞ –ó–º—ñ–π–∫–∞</h2>
            <p>–°–∫–∞–∂—ñ—Ç—å "–í–ø–µ—Ä–µ–¥"!</p>
        </div>
        <div style="position: absolute; top: 10px; right: 10px; font-size: 1.5rem; font-weight: bold; color: rgba(255,255,255,0.5);">
            Score: <span id="scoreVal" style="color:white">0</span>
        </div>
        <div style="position: absolute; bottom: 10px; left: 10px; font-size: 0.9rem; color: #94a3b8;">
            –¢–µ—Ä—Ç—è: <span id="momentumVal" style="color:white">0%</span>
        </div>
    </div>

    <div class="panel">
        <h3>üîç –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è</h3>
        <button id="btnListen" class="btn-success" onclick="toggleListening()">üéôÔ∏è –°—Ç–∞—Ä—Ç –º—ñ–∫—Ä–æ—Ñ–æ–Ω—É</button>
        
        <div style="margin: 15px 0; border-top:1px solid #334155; padding-top:10px;">
            <label style="font-size:0.9rem; display:flex; justify-content:space-between;">
                <span>Noise Gate</span> <span id="gateVal">10%</span>
            </label>
            <input type="range" id="noiseGate" min="0" max="100" value="10" oninput="document.getElementById('gateVal').innerText = this.value + '%'">
            <div style="height: 5px; background: #334155; border-radius: 2px; margin-top: 5px; overflow: hidden;">
                <div id="volBar" style="height: 100%; width: 0%; background: #ef4444; transition: width 0.1s;"></div>
            </div>
        </div>

        <h3>–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è</h3>
        <div id="predictions"></div>
        <div style="margin-top: auto; border-top: 1px solid #334155; padding-top: 10px;">
            <div style="font-size: 0.8rem; color: #94a3b8;">–ö–æ–º–∞–Ω–¥–∞: <span id="lastCmd" style="color: var(--accent); font-weight: bold;">-</span></div>
        </div>
    </div>
</div>

<script>
/**
 * === –ß–ê–°–¢–ò–ù–ê 1: CNN (Modified for 2D Bottleneck) ===
 */
class Layer {
    constructor() { this.input = null; this.output = null; }
    forward(input) { return input; }
    backward(grad) { return grad; }
}

class Conv2D extends Layer {
    constructor(inChannels, outChannels, kernelSize=3) {
        super();
        this.inChannels = inChannels; this.outChannels = outChannels; this.k = kernelSize;
        const scale = Math.sqrt(2.0 / (inChannels * kernelSize * kernelSize));
        this.filters = new Float32Array(outChannels * inChannels * kernelSize * kernelSize).map(() => (Math.random() - 0.5) * 2 * scale);
        this.biases = new Float32Array(outChannels).fill(0);
        this.gradFilters = new Float32Array(this.filters.length);
        this.gradBiases = new Float32Array(this.biases.length);
    }
    forward(input) {
        this.input = input; const { w, h, d } = input;
        const outW = (w - this.k) + 1; const outH = (h - this.k) + 1;
        this.output = { w: outW, h: outH, d: this.outChannels, data: new Float32Array(outW * outH * this.outChannels) };
        for (let oc = 0; oc < this.outChannels; oc++) {
            for (let y = 0; y < outH; y++) {
                for (let x = 0; x < outW; x++) {
                    let sum = this.biases[oc];
                    for (let ic = 0; ic < d; ic++) {
                        for (let ky = 0; ky < this.k; ky++) {
                            for (let kx = 0; kx < this.k; kx++) {
                                sum += input.data[(ic * h + y + ky) * w + x + kx] * this.filters[((oc * d + ic) * this.k + ky) * this.k + kx];
                            }
                        }
                    }
                    this.output.data[(oc * outH + y) * outW + x] = sum > 0 ? sum : 0; // ReLU
                }
            }
        }
        return this.output;
    }
    backward(gradOutput) {
        const { w: inW, h: inH, d: inD } = this.input; const { w: outW, h: outH, d: outD } = this.output;
        const gradInput = new Float32Array(inD * inH * inW).fill(0);
        this.gradFilters.fill(0); this.gradBiases.fill(0);
        for (let oc = 0; oc < outD; oc++) {
            for (let y = 0; y < outH; y++) {
                for (let x = 0; x < outW; x++) {
                    const idx = (oc * outH + y) * outW + x;
                    let chain = gradOutput.data[idx];
                    if (this.output.data[idx] <= 0) chain = 0;
                    this.gradBiases[oc] += chain;
                    for (let ic = 0; ic < inD; ic++) {
                        for (let ky = 0; ky < this.k; ky++) {
                            for (let kx = 0; kx < this.k; kx++) {
                                const inIdx = (ic * inH + y + ky) * inW + x + kx;
                                const fIdx = ((oc * inD + ic) * this.k + ky) * this.k + kx;
                                this.gradFilters[fIdx] += this.input.data[inIdx] * chain;
                                gradInput[inIdx] += this.filters[fIdx] * chain;
                            }
                        }
                    }
                }
            }
        }
        return { w: inW, h: inH, d: inD, data: gradInput };
    }
}

class MaxPool2x2 extends Layer {
    forward(input) {
        this.input = input; const { w, h, d } = input;
        const outW = Math.floor(w/2); const outH = Math.floor(h/2);
        this.output = { w: outW, h: outH, d: d, data: new Float32Array(outW*outH*d) };
        this.mask = new Int32Array(outW*outH*d);
        for (let c=0; c<d; c++) {
            for (let y=0; y<outH; y++) {
                for (let x=0; x<outW; x++) {
                    let maxVal = -Infinity, maxIdx = -1;
                    for (let dy=0; dy<2; dy++) for (let dx=0; dx<2; dx++) {
                        const idx = (c*h + y*2+dy)*w + x*2+dx;
                        if (input.data[idx] > maxVal) { maxVal = input.data[idx]; maxIdx = idx; }
                    }
                    const outIdx = (c*outH+y)*outW+x;
                    this.output.data[outIdx] = maxVal; this.mask[outIdx] = maxIdx;
                }
            }
        }
        return this.output;
    }
    backward(gradOutput) {
        const gradInput = new Float32Array(this.input.data.length).fill(0);
        for (let i=0; i<gradOutput.data.length; i++) gradInput[this.mask[i]] = gradOutput.data[i];
        return { ...this.input, data: gradInput };
    }
}

class Flatten extends Layer {
    forward(input) { this.inputShape = { ...input }; this.output = input.data; return this.output; }
    backward(grad) { return { ...this.inputShape, data: grad }; }
}

class Dense extends Layer {
    constructor(inSize, outSize) {
        super();
        this.inSize = inSize; this.outSize = outSize;
        const scale = Math.sqrt(2.0/inSize);
        this.weights = new Float32Array(inSize*outSize).map(() => (Math.random()-0.5)*2*scale);
        this.biases = new Float32Array(outSize).fill(0);
        this.gradW = new Float32Array(this.weights.length);
        this.gradB = new Float32Array(this.biases.length);
    }
    forward(input) {
        this.input = input; this.output = new Float32Array(this.outSize);
        for (let i=0; i<this.outSize; i++) {
            let sum = this.biases[i];
            for (let j=0; j<this.inSize; j++) sum += input[j] * this.weights[i*this.inSize+j];
            this.output[i] = sum > 0 ? sum : 0; // ReLU
        }
        return this.output;
    }
    backward(grad) {
        const gradIn = new Float32Array(this.inSize).fill(0);
        this.gradW.fill(0); this.gradB.fill(0);
        for (let i=0; i<this.outSize; i++) {
            let chain = grad[i];
            if (this.output[i] <= 0) chain = 0;
            this.gradB[i] += chain;
            for (let j=0; j<this.inSize; j++) {
                this.gradW[i*this.inSize+j] += this.input[j] * chain;
                gradIn[j] += this.weights[i*this.inSize+j] * chain;
            }
        }
        return gradIn;
    }
}

class SoftmaxLayer extends Layer {
    forward(input) {
        this.input = input; const max = Math.max(...input);
        const exps = input.map(v => Math.exp(v - max));
        const sum = exps.reduce((a,b) => a+b, 0);
        this.output = exps.map(v => v/sum);
        return this.output;
    }
    backward(labelIndex) {
        const grad = new Float32Array(this.output);
        grad[labelIndex] -= 1;
        return grad;
    }
}

class CNN {
    constructor() {
        this.layers = [
            new Conv2D(1, 4, 3),    // 0: Conv
            new MaxPool2x2(),       // 1: Pool
            new Flatten(),          // 2: Flatten
            new Dense(900, 2),      // 3: BOTTLENECK (900 -> 2)
            new Dense(2, 4),        // 4: Head (2 -> 4)
            new SoftmaxLayer()      // 5: Softmax
        ];
        this.learningRate = 0.01;
    }
    
    forward(inputData) {
        let x = { w: 32, h: 32, d: 1, data: inputData };
        for (const layer of this.layers) x = layer.forward(x);
        return x;
    }

    // –û—Ç—Ä–∏–º–∞–Ω–Ω—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∑ –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É
    getLatent(inputData) {
        let x = { w: 32, h: 32, d: 1, data: inputData };
        // –ü—Ä–æ–≥–∞–Ω—è—î–º–æ —Ç—ñ–ª—å–∫–∏ –¥–æ —à–∞—Ä—É 3 (Dense 900->2) –≤–∫–ª—é—á–Ω–æ
        for(let i=0; i<=3; i++) {
            x = this.layers[i].forward(x);
        }
        return x; // –ü–æ–≤–µ—Ä—Ç–∞—î –º–∞—Å–∏–≤ –∑ 2 —á–∏—Å–µ–ª
    }

    train(inputData, labelIndex) {
        const output = this.forward(inputData);
        let grad = labelIndex;
        for (let i = this.layers.length - 1; i >= 0; i--) grad = this.layers[i].backward(grad);
        
        for (const layer of this.layers) {
            if (layer.weights) {
                for (let i=0; i<layer.weights.length; i++) layer.weights[i] -= layer.gradW[i] * this.learningRate;
                for (let i=0; i<layer.biases.length; i++) layer.biases[i] -= layer.gradB[i] * this.learningRate;
            }
            if (layer.filters) {
                for (let i=0; i<layer.filters.length; i++) layer.filters[i] -= layer.gradFilters[i] * this.learningRate;
                for (let i=0; i<layer.biases.length; i++) layer.biases[i] -= layer.gradBiases[i] * this.learningRate;
            }
        }
        return -Math.log(output[labelIndex] + 1e-7);
    }
}

/**
 * === –ß–ê–°–¢–ò–ù–ê 2: –ê—É–¥—ñ–æ (Noise Gate & Buffering) ===
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 64; analyser.smoothingTimeConstant = 0.4;
let isListening = false, isRecording = false, currentVolume = 0;
let samples = [], spectroBuffer = [];
const labels = ["–°—Ç–æ–ø", "–í–ø–µ—Ä–µ–¥", "–ü—Ä–∞–≤–æ—Ä—É—á", "–õ—ñ–≤–æ—Ä—É—á"];
const colors = ['#dc2626', '#22c55e', '#3b82f6', '#f59e0b']; // Colors for plotting
const SPECTRO_SIZE = 32;

async function initAudio() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioCtx.createMediaStreamSource(stream).connect(analyser);
        drawSpectrogramLoop();
    } catch (e) { alert("Mic Error: " + e); }
}

function getAudioFrame() {
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    let sum = 0; for(let i=0; i<data.length; i++) sum += data[i]**2;
    currentVolume = Math.sqrt(sum/data.length)/255.0;
    const bar = document.getElementById('volBar');
    if(bar) bar.style.width = Math.min(100, currentVolume*400) + "%";
    return Float32Array.from(data).map(v => v/255);
}

function drawSpectrogramLoop() {
    const frame = getAudioFrame();
    if (isRecording) {
        spectroBuffer.push(frame);
        if(spectroBuffer.length > SPECTRO_SIZE*2) spectroBuffer.shift();
    } else if (isListening) {
        spectroBuffer.push(frame);
        if(spectroBuffer.length > SPECTRO_SIZE) spectroBuffer.shift();
        if(spectroBuffer.length === SPECTRO_SIZE && Math.random() < 0.2) predictLive();
    } else {
        drawSpectroCanvas([frame], true);
        requestAnimationFrame(drawSpectrogramLoop); return;
    }
    drawSpectroCanvas(spectroBuffer);
    requestAnimationFrame(drawSpectrogramLoop);
}

function drawSpectroCanvas(buffer, single=false) {
    const ctx = document.getElementById('spectrogramCanvas').getContext('2d');
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);
    if(single) {
        const c = buffer[0]; for(let i=0; i<c.length; i++) {
            ctx.fillStyle = `rgb(${c[i]*255},${c[i]*255},${c[i]*255})`; ctx.fillRect(0,h-i*3,w,3);
        } return;
    }
    const cw = w/SPECTRO_SIZE, ch = h/32;
    const start = Math.max(0, buffer.length-SPECTRO_SIZE);
    for(let t=0; t<Math.min(buffer.length, SPECTRO_SIZE); t++) {
        const col = buffer[start+t];
        for(let f=0; f<col.length; f++) {
            const v = col[f]*255; ctx.fillStyle = `rgb(${v},${255-v},100)`;
            ctx.fillRect(t*cw, h-(f*ch), cw, ch);
        }
    }
}

function startRec(id) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    isRecording = true; spectroBuffer = [];
    document.getElementById(`btnRec${id}`).classList.add('recording');
}

function stopRec() {
    if(!isRecording) return; isRecording=false;
    let id = -1;
    for(let i=0; i<4; i++) if(document.getElementById(`btnRec${i}`).classList.contains('recording')) {
        document.getElementById(`btnRec${i}`).classList.remove('recording'); id=i;
    }
    if(id!==-1 && spectroBuffer.length >= 10) {
        const full = new Float32Array(SPECTRO_SIZE*32).fill(0);
        const len = Math.min(spectroBuffer.length, SPECTRO_SIZE);
        const start = spectroBuffer.length - len;
        for(let t=0; t<len; t++) for(let f=0; f<32; f++) full[(SPECTRO_SIZE-len+t)*32+f] = spectroBuffer[start+t][f];
        samples.push({ data: full, label: id });
        document.getElementById(`cnt${id}`).innerText = samples.filter(s=>s.label===id).length;
    }
}

/**
 * === –ß–ê–°–¢–ò–ù–ê 3: –ù–∞–≤—á–∞–Ω–Ω—è —Ç–∞ –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –õ–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É ===
 */
let net = new CNN();

async function trainNetwork() {
    if (samples.length < 4) { alert("–ó–∞–ø–∏—à—ñ—Ç—å –¥–∞–Ω—ñ!"); return; }
    const btn = document.getElementById('btnTrain');
    btn.disabled = true; btn.innerText = "–ù–∞–≤—á–∞–Ω–Ω—è...";
    
    const EPOCHS = 50; 
    const lossHistory = [];
    
    // Init Plots
    Plotly.newPlot('loss-plot', [{y:[], type:'scatter', mode:'lines', line:{color:'#3b82f6'}}], 
        {margin:{t:10,l:30,r:10,b:20}, height:100, paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', xaxis:{color:'#94a3b8'}, yaxis:{color:'#94a3b8'}});

    Plotly.newPlot('latent-plot', [], 
        {
            margin:{t:10,l:30,r:10,b:30}, height:250, 
            paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
            xaxis:{title:'N1', color:'#94a3b8', gridcolor:'#334155'}, 
            yaxis:{title:'N2', color:'#94a3b8', gridcolor:'#334155'},
            showlegend: false
        }
    );

    for (let e = 0; e < EPOCHS; e++) {
        let totalLoss = 0;
        samples.sort(() => Math.random() - 0.5);
        for (const s of samples) totalLoss += net.train(s.data, s.label);
        lossHistory.push(totalLoss / samples.length);
        
        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ –∫–æ–∂–Ω—ñ 5 –µ–ø–æ—Ö
        if (e % 2 === 0 || e === EPOCHS-1) {
            // Update Loss
            Plotly.animate('loss-plot', { data: [{y: lossHistory}] }, { transition: {duration: 0}, frame: {duration: 0, redraw: false} });
            
            // Update Latent
            updateLatentPlot();
            await new Promise(r => setTimeout(r, 10)); // UI Breath
        }
    }
    
    btn.disabled = false; btn.innerText = "üöÄ –ù–∞–≤—á–∏—Ç–∏ (2D Bottleneck)";
    alert("–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ª–∞—Ç–µ–Ω—Ç–Ω–∏–π –≥—Ä–∞—Ñ—ñ–∫.");
}

function updateLatentPlot() {
    // Collect all points
    const traces = [[], [], [], []]; // x, y arrays for 4 classes
    
    for(const s of samples) {
        const latent = net.getLatent(s.data); // [x, y]
        // latent - —Ü–µ Float32Array(2)
        if (!traces[s.label].x) { traces[s.label] = { x:[], y:[], mode:'markers', type:'scatter', marker:{color: colors[s.label], size: 8}, name: labels[s.label] }; }
        traces[s.label].x.push(latent[0]);
        traces[s.label].y.push(latent[1]);
    }
    
    // Filter empty traces
    const plotData = traces.filter(t => t.x && t.x.length > 0);
    Plotly.react('latent-plot', plotData, 
        {
            margin:{t:10,l:30,r:10,b:30}, height:250, 
            paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
            xaxis:{color:'#94a3b8', gridcolor:'#334155'}, 
            yaxis:{color:'#94a3b8', gridcolor:'#334155'},
            showlegend: true, legend: {x: 0, y: 1, font:{color:'white'}}
        }
    );
}

function predictLive() {
    const gateVal = parseInt(document.getElementById('noiseGate').value)/100.0;
    if ((Math.min(1.0, currentVolume*4)) < gateVal) { updatePredUI([], true); return; }

    const input = new Float32Array(SPECTRO_SIZE*32).fill(0);
    const snippet = spectroBuffer.slice(spectroBuffer.length-SPECTRO_SIZE);
    for(let t=0; t<SPECTRO_SIZE; t++) for(let f=0; f<32; f++) input[t*32+f] = snippet[t][f];
    
    const probs = net.forward(input);
    updatePredUI(probs, false);
    
    // Check command
    const maxIdx = probs.indexOf(Math.max(...probs));
    if (probs[maxIdx] > 0.7) handleVoiceCommand(maxIdx);
}

function updatePredUI(probs, isSilence) {
    const div = document.getElementById('predictions'); div.innerHTML='';
    if(isSilence) {
        labels.forEach(l => div.innerHTML+=`<div class="pred-row disabled"><span style="width:70px">${l}</span><div class="bar-bg"></div><span>...</span></div>`);
        return;
    }
    const max = Math.max(...probs);
    probs.forEach((p,i) => {
        div.innerHTML+=`<div class="pred-row ${i===probs.indexOf(max)&&p>0.7?'active':''}"><span style="width:70px">${labels[i]}</span><div class="bar-bg"><div class="bar-fill" style="width:${p*100}%"></div></div><span style="width:30px">${(p*100).toFixed(0)}%</span></div>`;
    });
}

// IO
function saveNetwork() {
    const data = { w:[], b:[], f:[] };
    net.layers.forEach(l => {
        if(l.weights) data.w.push(Array.from(l.weights));
        if(l.biases) data.b.push(Array.from(l.biases));
        if(l.filters) data.f.push(Array.from(l.filters));
    });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], {type:'application/json'}));
    a.download = 'voice-cnn-2d.json'; a.click();
}
function loadNetwork(inp) {
    const r = new FileReader();
    r.onload = e => {
        const d = JSON.parse(e.target.result); let wi=0, bi=0, fi=0;
        net.layers.forEach(l => {
            if(l.weights) l.weights.set(d.w[wi++]);
            if(l.biases) l.biases.set(d.b[bi++]);
            if(l.filters) l.filters.set(d.f[fi++]);
        }); alert("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!");
    }; r.readAsText(inp.files[0]);
}

/**
 * === –ß–ê–°–¢–ò–ù–ê 4: Game Physics ===
 */
const cvs = document.getElementById('snakeCanvas'), ctx = cvs.getContext('2d');
let snake=[{x:10,y:10}], food={x:15,y:15}, dir={x:0,y:-1}, score=0, momentum=0, moveAcc=0;
const GRID=20, FRICTION=0.02;

window.onresize=()=>{cvs.width=cvs.parentElement.clientWidth;cvs.height=cvs.parentElement.clientHeight;}; window.onresize();

function gameLoop() {
    if(momentum>0) { momentum-=FRICTION; if(momentum<0) momentum=0; }
    document.getElementById('momentumVal').innerText = (momentum*100).toFixed(0)+"%";
    
    moveAcc += momentum;
    if(moveAcc >= 1.0) { moveAcc -= 1.0; moveSnake(); }
    drawGame();
}

function moveSnake() {
    const head = {x:snake[0].x+dir.x, y:snake[0].y+dir.y};
    const tw=Math.floor(cvs.width/GRID), th=Math.floor(cvs.height/GRID);
    if(head.x<0) head.x=tw-1; if(head.x>=tw) head.x=0;
    if(head.y<0) head.y=th-1; if(head.y>=th) head.y=0;
    
    if(snake.some(s=>s.x===head.x && s.y===head.y)) return resetGame();
    snake.unshift(head);
    if(head.x===food.x && head.y===food.y) {
        score++; document.getElementById('scoreVal').innerText=score;
        food={x:Math.floor(Math.random()*tw),y:Math.floor(Math.random()*th)};
        momentum=Math.min(1.5, momentum+0.2);
    } else snake.pop();
}

function drawGame() {
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,cvs.width,cvs.height);
    ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(food.x*GRID+GRID/2,food.y*GRID+GRID/2,GRID/2-2,0,7); ctx.fill();
    ctx.fillStyle='#22c55e'; snake.forEach((s,i)=>{ if(i>0)ctx.fillRect(s.x*GRID+1,s.y*GRID+1,GRID-2,GRID-2); });
    
    // Head Arrow
    const cx=snake[0].x*GRID+GRID/2, cy=snake[0].y*GRID+GRID/2;
    ctx.save(); ctx.translate(cx,cy);
    let ang=0;
    if(dir.x===0 && dir.y===-1) ang=0; else if(dir.x===1) ang=Math.PI/2;
    else if(dir.y===1) ang=Math.PI; else if(dir.x===-1) ang=-Math.PI/2;
    ctx.rotate(ang);
    ctx.fillStyle='#4ade80'; ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(8,8); ctx.lineTo(-8,8); ctx.fill();
    ctx.restore();
}

function resetGame() { snake=[{x:10,y:10}]; dir={x:0,y:-1}; score=0; momentum=0; document.getElementById('scoreVal').innerText=0; document.getElementById('gameOverlay').style.display='block'; }

let lastCmd=0;
function handleVoiceCommand(i) {
    if(Date.now()-lastCmd<300) return; lastCmd=Date.now();
    document.getElementById('lastCmd').innerText=labels[i];
    document.getElementById('gameOverlay').style.display='none';
    if(i===1) momentum=1.0;
    else if(i===0) momentum=0;
    else if(i===2) dir={x:-dir.y, y:dir.x};
    else if(i===3) dir={x:dir.y, y:-dir.x};
}

setInterval(gameLoop, 100);
initAudio();
function toggleListening() { 
    isListening=!isListening; 
    document.getElementById('btnListen').innerText=isListening?"üõë –°—Ç–æ–ø":"üéôÔ∏è –°—Ç–∞—Ä—Ç";
    if(audioCtx.state==='suspended') audioCtx.resume();
    if(!isListening) momentum=0;
}
</script>
</body>
</html>
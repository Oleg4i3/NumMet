<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN</title>
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #4f46e5;
            --secondary: #059669; 
            --accent: #d97706;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1f2937;
            --border: #e2e8f0;
        }

        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 20px; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 30px; }

        h1, h2, h3 { margin-top: 0; color: #111827; }
        h1 { text-align: center; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #6b7280; margin-bottom: 5px; }

        /* SPOILERS & TEXT */
        .theory-block { display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        details { background: #fff; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        summary { padding: 10px; cursor: pointer; font-weight: 500; background: #f1f5f9; }
        .spoiler-content { padding: 5px; font-size: 0.95rem; border-top: 1px solid var(--border); }
        .tag { padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold; margin-right: 5px; }
        .tag-math { background: #fee2e2; color: #991b1b; }

        /* CARDS */
        .card { background: var(--card); padding: 5px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border: 1px solid var(--border); }
        .card-header { border-bottom: 1px solid var(--border); padding-bottom: 15px; margin-bottom: 20px; }
        .row { display: flex; gap: 5px; justify-content: center; align-items: flex-start; flex-wrap: wrap; }
        
        /* GRIDS */
        .grid-container { text-align: center; display: flex; flex-direction: column; align-items: center; }
        .grid { display: grid; gap: 2px; background: #94a3b8; border: 2px solid #475569; margin: 10px auto; width: fit-content; position: relative; }
        .cell { width: 40px; height: 40px; background: white; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: bold; transition: all 0.1s; position: relative; user-select: none; color: #333; }
        
        /* INTERACTIVITY */
        .interactive .cell { cursor: pointer; }
        .interactive .cell:hover { opacity: 0.8; }
        .cell.active { background: #1f2937; color: white; }
        
        /* VISUAL FEEDBACK */
        .cell.scanning { box-shadow: inset 0 0 0 3px var(--primary); z-index: 10; }
        .cell.best-match-border { box-shadow: inset 0 0 0 4px #22c55e !important; z-index: 20; border-color: #22c55e; }

        /* KERNEL OVERLAY IN INPUT */
        .kernel-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.7rem; color: var(--primary); font-weight: bold;
            background: rgba(255, 255, 255, 0.7); pointer-events: none;
        }

        /* OUTPUT MAPS */
        .out-cell { font-size: 0.8rem; color: #555; font-weight: bold;}

        /* UI CONTROLS */
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 500; transition: 0.2s; }
        button:hover { background: #4338ca; transform: translateY(-1px); }
        button:disabled { background: #9ca3af; cursor: not-allowed; transform: none; }
        .btn-reset { background: #64748b; font-size: 0.8rem; padding: 5px 10px; }
        .btn-sm { font-size: 0.8rem; padding: 4px 8px; background: #e2e8f0; color: #333; }
        .btn-sm:hover { background: #cbd5e1; }
        
        .arrow-box { display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100px; max-width: 150px; text-align: center; font-size: 0.9rem; color: #6b7280; }
        .big-arrow { font-size: 2rem; color: #cbd5e1; margin: 5px 0; }

        /* PART 3 SPECIFIC */
        .kernel-display { margin-bottom: 5px; border: 2px solid var(--primary); cursor: pointer; transition: 0.2s;}
        .kernel-display:hover { border-color: #f59e0b; box-shadow: 0 0 8px rgba(245, 158, 11, 0.4); }
        .kernel-display .cell { font-size: 0; width: 25px; height: 25px; }
        .k-pos { background: #1f2937 !important; }

        .toggle-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; background: #f1f5f9; padding: 10px; border-radius: 30px; border: 1px solid #e2e8f0; width: fit-content; margin: 0 auto 20px auto; }
        .switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(24px); }

        /* NUMERICAL METHODS STUFF */
        .chart-container { width: 100%; height: 150px; background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; margin-top: 10px; }
        .lr-control { display: flex; align-items: center; gap: 10px; background: #fefce8; padding: 10px; border: 1px solid #fde047; border-radius: 8px; margin-bottom: 10px; font-size: 0.9rem; }
        .activation-box { background: #e0e7ff; padding: 8px; border-radius: 6px; border: 1px solid #c7d2fe; margin-bottom: 10px; width: 100%; text-align: center; }
        
        .filter-box { border: 1px dashed #cbd5e1; padding: 10px; border-radius: 8px; background: #f8fafc; display: flex; flex-direction: column; align-items: center; min-width: 120px; }
        .status { font-weight: bold; height: 30px; margin-top: 15px; font-size: 1.1rem; text-align: center;}
    </style>
</head>
<body>

<div class="container">
   
<div class="theory-block">
        <details>
            <summary><div>üìö <strong>–¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∏–π –¥–æ–≤—ñ–¥–Ω–∏–∫: –∑–≥–æ—Ä—Ç–∫–æ–≤—ñ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ</strong></div></summary>
            <div class="spoiler-content">
                
                <h3>–í—Å—Ç—É–ø: –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥–µ–ª—ñ</h3>
                <p>
                    –£ —Ü—å–æ–º—É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ —Ä–æ–∑–≥–ª—è–¥–∞—î—Ç—å—Å—è —Å–ø—Ä–æ—â–µ–Ω–∞ –º–æ–¥–µ–ª—å <strong>–ó–≥–æ—Ä—Ç–∫–æ–≤–æ—ó –ù–µ–π—Ä–æ–Ω–Ω–æ—ó –ú–µ—Ä–µ–∂—ñ (CNN - Convolutional Neural Network)</strong>. 
                    –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ —Ü–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, —â–æ –≤–∏–∫–æ–Ω—É—î –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω—å –≤—Ö—ñ–¥–Ω–æ–≥–æ —Ç–µ–Ω–∑–æ—Ä–∞ (–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è) –¥–ª—è –≤–∏–ª—É—á–µ–Ω–Ω—è —ñ—î—Ä–∞—Ä—Ö—ñ—á–Ω–∏—Ö –æ–∑–Ω–∞–∫.
                </p>
                <p>
                    –ù–∞—à–∞ –º–æ–¥–µ–ª—å —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è –∑:
                </p>
                <ul>
                    <li><strong>–í—Ö—ñ–¥–Ω–∏–π —à–∞—Ä ($X$):</strong> –ú–∞—Ç—Ä–∏—Ü—è —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ $N \times N$, —â–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –¥–∏—Å–∫—Ä–µ—Ç–Ω–µ –¥–≤–æ–≤–∏–º—ñ—Ä–Ω–µ –ø–æ–ª–µ (–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è).</li>
                    <li><strong>–Ø–¥—Ä–æ –∑–≥–æ—Ä—Ç–∫–∏ / –§—ñ–ª—å—Ç—Ä ($W$):</strong> –ú–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ $K \times K$ ($K < N$), —è–∫–∞ –º—ñ—Å—Ç–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–∏, —â–æ –Ω–∞–≤—á–∞—é—Ç—å—Å—è.</li>
                    <li><strong>–û–ø–µ—Ä–∞—Ü—ñ—è –∑–≥–æ—Ä—Ç–∫–∏ (*):</strong> –õ—ñ–Ω—ñ–π–Ω–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä, —â–æ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—î –ª–æ–∫–∞–ª—å–Ω—ñ –æ–∫—ñ–ª –ø—ñ–∫—Å–µ–ª—ñ–≤ —É —Å–∫–∞–ª—è—Ä.</li>
                    <li><strong>–§—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó ($f$):</strong> –ù–µ–ª—ñ–Ω—ñ–π–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è, —â–æ –∑–∞—Å—Ç–æ—Å–æ–≤—É—î—Ç—å—Å—è –ø–æ–µ–ª–µ–º–µ–Ω—Ç–Ω–æ.</li>
                </ul>

                <hr class="divider">

                <h3>–ß–∞—Å—Ç–∏–Ω–∞ 1: –ß–∏—Å–µ–ª—å–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —Ç–∞ –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫</h3>
                <p>
                    –ù–∞–≤—á–∞–Ω–Ω—è –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ ‚Äî —Ü–µ –∑–∞–¥–∞—á–∞ <strong>–º—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—ó —Ü—ñ–ª—å–æ–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó</strong> (—Ñ—É–Ω–∫—Ü—ñ—ó –≤—Ç—Ä–∞—Ç). –ú–∏ –Ω–∞–º–∞–≥–∞—î–º–æ—Å—è –∑–Ω–∞–π—Ç–∏ —Ç–∞–∫—ñ –≤–∞–≥–∏ —è–¥—Ä–∞ $W$, —â–æ–± –≤–∏—Ö—ñ–¥ –º–µ—Ä–µ–∂—ñ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–≤ –±–∞–∂–∞–Ω–æ–º—É —à–∞–±–ª–æ–Ω—É $T$.
                </p>
                
                <h4>1. –§—É–Ω–∫—Ü—ñ—è –≤—Ç—Ä–∞—Ç (Loss Function)</h4>
                <p>–ú–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ <em>Mean Squared Error (MSE)</em> ‚Äî —Å–µ—Ä–µ–¥–Ω—å–æ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω—É –ø–æ–º–∏–ª–∫—É, —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É –º–µ—Ç—Ä–∏–∫—É –≤ –∑–∞–¥–∞—á–∞—Ö —Ä–µ–≥—Ä–µ—Å—ñ—ó —Ç–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—ó:</p>
                $$ J(W) = \frac{1}{n} \sum_{i,j} (T_{i,j} - W_{i,j})^2 $$
                <p>–î–µ $J$ ‚Äî –∑–Ω–∞—á–µ–Ω–Ω—è –ø–æ–º–∏–ª–∫–∏, $T$ ‚Äî —Ü—ñ–ª—å–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü—è, $W$ ‚Äî –ø–æ—Ç–æ—á–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è –≤–∞–≥, $n$ ‚Äî –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤.</p>

                <h4>2. –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫ (Gradient Descent)</h4>
                <p>
                    –û—Å–∫—ñ–ª—å–∫–∏ $J(W)$ —î –≥–ª–∞–¥–∫–æ—é —Ç–∞ –¥–∏—Ñ–µ—Ä–µ–Ω—Ü—ñ–π–æ–≤–Ω–æ—é (–ø–∞—Ä–∞–±–æ–ª–æ—ó–¥ —É –ø—Ä–æ—Å—Ç–æ—Ä—ñ –≤–∞–≥), –º–∏ –º–æ–∂–µ–º–æ –∑–Ω–∞–π—Ç–∏ –º—ñ–Ω—ñ–º—É–º, —Ä—É—Ö–∞—é—á–∏—Å—å —É –Ω–∞–ø—Ä—è–º–∫—É –∞–Ω—Ç–∏–≥—Ä–∞–¥—ñ—î–Ω—Ç–∞.
                    –ì—Ä–∞–¥—ñ—î–Ω—Ç $\nabla J$ ‚Äî —Ü–µ –≤–µ–∫—Ç–æ—Ä —á–∞—Å—Ç–∫–æ–≤–∏—Ö –ø–æ—Ö—ñ–¥–Ω–∏—Ö –ø–æ –∫–æ–∂–Ω–æ–º—É –≤–∞–≥–æ–≤–æ–º—É –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—É:
                </p>
                $$ \frac{\partial J}{\partial W_{i,j}} = \frac{\partial}{\partial W_{i,j}} (T_{i,j} - W_{i,j})^2 = -2(T_{i,j} - W_{i,j}) $$

                <h4>3. –ü—Ä–∞–≤–∏–ª–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∞–≥ —Ç–∞ Learning Rate</h4>
                <p>–Ü—Ç–µ—Ä–∞—Ç–∏–≤–Ω–∏–π –ø—Ä–æ—Ü–µ—Å —É—Ç–æ—á–Ω–µ–Ω–Ω—è –≤–∞–≥ –æ–ø–∏—Å—É—î—Ç—å—Å—è —Ñ–æ—Ä–º—É–ª–æ—é:</p>
                $$ W_{new} = W_{old} - \alpha \cdot \nabla J $$
                <p>–ê–±–æ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç–∞ (—Å–ø—Ä–æ—â–µ–Ω–æ, –≤—ñ–¥–∫–∏–¥–∞—é—á–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É 2, —è–∫—É –ø–æ–≥–ª–∏–Ω–∞—î $\alpha$):</p>
                $$ W_{i,j}^{(t+1)} = W_{i,j}^{(t)} + \alpha \cdot (T_{i,j} - W_{i,j}^{(t)}) $$
                <p><strong>–ü–∞—Ä–∞–º–µ—Ç—Ä $\alpha$ (Learning Rate)</strong> ‚Äî —Ü–µ –∫—Ä–æ–∫ —ñ–Ω—Ç–µ–≥—Ä—É–≤–∞–Ω–Ω—è. –£ —á–∏—Å–µ–ª—å–Ω–∏—Ö –º–µ—Ç–æ–¥–∞—Ö –≤—ñ–Ω –≤–∏–∑–Ω–∞—á–∞—î —Å—Ç—ñ–π–∫—ñ—Å—Ç—å —Å—Ö–µ–º–∏:</p>
                <ul>
                    <li><strong>–ú–∞–ª–∏–π $\alpha$ ($\ll 1$):</strong> –ó–∞–±–µ–∑–ø–µ—á—É—î —Å—Ç–∞–±—ñ–ª—å–Ω—É –∑–±—ñ–∂–Ω—ñ—Å—Ç—å, –∞–ª–µ –ø—Ä–æ—Ü–µ—Å –¥—É–∂–µ –ø–æ–≤—ñ–ª—å–Ω–∏–π (–≤–µ–ª–∏–∫–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —ñ—Ç–µ—Ä–∞—Ü—ñ–π).</li>
                    <li><strong>–í–µ–ª–∏–∫–∏–π $\alpha$ ($> 2$):</strong> –ü–æ—Ä—É—à—É—î —É–º–æ–≤—É –ö—É—Ä–∞–Ω—Ç–∞-–§—Ä—ñ–¥—Ä—ñ—Ö—Å–∞-–õ–µ–≤—ñ (–∞–Ω–∞–ª–æ–≥—ñ—è –∑ —Ä–æ–∑–≤'—è–∑–∫–æ–º –¥–∏—Ñ. —Ä—ñ–≤–Ω—è–Ω—å), –ø—Ä–∏–∑–≤–æ–¥–∏—Ç—å –¥–æ –æ—Å—Ü–∏–ª—è—Ü—ñ–π –Ω–∞–≤–∫–æ–ª–æ –º—ñ–Ω—ñ–º—É–º—É –∞–±–æ —Ä–æ–∑–±—ñ–∂–Ω–æ—Å—Ç—ñ –ø—Ä–æ—Ü–µ—Å—É ("–≤–∏–±—É—Ö" –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞).</li>
                </ul>

                <hr class="divider">

                <h3>–ß–∞—Å—Ç–∏–Ω–∞ 2: –î–∏—Å–∫—Ä–µ—Ç–Ω–∞ –∑–≥–æ—Ä—Ç–∫–∞</h3>
                <p>
                    –û–ø–µ—Ä–∞—Ü—ñ—è, —è–∫—É –≤ Deep Learning –Ω–∞–∑–∏–≤–∞—é—Ç—å "–∑–≥–æ—Ä—Ç–∫–æ—é" (Convolution), –∑ —Ç–æ—á–∫–∏ –∑–æ—Ä—É —á–∏—Å—Ç–æ—ó –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ —Ç–∞ –æ–±—Ä–æ–±–∫–∏ —Å–∏–≥–Ω–∞–ª—ñ–≤ —î <strong>–∫—Ä–æ—Å-–∫–æ—Ä–µ–ª—è—Ü—ñ—î—é (Cross-Correlation)</strong>.
                </p>
                
                <h4>–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è</h4>
                <p>–î–ª—è –≤—Ö—ñ–¥–Ω–æ—ó –º–∞—Ç—Ä–∏—Ü—ñ $I$ —Ç–∞ —è–¥—Ä–∞ $K$, –∑–Ω–∞—á–µ–Ω–Ω—è –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ –ø—ñ–∫—Å–µ–ª—è $S(i, j)$ –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è —è–∫ —Å–∫–∞–ª—è—Ä–Ω–∏–π –¥–æ–±—É—Ç–æ–∫ (—Å—É–º–∞ –¥–æ–±—É—Ç–∫—ñ–≤):</p>
                $$ S(i, j) = (I * K)(i, j) = \sum_{m=0}^{k-1} \sum_{n=0}^{k-1} I(i+m, j+n) \cdot K(m, n) $$
                
                <p><strong>–ù—é–∞–Ω—Å —Ç–µ—Ä–º—ñ–Ω–æ–ª–æ–≥—ñ—ó:</strong></p>
                <ul>
                    <li>–°–ø—Ä–∞–≤–∂–Ω—è –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ <em>–∑–≥–æ—Ä—Ç–∫–∞</em> –≤–∏–º–∞–≥–∞—î —ñ–Ω–≤–µ—Ä—Å—ñ—ó —è–¥—Ä–∞ (–ø–æ–≤–æ—Ä–æ—Ç—É –Ω–∞ 180¬∞) –ø–µ—Ä–µ–¥ –º–Ω–æ–∂–µ–Ω–Ω—è–º: $K(m, n) \to K(-m, -n)$. –¶–µ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –¥–ª—è –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ –∫–æ–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—ñ ($f*g = g*f$).</li>
                    <li>–£ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞—Ö –∫–æ–º—É—Ç–∞—Ç–∏–≤–Ω—ñ—Å—Ç—å –Ω–µ –≤–∞–∂–ª–∏–≤–∞, –Ω–∞–º –≤–∞–∂–ª–∏–≤–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è —à–∞–±–ª–æ–Ω—ñ–≤. –¢–æ–º—É –º–∏ –Ω–µ –ø–µ—Ä–µ–≤–µ—Ä—Ç–∞—î–º–æ —è–¥—Ä–æ. –¶—è –æ–ø–µ—Ä–∞—Ü—ñ—è ("–∫–æ–≤–∑–∞—é—á–∏–π —Å–∫–∞–ª—è—Ä–Ω–∏–π –¥–æ–±—É—Ç–æ–∫") –≤–∏–º—ñ—Ä—é—î <strong>—Å—Ö–æ–∂—ñ—Å—Ç—å</strong> –¥—ñ–ª—è–Ω–∫–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ —Ñ—ñ–ª—å—Ç—Ä–æ–º.</li>
                </ul>

                <hr class="divider">

                <h3>–ß–∞—Å—Ç–∏–Ω–∞ 3: –ù–µ–ª—ñ–Ω—ñ–π–Ω—ñ—Å—Ç—å —Ç–∞ –§—É–Ω–∫—Ü—ñ—ó –ê–∫—Ç–∏–≤–∞—Ü—ñ—ó</h3>
                <p>
                    –ß–æ–º—É –Ω–µ –º–æ–∂–Ω–∞ –ø—Ä–æ—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –ª—ñ–Ω—ñ–π–Ω—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è, —è–∫ —É SVD (Singular Value Decomposition) –∞–±–æ PCA?
                    –Ø–∫—â–æ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞ —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è –ª–∏—à–µ –∑ –ª—ñ–Ω—ñ–π–Ω–∏—Ö —à–∞—Ä—ñ–≤ (–∑–≥–æ—Ä—Ç–æ–∫, –º–Ω–æ–∂–µ–Ω–Ω—è –º–∞—Ç—Ä–∏—Ü—å), —Ç–æ —Å—É–ø–µ—Ä–ø–æ–∑–∏—Ü—ñ—è (–∫–æ–º–ø–æ–∑–∏—Ü—ñ—è) –±—É–¥—å-—è–∫–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –ª—ñ–Ω—ñ–π–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π —î –ø—Ä–æ—Å—Ç–æ —ñ–Ω—à–æ—é –ª—ñ–Ω—ñ–π–Ω–æ—é —Ñ—É–Ω–∫—Ü—ñ—î—é:
                </p>
                $$ W_2(W_1(x)) = (W_2 \cdot W_1)x = W_{combined} x $$
                <p>
                    –¶–µ –æ–±–º–µ–∂—É—î –º–æ–¥–µ–ª—å: –≤–æ–Ω–∞ –º–æ–∂–µ —Ä–æ–∑–¥—ñ–ª—è—Ç–∏ –∫–ª–∞—Å–∏ –ª–∏—à–µ –≥—ñ–ø–µ—Ä–ø–ª–æ—â–∏–Ω–∞–º–∏. –©–æ–± –∞–ø—Ä–æ–∫—Å–∏–º—É–≤–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ –∫—Ä–∏–≤–æ–ª—ñ–Ω—ñ–π–Ω—ñ –≥—Ä–∞–Ω–∏—Ü—ñ —Ç–∞ —Ä–æ–∑–≤'—è–∑—É–≤–∞—Ç–∏ –Ω–µ–ª—ñ–Ω—ñ–π–Ω—ñ –∑–∞–¥–∞—á—ñ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, XOR –∞–±–æ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –æ–±—Ä–∞–∑—ñ–≤), –Ω–µ–æ–±—Ö—ñ–¥–Ω–∞ –Ω–µ–ª—ñ–Ω—ñ–π–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó $f(x)$. –¢–æ–¥—ñ –≤–∏—Ö—ñ–¥ —à–∞—Ä—É: $y = f(Wx + b)$.
                </p>

                <h4>–û—Å–Ω–æ–≤–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó:</h4>

                <p><strong>1. ReLU (Rectified Linear Unit):</strong></p>
                $$ f(x) = \max(0, x) $$
                <ul>
                    <li><em>–í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ:</em> –ù–∞–π–ø–æ–ø—É–ª—è—Ä–Ω—ñ—à–∞ —Ñ—É–Ω–∫—Ü—ñ—è –≤ –≥–ª–∏–±–æ–∫–æ–º—É –Ω–∞–≤—á–∞–Ω–Ω—ñ. –í–æ–Ω–∞ —î –∫—É—Å–∫–æ–≤–æ-–ª—ñ–Ω—ñ–π–Ω–æ—é.</li>
                    <li><em>–ü–µ—Ä–µ–≤–∞–≥–∏:</em> –û–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω–æ –¥–µ—à–µ–≤–∞ (–ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑ –Ω—É–ª–µ–º). –í–∏—Ä—ñ—à—É—î –ø—Ä–æ–±–ª–µ–º—É "–∑–Ω–∏–∫–∞—é—á–æ–≥–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞" –¥–ª—è $x > 0$. –†–æ–±–∏—Ç—å –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó —Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω–∏–º–∏ (sparse), –≤—ñ–¥—Å—ñ–∫–∞—é—á–∏ —à—É–º.</li>
                </ul>

                <p><strong>2. Sigmoid (–õ–æ–≥—ñ—Å—Ç–∏—á–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è):</strong></p>
                $$ f(x) = \sigma(x) = \frac{1}{1 + e^{-x}} $$
                <ul>
                    <li><em>–í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ:</em> –í—ñ–¥–æ–±—Ä–∞–∂–∞—î $\mathbb{R} \to (0, 1)$. –ú–∞—î —ñ—Å—Ç–æ—Ä–∏—á–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (—ñ–º—ñ—Ç–∞—Ü—ñ—è –Ω–∞—Å–∏—á–µ–Ω–Ω—è –Ω–µ–π—Ä–æ–Ω–∞).</li>
                    <li><em>–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:</em> –Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç—É—î—Ç—å—Å—è —è–∫ "–π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å". –ß–∞—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –Ω–∞ –≤–∏—Ö—ñ–¥–Ω–æ–º—É —à–∞—Ä—ñ –¥–ª—è –±—ñ–Ω–∞—Ä–Ω–æ—ó –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó.</li>
                    <li><em>–ù–µ–¥–æ–ª—ñ–∫–∏:</em> –ü—Ä–∏ –≤–µ–ª–∏–∫–∏—Ö $|x|$ –ø–æ—Ö—ñ–¥–Ω–∞ $\to 0$, —â–æ –∑—É–ø–∏–Ω—è—î –Ω–∞–≤—á–∞–Ω–Ω—è (vanishing gradients).</li>
                </ul>

                <p><strong>3. Tanh (–ì—ñ–ø–µ—Ä–±–æ–ª—ñ—á–Ω–∏–π —Ç–∞–Ω–≥–µ–Ω—Å):</strong></p>
                $$ f(x) = \tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} $$
                <ul>
                    <li><em>–í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ:</em> –í—ñ–¥–æ–±—Ä–∞–∂–∞—î $\mathbb{R} \to (-1, 1)$.</li>
                    <li><em>–ü–µ—Ä–µ–≤–∞–≥–∏:</em> –ù–∞ –≤—ñ–¥–º—ñ–Ω—É –≤—ñ–¥ —Å–∏–≥–º–æ—ó–¥–∏, —Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–∞ –≤—ñ–¥–Ω–æ—Å–Ω–æ –Ω—É–ª—è. –¶–µ –∫–æ—Ä–∏—Å–Ω–æ –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–∏—Ö —à–∞—Ä—ñ–≤ –º–µ—Ä–µ–∂—ñ, –æ—Å–∫—ñ–ª—å–∫–∏ —Å–µ—Ä–µ–¥–Ω—î –∑–Ω–∞—á–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–∞—Ü—ñ–π –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –±–ª–∏–∑—å–∫–∏–º –¥–æ 0.</li>
                </ul>
            </div>
        </details>
    </div>
	
	
	

    <div class="card">
        <div class="card-header">
            <h2>1. –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫ (Optimization)</h2>
            <p>–°–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞–π—Ç–µ –∑–∞ –∑–±—ñ–∂–Ω—ñ—Å—Ç—é (Convergence) –∞–±–æ —Ä–æ–∑–±—ñ–∂–Ω—ñ—Å—Ç—é (Divergence) –ø—Ä–æ—Ü–µ—Å—É –Ω–∞–≤—á–∞–Ω–Ω—è.</p>
        </div>
        
        <div class="lr-control">
            <span><strong>Learning Rate ($\alpha$):</strong></span>
            <input type="range" id="lrSlider" min="0.01" max="3.0" step="0.05" value="0.1" oninput="updateLrDisplay()">
            <span id="lrValue" style="font-weight:bold; min-width:40px;">0.10</span>
            <small style="color:#666; margin-left:10px;">(>2.0 = —Ä–∏–∑–∏–∫ –Ω–µ—Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ)</small>
        </div>

        <div class="row">
            <div class="grid-container">
                <h4> –¶—ñ–ª—å–æ–≤–∏–π –ø–∞—Ç–µ—Ä–Ω (–í—á–∏—Ç–µ–ª—å)</h4>
                <div id="targetGrid" class="grid interactive"></div>
                <small>–ë–∞–∂–∞–Ω–∏–π –ø–∞—Ç–µ—Ä–Ω $T$</small>
            </div>
            <div class="arrow-box">
                <div class="big-arrow">‚û°</div>
                <div>Loss = $\frac{1}{n}\sum(T-W)^2$</div>
                <div>$\Delta W = \alpha \cdot (T-W)$</div>
            </div>
            <div class="grid-container">
                <h4> Kernel (–Ø–¥—Ä–æ)</h4>
                <div id="trainKernel" class="grid"></div>
                <small>–í–∞–≥–∏ $W$</small>
            </div>
        </div>

        <div style="width: 100%; display: flex; justify-content: center;">
            <div class="grid-container" style="width: 80%;">
                <h4>–ì—Ä–∞—Ñ—ñ–∫ –ø–æ–º–∏–ª–∫–∏ (MSE Loss)</h4>
                <canvas id="lossChart" class="chart-container"></canvas>
            </div>
        </div>

        <div style="text-align: center; margin-top: 20px;">
            <button onclick="startAutoTrain()" id="btnAutoTrain">‚ñ∂ –ê–≤—Ç–æ-–Ω–∞–≤—á–∞–Ω–Ω—è</button>
            <button onclick="trainEpoch()"> 1 –∫—Ä–æ–∫ (Epoch)</button>
            <button class="btn-reset" onclick="resetWeights()">üîÑ –°–∫–∏–Ω—É—Ç–∏ –≤–∞–≥–∏</button>
        </div>
    </div>

    <div class="card">
        <div class="card-header">
            <h2>2. –ó–≥–æ—Ä—Ç–∫–∞ + –ê–∫—Ç–∏–≤–∞—Ü—ñ—è $f(x)$</h2>
            <p>–í–ø–ª–∏–≤ –Ω–µ–ª—ñ–Ω—ñ–π–Ω–æ—Å—Ç—ñ –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–µ—Ç–µ–∫—Ç—É–≤–∞–Ω–Ω—è. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —è–¥—Ä–æ –∑ –ß–∞—Å—Ç–∏–Ω–∏ 1.</p>
        </div>
        
        <div class="activation-box">
            <label for="scanActivation"><strong>–§—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó: </strong></label>
            <select id="scanActivation" style="width:auto; display:inline-block; font-weight:bold;">
                <option value="none">Linear (None)</option>
                <option value="relu" selected>ReLU (max(0, x))</option>
                <option value="sigmoid">Sigmoid (0...1)</option>
                <option value="tanh">Tanh (-1...1)</option>
            </select>
        </div>

        <div class="row">
            <div class="grid-container">
                <h4>–í—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è</h4>
                <div id="inputGrid" class="grid interactive"></div>
                <button class="btn-reset" onclick="clearInput()" style="margin-top: 5px;">–û—á–∏—Å—Ç–∏—Ç–∏</button>
            </div>
            
            <div class="arrow-box">
                 <small>–ü–æ—Ç–æ—á–Ω–µ —è–¥—Ä–æ:</small>
                 <div id="miniKernelDisplay" class="grid" style="transform: scale(0.6); margin: 5px 0;"></div>
                 <div class="big-arrow">‚û°</div>
                 <button onclick="runScan()" id="scanBtn">‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –∑–≥–æ—Ä—Ç–∫—É</button>
            </div>

            <div class="grid-container">
                <h4>–†–µ–∑—É–ª—å—Ç–∞—Ç (Feature Map)</h4>
                <div id="outputGrid" class="grid"></div>
            </div>
        </div>
        <div id="scanLog" style="margin-top: 15px; font-family: monospace; font-size: 0.9rem; color: #4b5563; height: 1.5em; text-align: center; font-weight: bold;"></div>
    </div>

    <div class="card">
        <header>
            <h2>3. Deep Learning & –ù–µ–ª—ñ–Ω—ñ–π–Ω—ñ—Å—Ç—å</h2>
        </header>

        <div class="toggle-container">
            <span style="font-size:0.9rem; color:#4b5563; margin-right:5px;">–ë—ñ–Ω–∞—Ä–Ω–∏–π</span>
            <label class="switch">
                <input type="checkbox" id="checkHeatmap" onchange="updateViewMode()" checked>
                <span class="slider"></span>
            </label>
            <span style="font-size:0.9rem; color:var(--primary); font-weight:bold; margin-left:5px;">Heatmap</span>
        </div>

        <div class="activation-box" style="background:#fff7ed; border-color:#fed7aa;">
            <div style="display:flex; justify-content:center; align-items:center; gap:20px; flex-wrap: wrap;">
                <div>
                    <label><strong>–†–µ–∂–∏–º –æ–±—á–∏—Å–ª–µ–Ω—å:</strong></label>
                    <select id="calcMode" onchange="runDeepCalc()" style="width:auto;">
                        <option value="heuristic">–ï–≤—Ä–∏—Å—Ç–∏—á–Ω–∏–π (+1 —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è, -0.5 –Ω–µ—Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è)</option>
                        <option value="math" selected>–ó —Ñ—É–Ω–∫—Ü—ñ—î—é –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó</option>
                    </select>
                </div>
                <div>
                    <label><strong>–ê–∫—Ç–∏–≤–∞—Ü—ñ—è:</strong></label>
                    <select id="deepActivation" onchange="runDeepCalc()" style="width:auto;">
                        <option value="relu">ReLU</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="tanh">Tanh</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
        </div>

        <div style="text-align:center; margin-bottom:15px; border-bottom: 1px solid #eee; padding-bottom: 15px;">
            <strong>–ü—Ä–µ—Å–µ—Ç–∏</strong><br>
            <div class="btn-group" style="display:flex; gap:5px; justify-content:center; margin-top:5px;">
                <button class="btn-sm" onclick="loadInputPreset('cross')">–•—Ä–µ—Å—Ç–∏–∫</button>
                <button class="btn-sm" onclick="loadInputPreset('K_letter')">–õ—ñ—Ç–µ—Ä–∞ "K"</button>
                <button class="btn-sm" onclick="loadInputPreset('checker')">–®–∞—Ö—ñ–≤–Ω–∏—Ü—è</button>
                <button class="btn-sm" onclick="loadInputPreset('full_black')">–ß–æ—Ä–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç</button>
                <button class="btn-sm" onclick="clearDeepInput()" style="background:#fee2e2; color:#991b1b;">–û—á–∏—Å—Ç–∏—Ç–∏</button>
            </div>
        </div>

        <div class="row">
            
            <div class="column grid-container">
                <strong>–í—Ö—ñ–¥ (5x5)</strong>
                <div id="deepInput" class="grid interactive" style="grid-template-columns: repeat(5, 1fr);"></div>
            </div>

            <div class="arrow-box"><div class="big-arrow">‚û°</div></div>

            <div class="column grid-container">
                <strong>–®–∞—Ä 1 (Features)</strong>
                <div style="display:flex; gap: 15px;">
                    
                    <div class="filter-box">
                        <small style="color:#1e40af; font-weight:bold;">–§—ñ–ª—å—Ç—Ä 1 (Vert)</small>
                        <div id="visFilter1" class="grid kernel-display" style="grid-template-columns: repeat(3, 1fr);"></div>
                        <div style="font-size:1.5rem; line-height:1; color:#ccc;">‚¨á</div>
                        <div id="map1" class="grid" style="grid-template-columns: repeat(3, 1fr);"></div>
                    </div>

                    <div class="filter-box">
                        <small style="color:#991b1b; font-weight:bold;">–§—ñ–ª—å—Ç—Ä 2 (Horz)</small>
                        <div id="visFilter2" class="grid kernel-display" style="grid-template-columns: repeat(3, 1fr);"></div>
                        <div style="font-size:1.5rem; line-height:1; color:#ccc;">‚¨á</div>
                        <div id="map2" class="grid" style="grid-template-columns: repeat(3, 1fr);"></div>
                    </div>

                </div>
            </div>

            <div class="arrow-box"><div class="big-arrow">‚û°</div></div>

            <div class="column grid-container">
                <strong>–®–∞—Ä 2 (Output)</strong>
                <div class="filter-box" style="border-color: #8b5cf6; background: #f5f3ff; min-width: 140px;">
                    <small style="color:#6b21a8">–°—É–º–∞ (Detect)</small>
                    <div id="visCombined" class="grid" style="grid-template-columns: repeat(3, 1fr); border: none; background: transparent; gap: 4px; pointer-events: none;"></div>
                    <div style="font-size:1.5rem; line-height:1; color:#ccc;">‚¨á</div>
                    <div id="mapMix" class="grid" style="grid-template-columns: repeat(3, 1fr);"></div>
                </div>
            </div>

        </div>

        <div style="text-align:center; margin-top:20px;">
            <button onclick="runDeepCalc()" id="btnRun" style="padding: 12px 30px; font-size:1rem;">–û–ë–ß–ò–°–õ–ò–¢–ò</button>
            <div id="statusMsg" class="status"></div>
            <div id="debugInfo" style="font-size:0.85rem; color:#666; margin-top:5px;"></div>
        </div>
    </div>

</div>

<script>
    /* =========================================
       MATH & UTILS
       ========================================= */
    
    const Activations = {
        'none': (x) => x,
        'relu': (x) => Math.max(0, x),
        'sigmoid': (x) => 1 / (1 + Math.exp(-x)),
        'tanh': (x) => Math.tanh(x)
    };

    // Absolute Heatmap Color Logic
    function getHeatmapColor(val) {
        // Absolute scale. 
        // 0 -> White
        // +4 -> Full Red
        // -4 -> Full Blue
        const maxScale = 4.0;
        let norm = val / maxScale;
        
        // Clamp -1 to 1
        if(norm > 1) norm = 1;
        if(norm < -1) norm = -1;

        if (Math.abs(val) < 0.05) return '#f3f4f6'; // Neutral gray

        if (norm > 0) {
            // RED shade
            // 255, 255-x, 255-x
            let intensity = Math.floor(255 * (1 - norm));
            return `rgb(255, ${intensity}, ${intensity})`;
        } else {
            // BLUE shade
            // 255-x, 255-x, 255
            let intensity = Math.floor(255 * (1 - Math.abs(norm)));
            return `rgb(${intensity}, ${intensity}, 255)`;
        }
    }

    // Chart Utils
    const chartState = { history: [], maxPoints: 50, canvas: null, ctx: null };

    function initChart() {
        chartState.canvas = document.getElementById('lossChart');
        chartState.canvas.width = chartState.canvas.offsetWidth;
        chartState.canvas.height = chartState.canvas.offsetHeight;
        chartState.ctx = chartState.canvas.getContext('2d');
        drawChart();
    }

    function updateChart(loss) {
        chartState.history.push(loss);
        if(chartState.history.length > chartState.maxPoints) chartState.history.shift();
        drawChart();
    }

    function clearChart() { chartState.history = []; drawChart(); }

    function drawChart() {
        const { ctx, canvas, history, maxPoints } = chartState;
        const w = canvas.width, h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        
        // Grid
        ctx.strokeStyle = '#f1f5f9'; ctx.lineWidth = 1; ctx.beginPath();
        for(let i=0; i<5; i++) { ctx.moveTo(0, i*h/4); ctx.lineTo(w, i*h/4); }
        ctx.stroke();

        if(history.length < 2) return;
        let maxVal = Math.max(...history, 0.1);
        if (maxVal > 10) maxVal = 10; 

        const padding = 10;
        const stepX = (w - padding * 2) / (maxPoints - 1);
        
        ctx.beginPath(); ctx.strokeStyle = '#4f46e5'; ctx.lineWidth = 2;
        history.forEach((val, i) => {
            let x = padding + i * stepX;
            let y = h - padding - (val / maxVal) * (h - padding * 2);
            if(y < padding) y = padding;
            if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();
    }

    /* =========================================
       PART 1 & 2: SCANNING
       ========================================= */
    
    const INPUT_SIZE = 6;
    const KERNEL_SIZE = 3;
    const OUTPUT_SIZE = INPUT_SIZE - KERNEL_SIZE + 1;
    
    let inputData = createMatrixPart1(INPUT_SIZE);
    let targetData = [[1, -1, 1], [1, 1, -1], [1, -1, 1]];
    let kernelWeights = createRandomMatrix(KERNEL_SIZE);
    let autoTrainInterval = null;

    function initScan() {
        renderInputGrid();
        renderTargetGrid();
        renderKernelGrid();
        createGridDiv(document.getElementById('outputGrid'), OUTPUT_SIZE, 'out-cell');
        createGridDiv(document.getElementById('miniKernelDisplay'), KERNEL_SIZE, 'cell'); // for part 2 view
        drawDemoLine();
        initChart();
        updateLrDisplay();
    }

    function updateLrDisplay() {
        document.getElementById('lrValue').textContent = parseFloat(document.getElementById('lrSlider').value).toFixed(2);
    }

    function renderInputGrid() {
        const div = document.getElementById('inputGrid');
        div.innerHTML = '';
        div.style.gridTemplateColumns = `repeat(${INPUT_SIZE}, 1fr)`;
        inputData.forEach((row, r) => {
            row.forEach((val, c) => {
                let cell = document.createElement('div');
                cell.className = 'cell ' + (val === 1 ? 'active' : '');
                cell.onclick = () => { if(!document.getElementById('scanBtn').disabled) {
                    inputData[r][c] = inputData[r][c] === 1 ? 0 : 1; renderInputGrid(); 
                }};
                div.appendChild(cell);
            });
        });
    }

    function renderTargetGrid() {
        const div = document.getElementById('targetGrid');
        div.innerHTML = '';
        div.style.gridTemplateColumns = `repeat(${KERNEL_SIZE}, 1fr)`;
        targetData.forEach((row, r) => {
            row.forEach((val, c) => {
                let cell = document.createElement('div');
                cell.className = 'cell';
                if(val === 1) cell.style.background = '#1f2937';
                else if(val === -1) { cell.style.background = '#fff'; cell.style.border = '1px solid red'; cell.style.color='red'; cell.textContent='-';}
                else { cell.style.background = '#e5e7eb'; }
                cell.onclick = () => {
                    if(val === 0) targetData[r][c] = 1; else if(val === 1) targetData[r][c] = -1; else targetData[r][c] = 0;
                    renderTargetGrid();
                };
                div.appendChild(cell);
            });
        });
    }

    function renderKernelGrid() {
        const div = document.getElementById('trainKernel');
        const miniDiv = document.getElementById('miniKernelDisplay');
        
        [div, miniDiv].forEach(d => {
            d.innerHTML = '';
            d.style.gridTemplateColumns = `repeat(${KERNEL_SIZE}, 1fr)`;
            kernelWeights.forEach((row, r) => {
                row.forEach((val, c) => {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = val.toFixed(1);
                    cell.style.backgroundColor = getHeatmapColor(val);
                    cell.style.color = Math.abs(val) > 2 ? 'white' : 'black';
                    d.appendChild(cell);
                });
            });
        });
    }

    function createGridDiv(container, size, cellClass) {
        container.innerHTML = '';
        container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        for(let i=0; i<size*size; i++) {
            let c = document.createElement('div'); c.className = 'cell ' + cellClass; container.appendChild(c);
        }
    }

    function trainEpoch() {
        const learningRate = parseFloat(document.getElementById('lrSlider').value);
        let totalSqError = 0;
        let count = 0;

        for(let i=0; i<KERNEL_SIZE; i++) {
            for(let j=0; j<KERNEL_SIZE; j++) {
                let t = targetData[i][j];
                let w = kernelWeights[i][j];
                let error = t - w; 
                totalSqError += error * error;
                count++;
                kernelWeights[i][j] += error * learningRate;
            }
        }
        updateChart(totalSqError / count);
        renderKernelGrid();
    }

    function startAutoTrain() {
        if(autoTrainInterval) {
            clearInterval(autoTrainInterval);
            autoTrainInterval = null;
            document.getElementById('btnAutoTrain').textContent = "‚ñ∂ –ê–≤—Ç–æ-–Ω–∞–≤—á–∞–Ω–Ω—è";
        } else {
            document.getElementById('btnAutoTrain').textContent = "‚èπ –°—Ç–æ–ø";
            autoTrainInterval = setInterval(trainEpoch, 100);
        }
    }

    function resetWeights() { 
        kernelWeights = createRandomMatrix(KERNEL_SIZE); 
        renderKernelGrid(); 
        clearChart();
    }

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    async function runScan() {
        const btn = document.getElementById('scanBtn');
        const log = document.getElementById('scanLog');
        const outDiv = document.getElementById('outputGrid');
        const inputDiv = document.getElementById('inputGrid');
        const actFuncType = document.getElementById('scanActivation').value;
        const actFunc = Activations[actFuncType];

        btn.disabled = true;
        log.textContent = `–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è (${actFuncType})...`;
        
        Array.from(outDiv.children).forEach(c => { c.textContent = ''; c.style.backgroundColor = '#f3f4f6'; });
        Array.from(inputDiv.children).forEach(c => c.classList.remove('best-match-border'));

        let maxVal = -Infinity;
        let bestCoords = null;

        for(let i=0; i<OUTPUT_SIZE; i++) {
            for(let j=0; j<OUTPUT_SIZE; j++) {
                
                highlightInputWithOverlay(i, j, true);
                
                let sum = 0;
                for(let ki=0; ki<KERNEL_SIZE; ki++) {
                    for(let kj=0; kj<KERNEL_SIZE; kj++) {
                        // Math logic: convert input 0 -> -1 to match kernel logic properly
                        let inPixel = inputData[i+ki][j+kj]; 
                        let inVal = (inPixel === 1) ? 1 : -1; 
                        let kVal = kernelWeights[ki][kj];
                        sum += inVal * kVal;
                    }
                }
                
                let val = actFunc(sum);

                if(val > maxVal) {
                    maxVal = val;
                    bestCoords = {r:i, c:j};
                }

                let cellIdx = i*OUTPUT_SIZE + j;
                let cell = outDiv.children[cellIdx];
                cell.textContent = val.toFixed(1);
                cell.style.backgroundColor = getHeatmapColor(val);
                if(Math.abs(val) > 2) cell.style.color = 'white'; else cell.style.color = '#333';

                await sleep(50); 
                highlightInputWithOverlay(i, j, false);
            }
        }

        if(maxVal > 0.5 && bestCoords) {
            log.textContent = `–ó–Ω–∞–π–¥–µ–Ω–æ –º–∞–∫—Å–∏–º—É–º: ${maxVal.toFixed(2)}`;
            drawBestMatchBorder(bestCoords.r, bestCoords.c);
        } else {
            log.textContent = "–°–∏–ª—å–Ω–∏—Ö –∑–±—ñ–≥—ñ–≤ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.";
        }
        btn.disabled = false;
    }

    function createMatrixPart1(size) { return Array(size).fill().map(() => Array(size).fill(0)); }
    function createRandomMatrix(size) { return Array(size).fill().map(() => Array(size).fill().map(() => Math.random() - 0.5)); }
    function drawDemoLine() { clearInput(); for(let i=0; i<INPUT_SIZE; i++) inputData[i][2] = 1; inputData[1][1] = 1; inputData[4][3] = 1;inputData[3][4] = 1; inputData[5][4] = 1; renderInputGrid(); }
    function clearInput() { inputData = createMatrixPart1(INPUT_SIZE); renderInputGrid(); }

    function highlightInputWithOverlay(r, c, active) {
        const div = document.getElementById('inputGrid');
        for(let i=0; i<KERNEL_SIZE; i++){
            for(let j=0; j<KERNEL_SIZE; j++){
                let idx = (r+i)*INPUT_SIZE + (c+j);
                let cell = div.children[idx];
                if(active) {
                    cell.classList.add('scanning');
                    let overlay = document.createElement('div');
                    overlay.className = 'kernel-overlay';
                    overlay.textContent = kernelWeights[i][j].toFixed(1);
                    cell.appendChild(overlay);
                } else {
                    cell.classList.remove('scanning');
                    let overlay = cell.querySelector('.kernel-overlay');
                    if(overlay) cell.removeChild(overlay);
                }
            }
        }
    }

    function drawBestMatchBorder(startR, startC) {
        const div = document.getElementById('inputGrid');
        for(let i=0; i<KERNEL_SIZE; i++){
            for(let j=0; j<KERNEL_SIZE; j++){
                let idx = (startR+i)*INPUT_SIZE + (startC+j);
                div.children[idx].classList.add('best-match-border');
            }
        }
    }
</script>

<script>
    /* =========================================
       PART 3: DEEP LEARNING (UPDATED)
       ========================================= */
    
    const SIZE_IN = 5;
    const SIZE_K = 3;
    const SIZE_OUT = 3;

    let deepInput = createMatrixDeep(SIZE_IN);
    let kernel1 = createMatrixDeep(SIZE_K);
    let kernel2 = createMatrixDeep(SIZE_K);
    
    let scores1 = createMatrixDeep(SIZE_OUT);
    let scores2 = createMatrixDeep(SIZE_OUT);
    let scoresMix = createMatrixDeep(SIZE_OUT);
    let hasRun = false;

    const FILTERS = {
        'vert': [[0, 1, 0], [0, 1, 0], [0, 1, 0]],
        'horz': [[0, 0, 0], [1, 1, 1], [0, 0, 0]],
        'checker': [[1, 0, 1], [0, 1, 0], [1, 0, 1]], 
        'custom': [[0,0,0], [0,0,0], [0,0,0]]
    };

    function initDeep() {
        createGrid('deepInput', SIZE_IN, true, 'cell', toggleDeepInput);
        // Interactive Kernels
        createGrid('visFilter1', SIZE_K, true, 'cell', (r, c) => toggleFilter(1, r, c)); 
        createGrid('visFilter2', SIZE_K, true, 'cell', (r, c) => toggleFilter(2, r, c));
        
        const combinedDiv = document.getElementById('visCombined');
        combinedDiv.innerHTML = '';
        for(let i=0; i<9; i++) {
            let d = document.createElement('div');
            d.style.width = '15px'; d.style.height = '15px'; d.style.background='#ccc'; d.style.borderRadius='2px';
            combinedDiv.appendChild(d);
        }

        createGrid('map1', SIZE_OUT, false, 'cell out-cell');
        createGrid('map2', SIZE_OUT, false, 'cell out-cell');
        createGrid('mapMix', SIZE_OUT, false, 'cell out-cell');
        
        loadInputPreset('cross');
        loadFilterPreset(1, 'vert');
        loadFilterPreset(2, 'horz');
    }

    function createMatrixDeep(size) { return Array(size).fill().map(() => Array(size).fill(0)); }

    function createGrid(id, size, interactive, cellClass, clickHandler) {
        const div = document.getElementById(id);
        div.innerHTML = '';
        div.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        for(let r=0; r<size; r++) {
            for(let c=0; c<size; c++) {
                let el = document.createElement('div');
                el.className = cellClass;
                el.dataset.r = r;
                el.dataset.c = c;
                if(interactive && clickHandler) {
                    el.style.cursor = 'pointer';
                    el.onclick = () => clickHandler(r, c, el);
                }
                div.appendChild(el);
            }
        }
    }

    function toggleDeepInput(r, c, el) {
        deepInput[r][c] = deepInput[r][c] === 1 ? 0 : 1;
        updateGridDisplay('deepInput', deepInput);
        clearResults();
    }

    // Restore Kernel Editing
    function toggleFilter(filterNum, r, c) {
        let k = (filterNum === 1) ? kernel1 : kernel2;
        k[r][c] = k[r][c] === 1 ? 0 : 1;
        updateKernelDisplay(filterNum);
        updateCombinedView();
        clearResults();
    }

    function clearDeepInput() {
        deepInput = createMatrixDeep(SIZE_IN);
        updateGridDisplay('deepInput', deepInput);
        clearResults();
    }

    function loadInputPreset(type) {
        deepInput = createMatrixDeep(SIZE_IN);
        if(type === 'cross') { for(let i=0; i<5; i++) { deepInput[2][i] = 1; deepInput[i][2] = 1; } } 
        else if (type === 'K_letter') {
            for(let i=0; i<5; i++) deepInput[i][1] = 1;
            deepInput[1][2] = 1; deepInput[0][3] = 1; deepInput[3][2] = 1; deepInput[4][3] = 1;
        } else if(type === 'checker') {
            for(let i=0; i<5; i++) for(let j=0; j<5; j++) if((i+j)%2===0) deepInput[i][j] = 1;
        } else if(type === 'full_black') {
            for(let i=0; i<5; i++) for(let j=0; j<5; j++) deepInput[i][j] = 1;
        }
        updateGridDisplay('deepInput', deepInput);
        clearResults();
    }

    function loadFilterPreset(filterNum, type) {
        let data = JSON.parse(JSON.stringify(FILTERS[type] || FILTERS['custom']));
        if (filterNum === 1) kernel1 = data; else kernel2 = data;
        updateKernelDisplay(filterNum);
        updateCombinedView();
        clearResults();
    }

    function updateGridDisplay(id, matrix) {
        const div = document.getElementById(id);
        Array.from(div.children).forEach(cell => {
            let r = cell.dataset.r, c = cell.dataset.c;
            cell.classList.remove('active');
            if(matrix[r][c] === 1) cell.classList.add('active');
        });
    }

    function updateKernelDisplay(filterNum) {
        let k = (filterNum === 1) ? kernel1 : kernel2;
        let id = `visFilter${filterNum}`;
        const div = document.getElementById(id);
        Array.from(div.children).forEach(cell => {
            let r = cell.dataset.r, c = cell.dataset.c;
            cell.className = 'cell'; 
            if(k[r][c] === 1) cell.classList.add('k-pos');
        });
    }

    function updateCombinedView() {
        const div = document.getElementById('visCombined');
        Array.from(div.children).forEach((cell, i) => {
            let r = Math.floor(i/3), c = i%3;
            cell.style.background = '#e5e7eb';
            let v1 = kernel1[r][c];
            let v2 = kernel2[r][c];
            if (v1 && v2) cell.style.background = '#8b5cf6';
            else if (v1) cell.style.background = '#3b82f6';
            else if (v2) cell.style.background = '#ef4444';
        });
    }

    function clearResults() {
        ['map1', 'map2', 'mapMix'].forEach(id => {
            Array.from(document.getElementById(id).children).forEach(c => {
                c.style.backgroundColor = '#f3f4f6'; c.textContent = '';
            });
        });
        document.getElementById('statusMsg').textContent = "";
        document.getElementById('debugInfo').textContent = "";
        // Remove input highlights
        Array.from(document.getElementById('deepInput').children).forEach(c => c.classList.remove('best-match-border'));
        hasRun = false;
    }

    function runDeepCalc() {
        const btn = document.getElementById('btnRun');
        const mode = document.getElementById('calcMode').value;
        const actName = document.getElementById('deepActivation').value;

        btn.disabled = true;
        
        scores1 = convDeep(deepInput, kernel1, mode, actName);
        scores2 = convDeep(deepInput, kernel2, mode, actName);
        
        for(let r=0; r<SIZE_OUT; r++) {
            for(let c=0; c<SIZE_OUT; c++) {
                scoresMix[r][c] = scores1[r][c] + scores2[r][c];
            }
        }

        hasRun = true;
        updateViewMode();
        setTimeout(() => btn.disabled = false, 300);
    }

    function convDeep(input, kernel, mode, actName) {
        let result = createMatrixDeep(SIZE_OUT);
        let actFunc = Activations[actName];

        for(let r=0; r<SIZE_OUT; r++) {
            for(let c=0; c<SIZE_OUT; c++) {
                let sum = 0;
                
                if (mode === 'heuristic') {
                    for(let i=0; i<SIZE_K; i++) {
                        for(let j=0; j<SIZE_K; j++) {
                            let inVal = input[r+i][c+j];
                            let kVal = kernel[i][j];
                            if (inVal === 1 && kVal === 1) sum += 1;
                            else if (inVal === 1 && kVal === 0) sum -= 0.5;
                        }
                    }
                } else {
                    // MATH MODE: Convert 0 to -1 to prevent Black Square Match
                    // Input: 0 -> -1, 1 -> 1
                    // Kernel: 0 -> -1, 1 -> 1
                    for(let i=0; i<SIZE_K; i++) {
                        for(let j=0; j<SIZE_K; j++) {
                            let inVal = (input[r+i][c+j] === 1) ? 1 : -1;
                            let kVal = (kernel[i][j] === 1) ? 1 : -1;
                            sum += inVal * kVal;
                        }
                    }
                    // For perfect match of 9 pixels (3x3), sum is 9.
                    // For perfect inverse, sum is -9.
                    // Random noise ~ 0.
                    sum = actFunc(sum);
                }
                
                result[r][c] = sum;
            }
        }
        return result;
    }

    function updateViewMode() {
        if(!hasRun) return;

        const isHeatmap = document.getElementById('checkHeatmap').checked;
        const status = document.getElementById('statusMsg');
        const debug = document.getElementById('debugInfo');
        
        // Render Maps with Absolute Heatmap
        renderMapDeep('map1', scores1, isHeatmap);
        renderMapDeep('map2', scores2, isHeatmap);
        
        const divMix = document.getElementById('mapMix');
        let maxScore = -999;
        let bestR = -1, bestC = -1;

        for(let i=0; i<divMix.children.length; i++) {
            let r = Math.floor(i/SIZE_OUT), c = i%SIZE_OUT;
            let s = scoresMix[r][c];
            let cell = divMix.children[i];
            
            if(s > maxScore) { maxScore = s; bestR = r; bestC = c; }

            cell.className = 'cell out-cell';
            
            if(isHeatmap) {
                cell.style.backgroundColor = getHeatmapColor(s/2); // divide by 2 for mix (sum of 2 layers)
                cell.textContent = s.toFixed(1).replace('.0','');
                cell.style.color = Math.abs(s) > 3 ? 'white' : 'black';
            } else {
                // Binary
                cell.style.backgroundColor = (s > 3.0) ? '#8b5cf6' : '#f3f4f6';
                cell.style.color = (s > 3.0) ? 'white' : 'transparent';
                cell.textContent = "";
            }
        }
        
        // HIGHLIGHT BEST MATCH IN INPUT (GREEN BORDER)
        if(maxScore > 1.0 && bestR !== -1) {
            highlightDeepInput(bestR, bestC);
            status.textContent = `–ú–∞–∫—Å. —Å–∏–≥–Ω–∞–ª: ${maxScore.toFixed(1)}`;
            status.style.color = "#059669";
        } else {
            status.textContent = "–°–∏–≥–Ω–∞–ª —Å–ª–∞–±–∫–∏–π";
            status.style.color = "#dc2626";
        }

        if(isHeatmap) {
            debug.textContent = "–ö–ª—ñ–∫–∞–π—Ç–µ –Ω–∞ –≤—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è —ñ –Ω–∞ —Ñ—ñ–ª—å—Ç—Ä–∏ 1 —à–∞—Ä—É, —â–æ–± –∑–º—ñ–Ω–∏—Ç–∏";
        }
    }

    function renderMapDeep(id, data, isHeatmap) {
        const div = document.getElementById(id);
        for(let i=0; i<div.children.length; i++) {
            let r = Math.floor(i/SIZE_OUT), c = i%SIZE_OUT;
            let val = data[r][c];
            let cell = div.children[i];
            
            cell.className = 'cell out-cell';
            if(isHeatmap) {
                cell.style.backgroundColor = getHeatmapColor(val);
                cell.textContent = val.toFixed(1).replace('.0','');
                cell.style.color = Math.abs(val) > 2 ? 'white' : 'black';
            } else {
                cell.style.backgroundColor = (val > 2.0) ? '#3b82f6' : '#f3f4f6';
                cell.textContent = '';
            }
        }
    }

    function highlightDeepInput(startR, startC) {
        const div = document.getElementById('deepInput');
        // Clear old
        Array.from(div.children).forEach(c => c.classList.remove('best-match-border'));
        // Draw new (3x3 area)
        for(let i=0; i<SIZE_K; i++){
            for(let j=0; j<SIZE_K; j++){
                let idx = (startR+i)*SIZE_IN + (startC+j);
                if(div.children[idx]) div.children[idx].classList.add('best-match-border');
            }
        }
    }

    initScan();
    initDeep();
</script>

</body>
</html>
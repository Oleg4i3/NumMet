<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>–°–∏–º—É–ª—è—Ç–æ—Ä GNN (v8 - –†–µ–¥–∞–∫—Ç–æ—Ä)</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            text-align: center;
            color: #444;
        }
        #main-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 70vh;
            border: 1px solid #ccc;
            background: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border-radius: 8px;
        }
        #network {
            width: 60%;
            height: 100%;
            border-right: 2px solid #eee;
        }
        #explanation-container {
            width: 40%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #explanation-header {
            padding: 10px 20px;
            border-bottom: 2px solid #eee;
            background: #fdfdfd;
        }
        #explanation-log {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            background: #fafafa;
        }
        #controls {
            text-align: center;
            margin: 20px 0;
        }
        .controls-group {
            margin: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            display: inline-block;
            vertical-align: top; /* –î–ª—è —Ä—ñ–≤–Ω–æ–≥–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è */
        }
        button {
            background-color: #007aff;
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #c0c0c0;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        /* –°—Ç–∏–ª—å –¥–ª—è –ª–æ–≥—ñ–≤ */
        .node-calc-container {
            margin-bottom: 5px;
        }
        .node-calc {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            background: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            line-height: 1.4;
            transition: background-color 0.3s;
            margin: 0;
        }
        .node-calc-container > .node-calc {
             border-bottom-left-radius: 0;
             border-bottom-right-radius: 0;
        }
        .node-calc-container > ul.node-calc {
             border-top-left-radius: 0;
             border-top-right-radius: 0;
             padding-left: 30px;
        }
        .node-calc-container:hover .node-calc {
            background-color: #dbeaff;
        }
        .node-anchor {
             background: #fffbe6;
             border-left: 3px solid #f0ad4e;
        }
        /* –õ–µ–≥–µ–Ω–¥–∞ */
        #legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #888;
        }
        /* –°–ø–æ–π–ª–µ—Ä */
        details {
            width: 80%;
            margin: 20px auto;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        details summary {
            font-size: 1.2em;
            font-weight: 600;
            padding: 15px;
            cursor: pointer;
            background: #f9f9f9;
            border-radius: 8px 8px 0 0;
        }
        .details-content {
            padding: 20px;
            line-height: 1.6;
        }
        .details-content h3 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        .details-content code {
            background: #e0e0e0;
            padding: 2px 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body onload="init()">

    <h1>–ì—Ä–∞—Ñ–æ–≤—ñ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ</h1>
    
    <div id="controls">
        <div class="controls-group">
            <strong>–ï—Ç–∞–ø 0: –†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è (–∫–ª—ñ–∫–Ω—ñ—Ç—å –Ω–∞ –≤–µ—Ä—à–∏–Ω—É, —â–æ–± –∑–º—ñ–Ω–∏—Ç–∏ –∫–æ–ª—ñ—Ä)</strong>
            <div id="edit-controls" style="text-align: left; max-width: 200px; margin: 10px auto 0 auto;">
                <label><input type="radio" id="edit-none" name="editMode" value="none" checked> –í–∏–º–∫–Ω–µ–Ω–æ</label><br>
                <label><input type="radio" id="edit-apple" name="editMode" value="apple"> üçé –ó—Ä–æ–±–∏—Ç–∏ Apple</label><br>
                <label><input type="radio" id="edit-android" name="editMode" value="android"> ü§ñ –ó—Ä–æ–±–∏—Ç–∏ Android</label><br>
                <label><input type="radio" id="edit-unknown" name="editMode" value="unknown"> ‚ùî –ó—Ä–æ–±–∏—Ç–∏ ???</label>
            </div>
        </div>

        <div class="controls-group">
            <strong>–ï—Ç–∞–ø 1: –ì—Ä–∞—Ñ</strong>
            <button onclick="generateGraph()">1. –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –ù–æ–≤–∏–π –ì—Ä–∞—Ñ</button>
        </div>
        <div class="controls-group">
            <strong>–ï—Ç–∞–ø 2: –†–µ–∂–∏–º</strong>
            <button id="gcn-btn" onclick="setMode('gcn')" disabled>2. GCN (–Ω–µ–∑–≤–∞–∂–µ–Ω–∏–π)</button>
            <button id="gat-btn" onclick="setMode('gat')" disabled>3. GAT (–∑–≤–∞–∂–µ–Ω–∏–π)</button>
        </div>
        <div class="controls-group">
            <strong>–ï—Ç–∞–ø 3: –ö–µ—Ä—É–≤–∞–Ω–Ω—è</strong>
            <button id="reset-btn" class="secondary" onclick="resetToStart()" disabled>‚ùÆ‚ùÆ –ù–∞ –ü–æ—á–∞—Ç–æ–∫</button>
            <button id="back-btn" class="secondary" onclick="runStepBack()" disabled>‚ùÆ –ù–∞–∑–∞–¥</button>
            <button id="forward-btn" onclick="runStepForward()" disabled>–í–ø–µ—Ä–µ–¥ ‚ùØ</button>
            <button id="end-btn" onclick="runToEnd()" disabled>–î–æ –ö—ñ–Ω—Ü—è ‚ùØ‚ùØ</button>
        </div>
    </div>

    <div id="main-container">
        <div id="network"></div>
        <div id="explanation-container">
            <div id="explanation-header">
                <h2>–ü–æ–∫—Ä–æ–∫–æ–≤—ñ –ü–æ—è—Å–Ω–µ–Ω–Ω—è</h2>
                <div id="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #dc3545;"></div>
                        <span>–§–∞–Ω Apple (–Ø–∫—ñ—Ä)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #28a745;"></div>
                        <span>–§–∞–Ω Android (–Ø–∫—ñ—Ä)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #adb5bd;"></div>
                        <span>–ù–µ –≤–∏–∑–Ω–∞—á–∏–≤—Å—è (?)</span>
                    </div>
                </div>
            </div>
            <div id="explanation-log">
                <p>–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ!</p>
                <p><strong>–ú–µ—Ç–∞:</strong> "–ü–æ—Ñ–∞—Ä–±—É–≤–∞—Ç–∏" —Å—ñ—Ä—ñ –≤—É–∑–ª–∏ (???) —É –∫–æ–ª—ñ—Ä —ó—Ö–Ω—ñ—Ö —Å—É—Å—ñ–¥—ñ–≤.</p>
                <p><strong>–†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è:</strong> –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å <strong>"–ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –ì—Ä–∞—Ñ"</strong>, –ø–æ—Ç—ñ–º (–¥–æ –∑–∞–ø—É—Å–∫—É —Å–∏–º—É–ª—è—Ü—ñ—ó) –æ–±–µ—Ä—ñ—Ç—å —Ä–µ–∂–∏–º –≤ "–ï—Ç–∞–ø—ñ 0" —ñ –∫–ª—ñ–∫–∞–π—Ç–µ –Ω–∞ –≤—É–∑–ª–∏, —â–æ–± –∑–º—ñ–Ω–∏—Ç–∏ —ó—Ö.</p>
            </div>
        </div>
    </div>

    <details>
        <summary>üß† –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –¥–æ–≤—ñ–¥–∫–∞ (–Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å, —â–æ–± —Ä–æ–∑–∫—Ä–∏—Ç–∏)</summary>
        <div class="details-content">
            <h3>–©–æ —Ç–∞–∫–µ –ì—Ä–∞—Ñ–æ–≤—ñ –ù–µ–π—Ä–æ–Ω–Ω—ñ –ú–µ—Ä–µ–∂—ñ (GNN)?</h3>
            <p>–¶–µ –∫–ª–∞—Å –Ω–µ–π—Ä–æ–Ω–Ω–∏—Ö –º–µ—Ä–µ–∂, –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∏—Ö –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ –¥–∞–Ω–∏–º–∏, —â–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ñ —É –≤–∏–≥–ª—è–¥—ñ –≥—Ä–∞—Ñ—ñ–≤ (–≤—É–∑–ª–∏ —Ç–∞ –∑–≤'—è–∑–∫–∏). –ó–≤–∏—á–∞–π–Ω—ñ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ (—è–∫ –¥–ª—è –∫–∞—Ä—Ç–∏–Ω–æ–∫ –∞–±–æ —Ç–µ–∫—Å—Ç—É) –æ—á—ñ–∫—É—é—Ç—å –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–∏—Ö –¥–∞–Ω–∏—Ö (–ø—ñ–∫—Å–µ–ª—ñ –ø–æ —Å—ñ—Ç—Ü—ñ, —Å–ª–æ–≤–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É). –ì—Ä–∞—Ñ–∏ –∂ <strong>–Ω–µ–≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω—ñ</strong> ‚Äî –≤—É–∑–æ–ª "–ê" –º–æ–∂–µ –±—É—Ç–∏ "–≤–∏—â–µ" –∞–±–æ "–Ω–∏–∂—á–µ" –≤—É–∑–ª–∞ "–ë", —ñ —Ü–µ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–º—ñ–Ω—é—î.</p>
            <p>–ö–ª—é—á–æ–≤–∞ —ñ–¥–µ—è GNN ‚Äî <strong>"–æ–±–º—ñ–Ω –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏" (Message Passing)</strong>. –ö–æ–∂–µ–Ω –≤—É–∑–æ–ª –æ–Ω–æ–≤–ª—é—î —Å–≤—ñ–π —Å—Ç–∞–Ω (—Å–≤–æ—ó "–æ–∑–Ω–∞–∫–∏", —É –Ω–∞—Å —Ü–µ <code>[Apple, Android]</code>), –¥–∏–≤–ª—è—á–∏—Å—å –Ω–∞ –æ–∑–Ω–∞–∫–∏ —Å–≤–æ—ó—Ö –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—ñ—Ö —Å—É—Å—ñ–¥—ñ–≤.</p>
            
            <h3>GCN vs GAT: –£ —á–æ–º—É —Ä—ñ–∑–Ω–∏—Ü—è?</h3>
            <ul>
                <li><strong>GCN (Graph Convolutional Network)</strong>: –¶–µ <em>"–¥–µ–º–æ–∫—Ä–∞—Ç—ñ—è"</em>. –í—É–∑–æ–ª –¥–∏–≤–∏—Ç—å—Å—è –Ω–∞ –≤—Å—ñ—Ö —Å—É—Å—ñ–¥—ñ–≤ —ñ –ø—Ä–æ—Å—Ç–æ <strong>—É—Å–µ—Ä–µ–¥–Ω—é—î</strong> —ó—Ö–Ω—ñ –æ–∑–Ω–∞–∫–∏. –ö–æ–∂–µ–Ω —Å—É—Å—ñ–¥ –º–∞—î –æ–¥–Ω–∞–∫–æ–≤–∏–π –≤–ø–ª–∏–≤. –¶–µ —à–≤–∏–¥–∫–æ —Ç–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ, –∞–ª–µ –Ω–µ –¥—É–∂–µ –≥–Ω—É—á–∫–æ.</li>
                <li><strong>GAT (Graph Attention Network)</strong>: –¶–µ <em>"–∑–≤–∞–∂–µ–Ω–∞ –¥–µ–º–æ–∫—Ä–∞—Ç—ñ—è"</em>. –í—É–∑–æ–ª –Ω–µ –ø—Ä–æ—Å—Ç–æ —É—Å–µ—Ä–µ–¥–Ω—é—î, –∞ –Ω–∞–¥–∞—î <strong>—Ä—ñ–∑–Ω–∏–π "–∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç —É–≤–∞–≥–∏" (attention)</strong> –∫–æ–∂–Ω–æ–º—É —Å—É—Å—ñ–¥—É. –Ø–∫—â–æ —Å—É—Å—ñ–¥ "–≤–∞–∂–ª–∏–≤—ñ—à–∏–π" (—É –Ω–∞—à–æ–º—É –ø—Ä–∏–∫–ª–∞–¥—ñ ‚Äî –∑–≤'—è–∑–æ–∫ "–±–ª–∏–∂—á–∏–π"), –π–æ–≥–æ –æ–∑–Ω–∞–∫–∏ –æ—Ç—Ä–∏–º–∞—é—Ç—å –±—ñ–ª—å—à—É –≤–∞–≥—É.</li>
            </ul>

            <h3>–©–æ —Ç–∞–∫–µ —à–∞—Ä–∏ —ñ –¥–ª—è —á–æ–≥–æ –≤–æ–Ω–∏?</h3>
            <p>–û–¥–∏–Ω "–∫—Ä–æ–∫" —É –Ω–∞—à–æ–º—É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∏–π –æ–¥–Ω–æ–º—É <strong>—à–∞—Ä—É (Layer)</strong> GNN. –®–∞—Ä ‚Äî —Ü–µ –æ–¥–∏–Ω –ø–æ–≤–Ω–∏–π —Ä–∞—É–Ω–¥ "–æ–±–º—ñ–Ω—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏", –¥–µ –∫–æ–∂–µ–Ω –≤—É–∑–æ–ª –æ–ø–∏—Ç–∞–≤ —Å–≤–æ—ó—Ö –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—ñ—Ö —Å—É—Å—ñ–¥—ñ–≤ —ñ –æ–Ω–æ–≤–∏–≤ —Å–≤–æ—ó –æ–∑–Ω–∞–∫–∏.</p>
            <p>–î–ª—è —á–æ–≥–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∫—ñ–ª—å–∫–∞ —à–∞—Ä—ñ–≤?
                <ul>
                    <li><strong>–†–æ–∑—à–∏—Ä–µ–Ω–Ω—è "–ø–æ–ª—è —Å–ø—Ä–∏–π–Ω—è—Ç—Ç—è":</strong> –ü—ñ—Å–ª—è 1-–≥–æ —à–∞—Ä—É –≤—É–∑–æ–ª "–∑–Ω–∞—î" –ª–∏—à–µ –ø—Ä–æ —Å–≤–æ—ó—Ö —Å—É—Å—ñ–¥—ñ–≤ (–¥—Ä—É–∑—ñ–≤). –ü—ñ—Å–ª—è 2-–≥–æ —à–∞—Ä—É –≤—ñ–Ω –æ–ø–æ—Å–µ—Ä–µ–¥–∫–æ–≤–∞–Ω–æ "–¥—ñ–∑–Ω–∞—î—Ç—å—Å—è" —ñ –ø—Ä–æ —Å—É—Å—ñ–¥—ñ–≤ —Å–≤–æ—ó—Ö —Å—É—Å—ñ–¥—ñ–≤ (–¥—Ä—É–∑—ñ–≤ –º–æ—ó—Ö –¥—Ä—É–∑—ñ–≤). –ö–æ–∂–µ–Ω –Ω–∞—Å—Ç—É–ø–Ω–∏–π —à–∞—Ä –¥–æ–∑–≤–æ–ª—è—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø–æ—à–∏—Ä—é–≤–∞—Ç–∏—Å—è (diffuse) –¥–∞–ª—ñ –ø–æ –≥—Ä–∞—Ñ—É.</li>
                    <li><strong>–°–∫–ª–∞–¥–Ω—ñ—à—ñ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ:</strong> –¢–∞–∫ —Å–∞–º–æ, —è–∫ —É –∑–≤–∏—á–∞–π–Ω–∏—Ö –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞—Ö, –∫—ñ–ª—å–∫–∞ —à–∞—Ä—ñ–≤ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –º–æ–¥–µ–ª—ñ –≤–∏–≤—á–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ—à—ñ, –Ω–µ–ª—ñ–Ω—ñ–π–Ω—ñ –ø–∞—Ç–µ—Ä–Ω–∏ —É –¥–∞–Ω–∏—Ö.</li>
                </ul>
            <p>–û–¥–Ω–∞–∫, –∑–∞–Ω–∞–¥—Ç–æ –±–∞–≥–∞—Ç–æ —à–∞—Ä—ñ–≤ (–Ω–∞–ø—Ä., 10-20) —É GNN –º–æ–∂—É—Ç—å –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –ø—Ä–æ–±–ª–µ–º–∏ <strong>"–Ω–∞–¥–º—ñ—Ä–Ω–æ–≥–æ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è" (Oversmoothing)</strong>. –¶–µ —Å–∏—Ç—É–∞—Ü—ñ—è, –∫–æ–ª–∏ –≤—É–∑–ª–∏ —Ç–∞–∫ –±–∞–≥–∞—Ç–æ —Ä–∞–∑—ñ–≤ —É—Å–µ—Ä–µ–¥–Ω—é—é—Ç—å —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –∑ —É—Å—å–æ–≥–æ –≥—Ä–∞—Ñ—É, —â–æ —ó—Ö–Ω—ñ –æ–∑–Ω–∞–∫–∏ —Å—Ç–∞—é—Ç—å –ø—Ä–∞–∫—Ç–∏—á–Ω–æ –æ–¥–Ω–∞–∫–æ–≤–∏–º–∏ (–≤—Å—ñ —Å—Ç–∞—é—Ç—å "—Å—ñ—Ä–∏–º–∏"), —ñ –º–æ–¥–µ–ª—å –≤—Ç—Ä–∞—á–∞—î –∑–¥–∞—Ç–Ω—ñ—Å—Ç—å —ó—Ö —Ä–æ–∑—Ä—ñ–∑–Ω—è—Ç–∏.</p>

            <h3>–Ø–∫ –ø—Ä–∞—Ü—é—î –Ω–∞—à —Å–∏–º—É–ª—è—Ç–æ—Ä (—Å–ø—Ä–æ—â–µ–Ω–Ω—è)</h3>
            <p>–ù–∞—à —Å–∏–º—É–ª—è—Ç–æ—Ä —Ä–µ–∞–ª—ñ–∑—É—î –æ–¥–∏–Ω "—à–∞—Ä" GNN. –ö–æ–∂–µ–Ω "–∫—Ä–æ–∫" ‚Äî —Ü–µ –æ–¥–∏–Ω –ø—Ä–æ—Ö—ñ–¥ —Ü—å–æ–≥–æ —à–∞—Ä—É.</p>
            <p><strong>–ê–ª–≥–æ—Ä–∏—Ç–º (Message Passing):</strong></p>
            <ol>
                <li><strong>–ê–≥—Ä–µ–≥–∞—Ü—ñ—è (Aggregation):</strong> –ö–æ–∂–µ–Ω "—Å—ñ—Ä–∏–π" –≤—É–∑–æ–ª –∑–±–∏—Ä–∞—î –æ–∑–Ω–∞–∫–∏ <code>[A, B]</code> –≤—ñ–¥ —É—Å—ñ—Ö —Å–≤–æ—ó—Ö —Å—É—Å—ñ–¥—ñ–≤.
                    <ul>
                        <li><strong>GCN:</strong> –ü—Ä–æ—Å—Ç–æ —É—Å–µ—Ä–µ–¥–Ω—é—î —ó—Ö (–Ω–∞–ø—Ä., <code>(–°—É—Å—ñ–¥1 + –°—É—Å—ñ–¥2) / 2</code>).</li>
                        <li><strong>GAT:</strong> –†–æ–±–∏—Ç—å –∑–≤–∞–∂–µ–Ω—É —Å—É–º—É (–Ω–∞–ø—Ä., <code>(–°—É—Å—ñ–¥1 * 0.9) + (–°—É—Å—ñ–¥2 * 0.1)</code>), –¥–µ –≤–∞–≥–∏ ‚Äî —Ü–µ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ "–±–ª–∏–∑—å–∫—ñ—Å—Ç—å" —Ä–µ–±—Ä–∞.</li>
                    </ul>
                </li>
                <li><strong>–û–Ω–æ–≤–ª–µ–Ω–Ω—è (Update):</strong> –í—É–∑–æ–ª "–∑–º—ñ—à—É—î" —Å–≤–æ—ó –ø–æ—Ç–æ—á–Ω—ñ –æ–∑–Ω–∞–∫–∏ –∑ –∞–≥—Ä–µ–≥–æ–≤–∞–Ω–∏–º–∏ –æ–∑–Ω–∞–∫–∞–º–∏ —Å—É—Å—ñ–¥—ñ–≤. –£ –Ω–∞—Å —Ü–µ –ø—Ä–æ—Å—Ç–∞ —Ñ–æ—Ä–º—É–ª–∞: <code>–ù–æ–≤—ñ = (–°–≤–æ—ó * 0.5) + (–ê–≥—Ä–µ–≥–æ–≤–∞–Ω—ñ * 0.5)</code>.</li>
                <li><strong>–ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è (Activation):</strong> –ú–∏ –¥—ñ–ª–∏–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–∞–∫, —â–æ–± —Å—É–º–∞ –æ–∑–Ω–∞–∫ –∑–Ω–æ–≤—É –¥–æ—Ä—ñ–≤–Ω—é–≤–∞–ª–∞ 1.0 (—Å–ø—Ä–æ—â–µ–Ω–∏–π SoftMax).</li>
            </ol>
            
            <p><strong>–£ —á–æ–º—É —Å–ø—Ä–æ—â–µ–Ω–Ω—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–æ –∑—ñ —Å–ø—Ä–∞–≤–∂–Ω—å–æ—é GNN?</strong></p>
            <ul>
                <li><strong>–í–∞–≥–∏ (Weights):</strong> –£ —Å–ø—Ä–∞–≤–∂–Ω—ñ–π GNN –Ω–∞ –µ—Ç–∞–ø—ñ "–û–Ω–æ–≤–ª–µ–Ω–Ω—è" –æ–∑–Ω–∞–∫–∏ (—Å–≤–æ—ó —Ç–∞ —Å—É—Å—ñ–¥—Å—å–∫—ñ) –º–Ω–æ–∂–∞—Ç—å—Å—è –Ω–∞ –º–∞—Ç—Ä–∏—Ü—ñ –≤–∞–≥ (<code>W_self</code>, <code>W_neigh</code>), —è–∫—ñ <strong>–Ω–∞–≤—á–∞—é—Ç—å—Å—è</strong> –ø—ñ–¥ —á–∞—Å —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è. –£ –Ω–∞—Å —Ü–µ —Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏ (<code>0.5</code> —ñ <code>0.5</code>).</li>
                <li><strong>–§—É–Ω–∫—Ü—ñ—è –ê–∫—Ç–∏–≤–∞—Ü—ñ—ó:</strong> –ú–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø—Ä–æ—Å—Ç—É –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—é. –°–ø—Ä–∞–≤–∂–Ω—ñ –º–µ—Ä–µ–∂—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å –Ω–µ–ª—ñ–Ω—ñ–π–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, <code>ReLU</code>) –º—ñ–∂ —à–∞—Ä–∞–º–∏, —â–æ –¥–æ–∑–≤–æ–ª—è—î —ó–º –≤–∏–≤—á–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ—à—ñ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ.</li>
                <li><strong>Attention (–¥–ª—è GAT):</strong> –£ —Å–ø—Ä–∞–≤–∂–Ω—å–æ–º—É GAT –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ —É–≤–∞–≥–∏ —Ç–∞–∫–æ–∂ <strong>–Ω–∞–≤—á–∞—é—Ç—å—Å—è</strong> (–æ–±—á–∏—Å–ª—é—é—Ç—å—Å—è –æ–∫—Ä–µ–º–æ—é –º–∞–ª–µ–Ω—å–∫–æ—é –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–µ—é), –∞ –Ω–µ –±–µ—Ä—É—Ç—å—Å—è –∑ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ—ó –≤–∞–≥–∏ —Ä–µ–±—Ä–∞.</li>
            </ul>

            <h3>GNN —Ç–∞ —ñ–Ω—à—ñ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∏</h3>
            <ul>
                <li><strong>vs. CNN (–ó–≥–æ—Ä—Ç–∫–æ–≤—ñ –º–µ—Ä–µ–∂—ñ):</strong> CNN ‚Äî —Ü–µ <em>—Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫</em> GNN. –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è ‚Äî —Ü–µ –≥—Ä–∞—Ñ —É –≤–∏–≥–ª—è–¥—ñ —ñ–¥–µ–∞–ª—å–Ω–æ—ó 2D-—Å—ñ—Ç–∫–∏, –¥–µ "—Å—É—Å—ñ–¥–∏" –ø—ñ–∫—Å–µ–ª—è ‚Äî —Ü–µ 8 –ø—ñ–∫—Å–µ–ª—ñ–≤ –Ω–∞–≤–∫–æ–ª–æ –Ω—å–æ–≥–æ. GNN —É–∑–∞–≥–∞–ª—å–Ω—é—î —Ü—é —ñ–¥–µ—é –Ω–∞ –±—É–¥—å-—è–∫—ñ –Ω–µ—Ä–µ–≥—É–ª—è—Ä–Ω—ñ –≥—Ä–∞—Ñ–∏.</li>
                <li><strong>vs. Transformers:</strong> Transformer (—è–∫ —É ChatGPT) ‚Äî —Ü–µ —Ç–µ–∂ <em>—Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫</em> GNN. –¢–µ–∫—Å—Ç –º–æ–∂–Ω–∞ —É—è–≤–∏—Ç–∏ —è–∫ <em>"–ø–æ–≤–Ω—ñ—Å—Ç—é –∑–≤'—è–∑–∞–Ω–∏–π –≥—Ä–∞—Ñ"</em>, –¥–µ –∫–æ–∂–Ω–µ —Å–ª–æ–≤–æ "–¥–∏–≤–∏—Ç—å—Å—è" –Ω–∞ –∫–æ–∂–Ω–µ —ñ–Ω—à–µ —Å–ª–æ–≤–æ. –ú–µ—Ö–∞–Ω—ñ–∑–º "Attention" —É GAT –±—É–≤ –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ –Ω–∞—Ç—Ö–Ω–µ–Ω–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º–æ–º "Self-Attention" —É –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–∞—Ö.</li>
                <li><strong>vs. –î–∏—Ñ—É–∑—ñ–π–Ω—ñ –º–æ–¥–µ–ª—ñ:</strong> –¶–µ –º–æ–¥–µ–ª—ñ –¥–ª—è <em>–≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó</em> –¥–∞–Ω–∏—Ö (–Ω–∞–ø—Ä., Stable Diffusion). –í–æ–Ω–∏ –ø—Ä–∞—Ü—é—é—Ç—å –∑–∞ —ñ–Ω—à–∏–º –ø—Ä–∏–Ω—Ü–∏–ø–æ–º (–ø–æ—Å—Ç—É–ø–æ–≤–µ –¥–æ–¥–∞–≤–∞–Ω–Ω—è —Ç–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è —à—É–º—É). –á—Ö –º–æ–∂–Ω–∞ –ø–æ—î–¥–Ω—É–≤–∞—Ç–∏ –∑ GNN (–Ω–∞–ø—Ä., –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –Ω–æ–≤–∏—Ö –º–æ–ª–µ–∫—É–ª—è—Ä–Ω–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä), –∞–ª–µ —ó—Ö–Ω—ñ –∑–∞–≤–¥–∞–Ω–Ω—è —Ç–∞ –º–µ—Ö–∞–Ω—ñ–∫–∏ —Ä—ñ–∑–Ω—ñ.</li>
            </ul>

            <h3>üöÄ –î–µ —Ü–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è? (–ü—Ä–∏–∫–ª–∞–¥–∏)</h3>
            <ul>
                <li><strong>–°–æ—Ü—ñ–∞–ª—å–Ω—ñ –º–µ—Ä–µ–∂—ñ:</strong> –ü–æ—à—É–∫ "–±–æ—Ç—ñ–≤", –≤–∏—è–≤–ª–µ–Ω–Ω—è —Å–ø—ñ–ª—å–Ω–æ—Ç, —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –¥—Ä—É–∑—ñ–≤.</li>
                <li><strong>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π–Ω—ñ —Å–∏—Å—Ç–µ–º–∏:</strong> Pinterest, Uber Eats (—Ä–µ–∫–æ–º–µ–Ω–¥—É–≤–∞—Ç–∏ —Ç–æ–≤–∞—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≥—Ä–∞—Ñ—É "–∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ-—Ç–æ–≤–∞—Ä–∏").</li>
                <li><strong>–•—ñ–º—ñ—è —Ç–∞ –§–∞—Ä–º–∞—Ü–µ–≤—Ç–∏–∫–∞:</strong> –ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π –º–æ–ª–µ–∫—É–ª–∏ (–≥—Ä–∞—Ñ –∞—Ç–æ–º—ñ–≤ —Ç–∞ –∑–≤'—è–∑–∫—ñ–≤), –ø–æ—à—É–∫ –Ω–æ–≤–∏—Ö –ª—ñ–∫—ñ–≤.</li>
                <li><strong>–ö–∞—Ä—Ç–æ–≥—Ä–∞—Ñ—ñ—è —Ç–∞ –õ–æ–≥—ñ—Å—Ç–∏–∫–∞:</strong> –ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –∑–∞—Ç–æ—Ä—ñ–≤ —É –º—ñ—Å—Ç—ñ (–≥—Ä–∞—Ñ –¥–æ—Ä—ñ–≥ —Ç–∞ –ø–µ—Ä–µ—Ö—Ä–µ—Å—Ç—å).</li>
            </ul>
        </div>
    </details>

    <script type="text/javascript">
        let network = null;
        let nodes = new vis.DataSet();
        let edges = new vis.DataSet();

        let stateHistory = [];
        let currentStep = 0;
        let currentMode = null;
        let isProcessing = false;
        let processingTimeout = null;

        const appleColor = '#dc3545';
        const androidColor = '#28a745';
        const convergenceEpsilon = 0.001;
        const maxSteps = 20;
        const animationDelay = 500; // –º—Å

        // ### 1. –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø –¢–ê –ì–ï–ù–ï–†–ê–¶–Ü–Ø –ì–†–ê–§–£ ###

        function init() {
            //
        }

        function generateGraph() {
            stopProcessing();
            const N = 15;
            const M = 2;
            
            const [nodesArray, edgesArray, initialFeatures] = barabasiAlbertGenerator(N, M);

            nodes.clear();
            edges.clear();
            nodes.add(nodesArray);
            edges.add(edgesArray);

            const container = document.getElementById('network');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'circle',
                    size: 30,
                    font: { 
                        size: 18, 
                        color: 'white', 
                        face: 'arial',
                        strokeWidth: 2, 
                        strokeColor: '#333333' 
                    },
                    borderWidth: 2
                },
                edges: {
                    width: 2,
                    smooth: false
                },
                physics: {
                    enabled: true,
                    solver: 'barnesHut',
                    barnesHut: {
                        gravitationalConstant: -10000,
                        springConstant: 0.04,
                        springLength: 150
                    }
                },
                interaction: {
                    dragNodes: true,
                    hover: true
                }
            };

            network = new vis.Network(container, data, options);
            
            network.on("stabilized", function (params) {
                network.setOptions({ physics: { enabled: false } });
            });
            
            // **FIX 2: –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –∫–ª—ñ–∫—ñ–≤**
            network.on("click", clickHandler);

            stateHistory = [initialFeatures];
            currentStep = 0;
            currentMode = null;
            
            document.getElementById('explanation-log').innerHTML = '<h2>üéâ –ù–æ–≤–∏–π –≥—Ä–∞—Ñ –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ!</h2><p>–¢–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–≥—É–≤–∞—Ç–∏ –≤—É–∑–ª–∏ (–ï—Ç–∞–ø 0) –∞–±–æ –æ–±—Ä–∞—Ç–∏ —Ä–µ–∂–∏–º —Å–∏–º—É–ª—è—Ü—ñ—ó (–ï—Ç–∞–ø 2).</p>';
            updateStepUI();
        }

        // ... (–§—É–Ω–∫—Ü—ñ—ó –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –≥—Ä–∞—Ñ—É barabasiAlbertGenerator, createNodeFeatures, createEdge, getPreferentialTargets –∑–∞–ª–∏—à–∞—é—Ç—å—Å—è –±–µ–∑ –∑–º—ñ–Ω) ...
        function barabasiAlbertGenerator(N, M) {
            const nodesArray = [];
            const edgesArray = [];
            const initialFeatures = {};
            const degree = Array(N).fill(0);
            let edgeIdCounter = 0;
            const M0 = M + 1; 
            for (let i = 0; i < M0; i++) {
                const [features, isLabeled] = createNodeFeatures(i);
                nodesArray.push({ id: i, label: i.toString(), features: features, color: getColor(features), isLabeled: isLabeled });
                initialFeatures[i] = features;
            }
            for (let i = 0; i < M0; i++) {
                for (let j = i + 1; j < M0; j++) {
                    const [edge] = createEdge(edgeIdCounter++, i, j);
                    edgesArray.push(edge);
                    degree[i]++;
                    degree[j]++;
                }
            }
            for (let i = M0; i < N; i++) {
                const [features, isLabeled] = createNodeFeatures(i);
                nodesArray.push({ id: i, label: i.toString(), features: features, color: getColor(features), isLabeled: isLabeled });
                initialFeatures[i] = features;
                const targets = getPreferentialTargets(degree, i, M);
                for (const target of targets) {
                    const [edge] = createEdge(edgeIdCounter++, i, target);
                    edgesArray.push(edge);
                    degree[i]++;
                    degree[target]++;
                }
            }
            return [nodesArray, edgesArray, initialFeatures];
        }
        function createNodeFeatures(id) {
            let features; let isLabeled; let r = Math.random();
            if (r < 0.2) { features = [1.0, 0.0]; isLabeled = true; }
            else if (r < 0.4) { features = [0.0, 1.0]; isLabeled = true; }
            else { features = [0.5, 0.5]; isLabeled = false; }
            return [features, isLabeled];
        }
        function createEdge(id, from, to) {
            const closeness = Math.random(); 
            const edge = { id: `e${id}`, from: from, to: to, weight: closeness, label: closeness.toFixed(2), color: { color: '#cccccc' }, font: { align: 'middle', size: 10, color: '#888' }, hidden: false };
            return [edge];
        }
        function getPreferentialTargets(degree, numExistingNodes, M) {
            let targets = new Set();
            let totalDegree = degree.slice(0, numExistingNodes).reduce((a, b) => a + b, 0);
            if (totalDegree === 0) { 
                while(targets.size < M && targets.size < numExistingNodes) targets.add(Math.floor(Math.random() * numExistingNodes));
                return Array.from(targets);
            }
            while(targets.size < M) {
                let rand = Math.random() * totalDegree; let sum = 0;
                for (let j = 0; j < numExistingNodes; j++) {
                    sum += degree[j];
                    if (rand <= sum) {
                        if (!targets.has(j)) { targets.add(j); break; } else { break; }
                    }
                }
            }
            return Array.from(targets);
        }
        
        // ### 2. –£–ü–†–ê–í–õ–Ü–ù–ù–Ø –°–¢–ê–ù–û–ú –¢–ê –ö–†–û–ö–ê–ú–ò ###
        
        // **FIX 2: –ù–æ–≤—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è**
        function clickHandler(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const editMode = document.querySelector('input[name="editMode"]:checked').value;
                if (editMode !== 'none') {
                    updateNodeManually(nodeId, editMode);
                }
            }
        }

        function updateNodeManually(nodeId, editMode) {
            if (currentStep !== 0) {
                alert("–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ –≤—É–∑–ª–∏ –º–æ–∂–Ω–∞ –ª–∏—à–µ –Ω–∞ –ö—Ä–æ—Ü—ñ 0. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å '‚ùÆ‚ùÆ –ù–∞ –ü–æ—á–∞—Ç–æ–∫'.");
                // –°–∫–∏–¥–∞—î–º–æ —Ä–∞–¥—ñ–æ–∫–Ω–æ–ø–∫—É
                document.getElementById('edit-none').checked = true;
                return;
            }

            let newFeatures, newIsLabeled;
            if (editMode === 'apple') {
                newFeatures = [1.0, 0.0];
                newIsLabeled = true;
            } else if (editMode === 'android') {
                newFeatures = [0.0, 1.0];
                newIsLabeled = true;
            } else if (editMode === 'unknown') {
                newFeatures = [0.5, 0.5];
                newIsLabeled = false;
            }

            // –û–Ω–æ–≤–ª—é—î–º–æ –≤—É–∑–æ–ª –≤ –¥–∞—Ç–∞—Å–µ—Ç—ñ vis.js
            nodes.update({ 
                id: nodeId, 
                features: newFeatures, 
                isLabeled: newIsLabeled, 
                color: getColor(newFeatures) 
            });
            
            // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω –≤ —ñ—Å—Ç–æ—Ä—ñ—ó
            if (stateHistory.length > 0) {
                stateHistory[0][nodeId] = newFeatures;
            }
        }

        function setMode(mode) {
            stopProcessing();
            currentMode = mode;
            resetToStart(true); // true = —Ç–∏—Ö–∏–π —Ä–µ–∂–∏–º
            currentMode = mode;
            
            const showEdgeLabels = (mode === 'gat');
            const edgesToUpdate = edges.get().map(edge => ({
                id: edge.id,
                label: showEdgeLabels ? edge.weight.toFixed(2) : undefined,
                font: { ...edge.font, color: showEdgeLabels ? '#888' : 'rgba(0,0,0,0)', strokeWidth: 0 }
            }));
            edges.update(edgesToUpdate);
            
            let logHtml = `<h2>–†–µ–∂–∏–º: ${mode.toUpperCase()}</h2>`;
            if (mode === 'gat') {
                logHtml += `<p><strong>–í–∞–≥–∞ —Ä–µ–±—Ä–∞ (–Ω–∞–ø—Ä., 0.82):</strong> –¶–µ "–±–ª–∏–∑—å–∫—ñ—Å—Ç—å" —Å—Ç–æ—Å—É–Ω–∫—ñ–≤. GAT –±—É–¥–µ <em>—Å–∏–ª—å–Ω—ñ—à–µ</em> –ø—Ä–∏—Å–ª—É—Ö–∞—Ç–∏—Å—è –¥–æ —Å—É—Å—ñ–¥—ñ–≤ –∑ –≤–∏—â–æ—é –≤–∞–≥–æ—é.</p>`;
            } else {
                logHtml += `<p><strong>–†–µ–∂–∏–º GCN:</strong> –í–∞–≥–∞ —Ä–µ–±–µ—Ä —ñ–≥–Ω–æ—Ä—É—î—Ç—å—Å—è.</p>`;
            }
            document.getElementById('explanation-log').innerHTML = logHtml;
            updateStepUI();
        }

        function resetToStart(silent = false) {
            stopProcessing();
            currentStep = 0;
            currentMode = null;
            const initialState = stateHistory[0];
            stateHistory = [initialState];
            
            applyStateToGraph(initialState);
            
            if (!silent) {
                document.getElementById('explanation-log').innerHTML = `<h2>‚Ü©Ô∏è –°–∫–∏–Ω—É—Ç–æ –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É.</h2><p>–¢–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–≥—É–≤–∞—Ç–∏ –≤—É–∑–ª–∏ –∞–±–æ –æ–±—Ä–∞—Ç–∏ —Ä–µ–∂–∏–º.</p>`;
            }
            updateStepUI();
        }
        
        function runStepForward() {
            stopProcessing();
            isProcessing = true;
            
            currentStep++;
            let logHtml = "";

            if (currentStep < stateHistory.length) {
                // –ü–æ–≤—Ç–æ—Ä –∫—Ä–æ–∫—É
                logHtml = `<div class="step"><h3>–ü–æ–≤—Ç–æ—Ä –∫—Ä–æ–∫—É ${currentStep} (${currentMode.toUpperCase()})</h3><p>–ü–µ—Ä–µ–≥–ª—è–¥ —Ä–∞–Ω—ñ—à–µ –æ–±—á–∏—Å–ª–µ–Ω–æ–≥–æ —Å—Ç–∞–Ω—É.</p></div>`;
                applyStateToGraph(stateHistory[currentStep]);
                document.getElementById('explanation-log').prepend(htmlToElement(logHtml));
                updateStepUI();
                isProcessing = false;
                return;
            }

            // –ù–æ–≤–∏–π –∫—Ä–æ–∫
            updateStepUI(true); // true = processing
            const currentState = stateHistory[currentStep - 1];
            const newFeaturesMap = { ...currentState };
            const allNodesData = nodes.get();
            
            const logContainer = document.createElement('div');
            logContainer.className = 'step';
            logContainer.innerHTML = `<h3>–ö—Ä–æ–∫ ${currentMode.toUpperCase()} ‚Ññ${currentStep}</h3>`;
            document.getElementById('explanation-log').prepend(logContainer);

            processNodeRecursive(0, allNodesData, currentState, newFeaturesMap, logContainer);
        }

        function processNodeRecursive(index, allNodesData, currentState, newFeaturesMap, logContainer) {
            if (!isProcessing) {
                revertAllHighlights();
                return;
            }

            if (index > 0) {
                const prevNodeData = allNodesData[index - 1];
                if (!prevNodeData.isLabeled) {
                     revertHighlights(prevNodeData.id);
                }
            }

            if (index === allNodesData.length) {
                revertAllHighlights();
                if (checkConvergence(currentState, newFeaturesMap)) {
                    logContainer.append(htmlToElement(`<p>‚úÖ <strong>–ó–±—ñ–∂–Ω—ñ—Å—Ç—å –¥–æ—Å—è–≥–Ω—É—Ç–∞!</strong> –û–∑–Ω–∞–∫–∏ –±—ñ–ª—å—à–µ –Ω–µ –∑–º—ñ–Ω—é—é—Ç—å—Å—è.</p>`));
                    currentStep--;
                } else {
                    stateHistory.push(newFeaturesMap);
                }
                applyStateToGraph(newFeaturesMap);
                isProcessing = false;
                updateStepUI();
                return;
            }

            const nodeData = allNodesData[index];
            const nodeId = nodeData.id;
            
            const [newFeatures, logEntry] = (currentMode === 'gcn')
                ? calculateSingleNodeGCN(nodeId, nodeData, currentState)
                : calculateSingleNodeGAT(nodeId, nodeData, currentState);
            
            newFeaturesMap[nodeId] = newFeatures;
            
            const logElement = htmlToElement(logEntry);
            logContainer.append(logElement);
            logContainer.scrollTop = logContainer.scrollHeight;

            if (nodeData.isLabeled) {
                processNodeRecursive(index + 1, allNodesData, currentState, newFeaturesMap, logContainer);
                return;
            }
            
            applyHighlights(nodeId, currentState);

            processingTimeout = setTimeout(() => {
                processNodeRecursive(index + 1, allNodesData, currentState, newFeaturesMap, logContainer);
            }, animationDelay);
        }
        
        function applyHighlights(nodeId, currentState) {
            nodes.update({ id: nodeId, borderWidth: 5, borderColor: '#007bff' });
            const connectedEdges = network.getConnectedEdges(nodeId);
            const edgesToUpdate = [];
            for (const edgeId of connectedEdges) {
                const edge = edges.get(edgeId);
                const neighborId = (edge.from == nodeId) ? edge.to : edge.from;
                const neighborColor = getColor(currentState[neighborId]);
                edgesToUpdate.push({ id: edgeId, color: neighborColor, width: 4 });
            }
            edges.update(edgesToUpdate);
        }

        function revertHighlights(nodeId) {
            nodes.update({ id: nodeId, borderWidth: 2, borderColor: null });
            const connectedEdges = network.getConnectedEdges(nodeId);
            const edgesToUpdate = [];
            for (const edgeId of connectedEdges) {
                edgesToUpdate.push({ id: edgeId, color: { color: '#cccccc' }, width: 2 });
            }
            edges.update(edgesToUpdate);
        }

        function revertAllHighlights() {
            const allNodes = nodes.get({ fields: ['id'] });
            nodes.update(allNodes.map(n => ({ id: n.id, borderWidth: 2, borderColor: null })));
            const allEdges = edges.get({ fields: ['id'] });
            edges.update(allEdges.map(e => ({ id: e.id, color: { color: '#cccccc' }, width: 2 })));
        }
        
        function stopProcessing() {
            isProcessing = false;
            if (processingTimeout) {
                clearTimeout(processingTimeout);
                processingTimeout = null;
            }
            revertAllHighlights();
        }

        function runStepBack() {
            stopProcessing();
            if (currentStep > 0) {
                currentStep--;
                const stateToApply = stateHistory[currentStep];
                applyStateToGraph(stateToApply);
                const logHtml = `<div class="step"><h3>‚ùÆ –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –∫—Ä–æ–∫—É ${currentStep}</h3><p>–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ —Å—Ç–∞–Ω –∑ –∫—Ä–æ–∫—É ${currentStep}.</p></div>`;
                document.getElementById('explanation-log').prepend(htmlToElement(logHtml));
                updateStepUI();
            }
        }

        function runToEnd() {
            stopProcessing();
            if (currentMode === null) return;

            updateStepUI(true); // –ë–ª–æ–∫—É—î–º–æ UI
            let logHtml = `<div class="step"><h3>‚ùØ‚ùØ –í–∏–∫–æ–Ω–∞–Ω–Ω—è –¥–æ –∫—ñ–Ω—Ü—è...</h3>`;
            let stepsTaken = 0;
            let converged = false;
            
            let currentState = stateHistory[currentStep]; 
            while (currentStep < stateHistory.length - 1) {
                currentStep++;
            }

            setTimeout(() => { // –î–∞—î–º–æ UI –æ–Ω–æ–≤–∏—Ç–∏—Å—è
                for (let i = 0; i < maxSteps; i++) {
                    currentStep++;
                    stepsTaken++;
                    
                    const [newState, stepLog] = (currentMode === 'gcn')
                        ? calculateGCNStateBatch(currentState)
                        : calculateGATStateBatch(currentState);

                    stateHistory.push(newState);

                    if (checkConvergence(currentState, newState)) {
                        converged = true;
                        currentState = newState;
                        break;
                    }
                    currentState = newState;
                }

                applyStateToGraph(currentState);
                
                if (converged) {
                    logHtml += `<p>‚úÖ <strong>–°–∏–º—É–ª—è—Ü—ñ—è –∑—ñ–π—à–ª–∞—Å—è</strong> –∑–∞ ${stepsTaken} –∫—Ä–æ–∫—ñ–≤ (–í—Å—å–æ–≥–æ –∫—Ä–æ–∫—ñ–≤: ${currentStep}).</p>`;
                } else {
                    logHtml += `<p>‚ö†Ô∏è <strong>–î–æ—Å—è–≥–Ω—É—Ç–æ –ª—ñ–º—ñ—Ç—É</strong> (${maxSteps} –∫—Ä–æ–∫—ñ–≤). –°–∏–º—É–ª—è—Ü—ñ—é –∑—É–ø–∏–Ω–µ–Ω–æ.</p>`;
                }
                logHtml += `</div>`;
                document.getElementById('explanation-log').prepend(htmlToElement(logHtml));
                
                updateStepUI();
            }, 50);
        }
        
        function updateStepUI(processing = false) {
            isProcessing = processing;
            const isStart = (currentStep === 0);
            const isModeSet = (currentMode !== null);
            const isGenerated = (stateHistory.length > 0);

            document.getElementById('gcn-btn').disabled = processing || !isGenerated || !isStart;
            document.getElementById('gat-btn').disabled = processing || !isGenerated || !isStart;
            document.getElementById('reset-btn').disabled = processing || !isGenerated || isStart;
            document.getElementById('back-btn').disabled = processing || !isGenerated || isStart;
            document.getElementById('forward-btn').disabled = processing || !isGenerated || !isModeSet;
            document.getElementById('end-btn').disabled = processing || !isGenerated || !isModeSet;
            
            // **FIX 2: –ö–µ—Ä—É–≤–∞–Ω–Ω—è —Ä–∞–¥—ñ–æ–∫–Ω–æ–ø–∫–∞–º–∏**
            const editRadios = document.querySelectorAll('input[name="editMode"]');
            const canEdit = !processing && isStart && isGenerated;
            editRadios.forEach(radio => radio.disabled = !canEdit);
            if (!canEdit && document.getElementById('edit-none')) {
                document.getElementById('edit-none').checked = true; // –°–∫–∏–¥–∞—î–º–æ –≤–∏–±—ñ—Ä
            }
            
            if (!processing && currentStep > 0 && stateHistory.length > 1) {
                const converged = checkConvergence(stateHistory[currentStep-1], stateHistory[currentStep]);
                if (converged) {
                    document.getElementById('forward-btn').disabled = true;
                    document.getElementById('end-btn').disabled = true;
                }
            }
        }

        function applyStateToGraph(featuresMap) {
            const nodesToUpdate = [];
            for (const nodeId in featuresMap) {
                nodesToUpdate.push({
                    id: parseInt(nodeId),
                    features: featuresMap[nodeId], 
                    color: getColor(featuresMap[nodeId])
                });
            }
            nodes.update(nodesToUpdate);
        }
        
        function checkConvergence(stateA, stateB) {
            for (const nodeId in stateA) {
                const fA = stateA[nodeId];
                const fB = stateB[nodeId];
                if (Math.abs(fA[0] - fB[0]) > convergenceEpsilon || Math.abs(fA[1] - fB[1]) > convergenceEpsilon) {
                    return false;
                }
            }
            return true;
        }

        // ### 3. –õ–û–ì–Ü–ö–ê GCN —Ç–∞ GAT ###
        
        // **FIX 1: –ù–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –ª–æ–≥—ñ–≤**
        function getFeatureStatus(features) {
            const apple = features[0];
            const android = features[1];
            const confidence = Math.abs(apple - android);

            if (confidence < 0.1) {
                return `<span style="color:#888; font-weight:bold;">???</span>`;
            }
            if (apple > android) {
                return `<span style="color:${appleColor}; font-weight:bold;">Apple</span>`;
            } else {
                return `<span style="color:${androidColor}; font-weight:bold;">Android</span>`;
            }
        }

        function calculateSingleNodeGCN(nodeId, nodeData, currentState) {
            if (nodeData.isLabeled) {
                const log = `<div class="node-calc-container"><p class="node-calc node-anchor"><strong>–í—É–∑–æ–ª ${nodeId} (–Ø–∫—ñ—Ä):</strong> –ù–µ –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è.</p></div>`;
                return [currentState[nodeId], log];
            }

            const currentFeatures = currentState[nodeId];
            const neighborIds = network.getConnectedNodes(nodeId);
            let aggregatedFeatures = [0.0, 0.0];
            
            let logEntry = `<div class="node-calc-container" data-node-id="${nodeId}">`;
            logEntry += `<p class="node-calc"><strong>–í—É–∑–æ–ª ${nodeId} (???):</strong></p>`;
            logEntry += `<ul class="node-calc">`;

            if (neighborIds.length > 0) {
                logEntry += `<li>–î–∏–≤–∏—Ç—å—Å—è –Ω–∞ ${neighborIds.length} —Å—É—Å—ñ–¥—ñ–≤:</li>`;
                // **FIX 1: –î–µ—Ç–∞–ª—å–Ω–∏–π –ª–æ–≥ —Å—É—Å—ñ–¥—ñ–≤**
                for (const neighborId of neighborIds) {
                    const neighborFeatures = currentState[neighborId];
                    aggregatedFeatures[0] += neighborFeatures[0];
                    aggregatedFeatures[1] += neighborFeatures[1];
                    logEntry += `<li style="padding-left:15px;">...–æ—Ç—Ä–∏–º—É—î –≤—ñ–¥ –í—É–∑–ª–∞ ${neighborId} (${getFeatureStatus(neighborFeatures)}): [${neighborFeatures[0].toFixed(2)}, ${neighborFeatures[1].toFixed(2)}]</li>`;
                }
                
                aggregatedFeatures[0] /= neighborIds.length;
                aggregatedFeatures[1] /= neighborIds.length;
                logEntry += `<li><strong>–ê–≥—Ä–µ–≥–∞—Ü—ñ—è: [`;
                logEntry += `<span style="color:${appleColor}; font-weight:bold;">${aggregatedFeatures[0].toFixed(2)}</span>, `;
                logEntry += `<span style="color:${androidColor}; font-weight:bold;">${aggregatedFeatures[1].toFixed(2)}</span>]</strong></li>`;
            } else {
                logEntry += `<li>...–Ω–µ–º–∞—î —Å—É—Å—ñ–¥—ñ–≤. –ê–≥—Ä–µ–≥–∞—Ü—ñ—è = [0, 0].</li>`;
            }

            const [newFeatures, updateLog] = updateAndNormalize(currentFeatures, aggregatedFeatures);
            logEntry += updateLog;
            logEntry += `</ul>`;
            logEntry += `</div>`;
            
            return [newFeatures, logEntry];
        }
        
        function calculateSingleNodeGAT(nodeId, nodeData, currentState) {
            if (nodeData.isLabeled) {
                const log = `<div class="node-calc-container"><p class="node-calc node-anchor"><strong>–í—É–∑–æ–ª ${nodeId} (–Ø–∫—ñ—Ä):</strong> –ù–µ –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è.</p></div>`;
                return [currentState[nodeId], log];
            }
            
            const allEdges = edges.get();
            const currentFeatures = currentState[nodeId];
            const neighborIds = network.getConnectedNodes(nodeId);
            
            let logEntry = `<div class="node-calc-container" data-node-id="${nodeId}">`;
            logEntry += `<p class="node-calc"><strong>–í—É–∑–æ–ª ${nodeId} (???):</strong></p>`;
            logEntry += `<ul class="node-calc">`;
            let aggregatedFeatures = [0.0, 0.0];

            if (neighborIds.length > 0) {
                let neighborData = [];
                let totalCloseness = 0;
                logEntry += `<li><strong>–§–∞–∑–∞ —É–≤–∞–≥–∏ (Attention):</strong></li>`;
                
                // **FIX 1: –ó–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ —ñ –ª–æ–≥—É—î–º–æ**
                for (const neighborId of neighborIds) {
                    const edge = allEdges.find(e => (e.from == nodeId && e.to == neighborId) || (e.from == neighborId && e.to == nodeId));
                    const closeness = edge.weight;
                    const neighborFeatures = currentState[neighborId];
                    neighborData.push({ id: neighborId, features: neighborFeatures, closeness: closeness });
                    totalCloseness += closeness;
                    logEntry += `<li style="padding-left:15px;">...–¥–æ —Å—É—Å—ñ–¥–∞ ${neighborId} (${getFeatureStatus(neighborFeatures)}) –±–ª–∏–∑—å–∫—ñ—Å—Ç—å = ${closeness.toFixed(2)}</li>`;
                }

                logEntry += `<li><strong>–§–∞–∑–∞ –∞–≥—Ä–µ–≥–∞—Ü—ñ—ó (–ó–≤–∞–∂–µ–Ω–∞ —Å—É–º–∞):</strong></li>`;
                for (const neighbor of neighborData) {
                    let attentionCoeff = (totalCloseness > 0) ? (neighbor.closeness / totalCloseness) : 0;
                    aggregatedFeatures[0] += neighbor.features[0] * attentionCoeff;
                    aggregatedFeatures[1] += neighbor.features[1] * attentionCoeff;
                }
                logEntry += `<li><strong>–ê–≥—Ä–µ–≥–∞—Ü—ñ—è: [`;
                logEntry += `<span style="color:${appleColor}; font-weight:bold;">${aggregatedFeatures[0].toFixed(2)}</span>, `;
                logEntry += `<span style="color:${androidColor}; font-weight:bold;">${aggregatedFeatures[1].toFixed(2)}</span>]</strong></li>`;
            } else {
                logEntry += `<li>...–Ω–µ–º–∞—î —Å—É—Å—ñ–¥—ñ–≤. –ê–≥—Ä–µ–≥–∞—Ü—ñ—è = [0, 0].</li>`;
            }

            const [newFeatures, updateLog] = updateAndNormalize(currentFeatures, aggregatedFeatures);
            logEntry += updateLog;
            logEntry += `</ul>`;
            logEntry += `</div>`;
            
            return [newFeatures, logEntry];
        }

        // --- –ë–ê–¢–ß-–§–£–ù–ö–¶–Ü–á (–¥–ª—è "–î–æ –ö—ñ–Ω—Ü—è") ---
        
        function calculateGCNStateBatch(currentState) {
            const newFeaturesMap = { ...currentState }; 
            const allNodesData = nodes.get(); 
            let fullLog = "";
            for (const nodeData of allNodesData) {
                const [newFeatures, logEntry] = calculateSingleNodeGCN(nodeData.id, nodeData, currentState);
                newFeaturesMap[nodeData.id] = newFeatures;
            }
            return [newFeaturesMap, fullLog];
        }
        
        function calculateGATStateBatch(currentState) {
            const newFeaturesMap = { ...currentState };
            const allNodesData = nodes.get();
            let fullLog = "";
            for (const nodeData of allNodesData) {
                const [newFeatures, logEntry] = calculateSingleNodeGAT(nodeData.id, nodeData, currentState);
                newFeaturesMap[nodeData.id] = newFeatures;
            }
            return [newFeaturesMap, fullLog];
        }


        // ### 4. –î–û–ü–û–ú–Ü–ñ–ù–Ü –§–£–ù–ö–¶–Ü–á ###

        function updateAndNormalize(currentFeatures, aggregatedFeatures) {
            const W_self = 0.5;
            const W_neigh = 0.5;
            
            let newApple = (currentFeatures[0] * W_self) + (aggregatedFeatures[0] * W_neigh);
            let newAndroid = (currentFeatures[1] * W_self) + (aggregatedFeatures[1] * W_neigh);

            let log = `<li class="node-calc"><strong>–ï—Ç–∞–ø –û–Ω–æ–≤–ª–µ–Ω–Ω—è:</strong></li>`;
            log += `<li class="node-calc">Apple = (–°–≤–æ—ó ${currentFeatures[0].toFixed(2)}*${W_self}) + (–°—É—Å—ñ–¥—Å—å–∫—ñ ${aggregatedFeatures[0].toFixed(2)}*${W_neigh}) = ${newApple.toFixed(2)}</li>`;
            log += `<li class="node-calc">Android = (–°–≤–æ—ó ${currentFeatures[1].toFixed(2)}*${W_self}) + (–°—É—Å—ñ–¥—Å—å–∫—ñ ${aggregatedFeatures[1].toFixed(2)}*${W_neigh}) = ${newAndroid.toFixed(2)}</li>`;

            // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è
            const total = newApple + newAndroid;
            if (total > 0) {
                newApple /= total;
                newAndroid /= total;
            } else {
                newApple = 0.5; newAndroid = 0.5;
            }

            const finalFeatures = [newApple, newAndroid];
            log += `<li class="node-calc"><strong>–ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è (—Ä–µ–∑—É–ª—å—Ç–∞—Ç): [`;
            log += `<span style="color:${appleColor}; font-weight:bold;">${finalFeatures[0].toFixed(2)}</span>, `;
            log += `<span style="color:${androidColor}; font-weight:bold;">${finalFeatures[1].toFixed(2)}</span>]</strong></li>`;
            
            return [finalFeatures, log];
        }

        function htmlToElement(html) {
            const template = document.createElement('template');
            html = html.trim();
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function getColor(features) {
            const apple = features[0];
            const android = features[1];
            const confidence = Math.abs(apple - android);

            if (confidence < 0.1) {
                return '#adb5bd'; // –°—ñ—Ä–∏–π
            }

            const hue = (apple > android) ? 0 : 120; // 0=–ß–µ—Ä–≤–æ–Ω–∏–π, 120=–ó–µ–ª–µ–Ω–∏–π
            const saturation = 10 + (confidence * 80);
            const lightness = 50;
            
            if (hue === 0) return `hsl(0, ${saturation}%, 55%)`; 
            if (hue === 120) return `hsl(120, ${saturation}%, 45%)`;
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
    </script>

</body>
</html>
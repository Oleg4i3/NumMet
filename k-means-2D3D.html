<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û–±'—î–¥–Ω–∞–Ω–∏–π –°–∏–º—É–ª—è—Ç–æ—Ä K-means (2D & 3D)</title>
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
      }
    </script>

    <style>
        /* --- –ó–ê–ì–ê–õ–¨–ù–Ü –°–¢–ò–õ–Ü --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* –°–∫—Ä–æ–ª –±—É–¥–µ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –≤–∫–ª–∞–¥–æ–∫ */
        }

        /* --- –°–¢–ò–õ–Ü –í–ê–ù–ï–õ–Ü –í–ö–õ–ê–î–û–ö (TABS) --- */
        .tabs-nav {
            display: flex;
            background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
            padding: 0 20px;
        }
        .tab-button {
            padding: 15px 25px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            background: transparent;
            cursor: pointer;
            color: #555;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab-button:hover {
            background-color: #f8f9fa;
            color: #007bff;
        }
        .tab-button.active {
            color: #007bff;
            border-bottom: 3px solid #007bff;
        }
        
        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –≤–º—ñ—Å—Ç—É –≤–∫–ª–∞–¥–æ–∫ */
        .tab-content {
            display: none; /* –ü—Ä–∏—Ö–æ–≤–∞–Ω–æ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º */
            flex-grow: 1;
            overflow: auto; /* –°–∫—Ä–æ–ª –¥–ª—è –∫–æ–Ω—Ç–µ–Ω—Ç—É */
            position: relative;
            height: 100%;
        }
        .tab-content.active {
            display: flex; /* 3D –≤–∏–º–∞–≥–∞—î flex, 2D –ø—ñ–¥–ª–∞—à—Ç—É—î–º–æ */
            flex-direction: column;
        }

        /* --- –°–¢–ò–õ–Ü –î–õ–Ø 2D –°–ò–ú–£–õ–Ø–¢–û–†–ê --- */
        #tab-2d {
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            display: none; /* –ü–µ—Ä–µ–≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –∫–ª–∞—Å–æ–º .active */
        }
        #tab-2d.active {
            display: flex;
        }

        .controls-2d {
            margin: 10px 0;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        .controls-2d label { font-weight: bold; }
        .controls-2d input[type="number"] { width: 60px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .controls-2d select { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        
        /* –ó–∞–≥–∞–ª—å–Ω—ñ –∫–Ω–æ–ø–∫–∏ */
        button {
            padding: 8px 12px;
            font-size: 14px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .btn-manual { background-color: #28a745; }
        .btn-manual:hover { background-color: #218838; }
        .btn-reset { background-color: #dc3545; }
        .btn-reset:hover { background-color: #c82333; }

        #simulation-container-2d {
            position: relative;
            width: 800px;
            height: 500px;
            border-radius: 8px;
            flex-shrink: 0;
        }
        #main-canvas-2d {
            position: relative;
            z-index: 2;
            background: transparent;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: crosshair;
        }
        #voronoi-canvas-2d {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: #fff;
            border-radius: 8px;
        }
        #tooltip-2d {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 3;
        }
        #theory-container-2d {
            margin-top: 20px;
            width: 800px;
            max-width: 100%;
            padding-bottom: 40px;
        }

        /* --- –°–¢–ò–õ–Ü –î–õ–Ø 3D –°–ò–ú–£–õ–Ø–¢–û–†–ê --- */
        #tab-3d {
            padding: 10px;
            box-sizing: border-box;
            height: 100%;
            overflow: hidden; /* –ü—Ä–∏–±–∏—Ä–∞—î–º–æ —Å–∫—Ä–æ–ª —Å–∞–º–æ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
        }
        /* Wrapper –¥–ª—è 3D (Flex layout) */
        #app-wrapper-3d {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            gap: 10px;
        }
        #main-content-3d {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-grow: 1;
            min-height: 0; 
        }
        #simulation-container-3d {
            flex-grow: 1;
            position: relative;
            border-radius: 8px;
            border: 2px solid #ddd;
            min-width: 0;
        }
        #three-canvas-3d {
            width: 100%;
            height: 100%;
            display: block;
            background: #fff;
            border-radius: 8px;
        }
        #main-controls-panel-3d {
            width: 240px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .control-group-3d {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        .control-group-3d:last-child { border-bottom: none; }
        .control-group-3d label { font-weight: bold; font-size: 14px; margin-bottom: -5px; }
        .control-group-3d input[type="number"], .control-group-3d select { width: 100%; box-sizing: border-box; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .checkbox-label-3d { display: flex; align-items: center; font-weight: normal; font-size: 14px; cursor: pointer; gap: 5px; }
        
        /* –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π —Å–ª–∞–π–¥–µ—Ä */
        .vertical-slider-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            height: 150px;
        }
        #density-slider-3d {
            writing-mode: bt-lr; /* IE/Edge */
            appearance: slider-vertical; /* Chrome/Safari */
            width: 8px;
            height: 120px;
        }
        
        #theory-container-3d {
            width: 100%;
            height: 25vh;
            flex-shrink: 0;
            overflow-y: auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            box-sizing: border-box;
        }
        #tooltip-3d {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 3;
        }

        /* –°–ø—ñ–ª—å–Ω—ñ —Å—Ç–∏–ª—ñ –¥–ª—è Theory Details */
        details {
            background: #fff;
            border-radius: 8px;
            padding: 10px; 
            /* –î–ª—è 2D —Ü–µ –±—É–ª–æ –≤–∞–∂–ª–∏–≤–æ, –¥–ª—è 3D —Ç–µ–∂ –Ω–µ –∑–∞–≤–∞–¥–∏—Ç—å */
            box-shadow: none; 
        }
        summary {
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            color: #0056b3;
            margin-bottom: 10px;
        }
        p, li { line-height: 1.6; }
        pre { background: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; }
        code { font-family: "Courier New", Courier, monospace; }
    </style>
</head>
<body>

    <div class="tabs-nav">
        <button class="tab-button active" onclick="openTab('2d')">2D –°–∏–º—É–ª—è—Ç–æ—Ä</button>
        <button class="tab-button" onclick="openTab('3d')">3D –°–∏–º—É–ª—è—Ç–æ—Ä</button>
    </div>

    <div id="tab-2d" class="tab-content active">
        <h1>K-means Clustering Simulator (2D)</h1>

        <div class="controls-2d" id="controls-2d">
            <label for="k-input-2d">K:</label>
            <input type="number" id="k-input-2d" value="3" min="1" max="10">
            
            <label for="metric-select-2d">–ú–µ—Ç—Ä–∏–∫–∞:</label>
            <select id="metric-select-2d">
                <option value="euclidean">–ï–≤–∫–ª—ñ–¥–æ–≤–∞</option>
                <option value="manhattan">–ú–∞–Ω—Ö–µ—Ç—Ç–µ–Ω—Å—å–∫–∞</option>
            </select>
            
            <button id="btn-gen-points-2d">–ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Ç–æ—á–∫–∏ (50)</button>
            <button id="btn-random-centroids-2d">–ê–≤—Ç–æ-—Ü–µ–Ω—Ç—Ä–∏</button>
            <button id="btn-manual-centroids-2d" class="btn-manual">–ó–∞–¥–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä–∏ –≤—Ä—É—á–Ω—É</button>
            
            <button id="btn-step-2d" disabled>–ö—Ä–æ–∫</button>
            <button id="btn-run-2d" disabled>–ó–∞–ø—É—Å—Ç–∏—Ç–∏/–ó—É–ø–∏–Ω–∏—Ç–∏</button>
            <button id="btn-reset-2d" class="btn-reset">–°–∫–∏–Ω—É—Ç–∏ –≤—Å–µ</button>
        </div>
        
        <div class="controls-2d">
            <input type="checkbox" id="chk-lines-2d" checked>
            <label for="chk-lines-2d">–ü–æ–∫–∞–∑–∞—Ç–∏ –ª—ñ–Ω—ñ—ó –¥–æ —Ü–µ–Ω—Ç—Ä—ñ–≤</label>
            
            <input type="checkbox" id="chk-voronoi-2d">
            <label for="chk-voronoi-2d">–ü–æ–∫–∞–∑–∞—Ç–∏ –º–µ–∂—ñ –í–æ—Ä–æ–Ω–æ–≥–æ</label>
        </div>

        <div id="simulation-container-2d">
            <canvas id="voronoi-canvas-2d" width="800" height="500"></canvas>
            <canvas id="main-canvas-2d" width="800" height="500"></canvas>
            <div id="tooltip-2d">–ö–ª—ñ–∫: –¥–æ–¥–∞—Ç–∏ —Ç–æ—á–∫—É | –ü–ö–ú: –≤–∏–¥–∞–ª–∏—Ç–∏ | Drag: –ø–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏</div>
        </div>

        <div id="theory-container-2d">
            <details>
                <summary>üìñ –¢–µ–æ—Ä—ñ—è: –ê–ª–≥–æ—Ä–∏—Ç–º K-means</summary>
                
                <h3>–©–æ —Ç–∞–∫–µ K-means?</h3>
                <p>
                    <b>K-means (K-—Å–µ—Ä–µ–¥–Ω—ñ—Ö)</b> ‚Äî —Ü–µ –æ–¥–∏–Ω –∑ –Ω–∞–π–ø–æ–ø—É–ª—è—Ä–Ω—ñ—à–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤ **–Ω–∞–≤—á–∞–Ω–Ω—è –±–µ–∑ –≤—á–∏—Ç–µ–ª—è** (unsupervised learning), —è–∫–∏–π –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è **–∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—ó**. –ô–æ–≥–æ –º–µ—Ç–∞ ‚Äî —Ä–æ–∑–¥—ñ–ª–∏—Ç–∏ –Ω–∞–±—ñ—Ä $N$ —Ç–æ—á–æ–∫ –¥–∞–Ω–∏—Ö –Ω–∞ $K$ –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤ (–≥—Ä—É–ø), –¥–µ –∫–æ–∂–Ω–∞ —Ç–æ—á–∫–∞ –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ –∑ –Ω–∞–π–±–ª–∏–∂—á–∏–º "—Ü–µ–Ω—Ç—Ä–æ–º" –∞–±–æ **—Ü–µ–Ω—Ç—Ä–æ—ó–¥–æ–º**.
                </p>

                <h3>–Ø–∫ –ø—Ä–∞—Ü—é—î –∞–ª–≥–æ—Ä–∏—Ç–º?</h3>
                <p>–ê–ª–≥–æ—Ä–∏—Ç–º –ø—Ä–∞—Ü—é—î —ñ—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ, –ø–æ–≤—Ç–æ—Ä—é—é—á–∏ –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ñ –∫—Ä–æ–∫–∏:</p>
                <ol>
                    <li>
                        <b>–ö—Ä–æ–∫ –ø—Ä–∏—Å–≤–æ—î–Ω–Ω—è (Assignment Step):</b>
                        –ö–æ–∂–Ω–∞ —Ç–æ—á–∫–∞ –¥–∞–Ω–∏—Ö $x_i$ –ø—Ä–∏—Å–≤–æ—é—î—Ç—å—Å—è –¥–æ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ $\mu_k$. "–ù–∞–π–±–ª–∏–∂—á–∏–π" –æ–∑–Ω–∞—á–∞—î –Ω–∞–π–º–µ–Ω—à—É –≤—ñ–¥—Å—Ç–∞–Ω—å $d$ –∑–∞ –æ–±—Ä–∞–Ω–æ—é **–º–µ—Ç—Ä–∏–∫–æ—é**.
                        $$ S_k^{(t)} = \{ x_i : d(x_i, \mu_k^{(t)}) \le d(x_i, \mu_j^{(t)}) \text{ –¥–ª—è –≤—Å—ñ—Ö } j=1, \dots, K \} $$
                    </li>
                    <li>
                        <b>–ö—Ä–æ–∫ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è (Update Step):</b>
                        –ü–æ–∑–∏—Ü—ñ—è –∫–æ–∂–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ $\mu_k$ –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î—Ç—å—Å—è —è–∫ <b>—Å–µ—Ä–µ–¥–Ω—î –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–Ω–µ</b> (—Ü–µ–Ω—Ç—Ä –º–∞—Å) —É—Å—ñ—Ö —Ç–æ—á–æ–∫ $x_i$, —è–∫—ñ –±—É–ª–∏ –ø—Ä–∏—Å–≤–æ—î–Ω—ñ –¥–æ –π–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ $S_k^{(t)}$ –Ω–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–º—É –∫—Ä–æ—Ü—ñ.
                        $$ \mu_k^{(t+1)} = \frac{1}{|S_k^{(t)}|} \sum_{x_i \in S_k^{(t)}} x_i $$
                    </li>
                </ol>
                <p>
                    –ê–ª–≥–æ—Ä–∏—Ç–º –ø–æ–≤—Ç–æ—Ä—é—î —Ü—ñ –¥–≤–∞ –∫—Ä–æ–∫–∏ (–ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è $\rightarrow$ –û–Ω–æ–≤–ª–µ–Ω–Ω—è $\rightarrow$ –ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è $\rightarrow$ ...) –¥–æ—Ç–∏, –¥–æ–∫–∏ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∏ –Ω–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω—É—Ç—å —Å—É—Ç—Ç—î–≤–æ –∑–º—ñ–Ω—é–≤–∞—Ç–∏ —Å–≤–æ—î –ø–æ–ª–æ–∂–µ–Ω–Ω—è (–∞–ª–≥–æ—Ä–∏—Ç–º <b>–∑—ñ–π—à–æ–≤—Å—è</b>).
                </p>

                <h3>–ú–µ—Ç—Ä–∏–∫–∏ –≤—ñ–¥—Å—Ç–∞–Ω—ñ</h3>
                <p>
                    "–ù–∞–π–±–ª–∏–∂—á–∏–π" ‚Äî –ø–æ–Ω—è—Ç—Ç—è –≤—ñ–¥–Ω–æ—Å–Ω–µ —ñ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Ç–æ–≥–æ, —è–∫ –º–∏ –≤–∏–º—ñ—Ä—é—î–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—å (—è–∫—É <b>–º–µ—Ç—Ä–∏–∫—É</b> –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ). K-means –º–æ–∂–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ —Ä—ñ–∑–Ω–∏–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏:
                </p>
                <ul>
                    <li>
                        <b>–ï–≤–∫–ª—ñ–¥–æ–≤–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (Euclidean, $L_2$):</b>
                        –¶–µ –∑–≤–∏—á–∞–π–Ω–∞, "–ø—Ä—è–º–∞" –≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –¥–≤–æ–º–∞ —Ç–æ—á–∫–∞–º–∏ $P_1(x_1, y_1)$ —Ç–∞ $P_2(x_2, y_2)$ —É –ø—Ä–æ—Å—Ç–æ—Ä—ñ. 
                        $$ d_E = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$
                        –ï–≤–∫–ª—ñ–¥–æ–≤–∞ –º–µ—Ç—Ä–∏–∫–∞ —Å—Ç–≤–æ—Ä—é—î –∫–ª–∞—Å—Ç–µ—Ä–∏ —Å—Ñ–µ—Ä–∏—á–Ω–æ—ó (–∫—Ä—É–≥–ª–æ—ó) —Ñ–æ—Ä–º–∏.
                    </li>
                    <li>
                        <b>–ú–∞–Ω—Ö–µ—Ç—Ç–µ–Ω—Å—å–∫–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (Manhattan, $L_1$):</b>
                        –¢–∞–∫–æ–∂ –≤—ñ–¥–æ–º–∞ —è–∫ "–≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ—Å—å–∫–∏—Ö –∫–≤–∞—Ä—Ç–∞–ª—ñ–≤". –¶–µ —Å—É–º–∞ –∞–±—Å–æ–ª—é—Ç–Ω–∏—Ö —Ä—ñ–∑–Ω–∏—Ü—å –∑–∞ –∫–æ–∂–Ω–æ—é –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—é.
                        $$ d_M = |x_2 - x_1| + |y_2 - y_1| $$
                        –ú–∞–Ω—Ö–µ—Ç—Ç–µ–Ω—Å—å–∫–∞ –º–µ—Ç—Ä–∏–∫–∞ —Å—Ç–≤–æ—Ä—é—î –∫–ª–∞—Å—Ç–µ—Ä–∏, —â–æ –º–∞—é—Ç—å —Ñ–æ—Ä–º—É —Ä–æ–º–±–∞ (–ø–æ–≤–µ—Ä–Ω—É—Ç–æ–≥–æ –Ω–∞ 45¬∞ –∫–≤–∞–¥—Ä–∞—Ç–∞).
                    </li>
                </ul>

                <h3>–î—ñ–∞–≥—Ä–∞–º–∞ –í–æ—Ä–æ–Ω–æ–≥–æ —Ç–∞ K-means</h3>
                <p>
                    <b>–î—ñ–∞–≥—Ä–∞–º–∞ –í–æ—Ä–æ–Ω–æ–≥–æ</b> ‚Äî —Ü–µ —Å–ø–æ—Å—ñ–± —Ä–æ–∑–¥—ñ–ª–∏—Ç–∏ –ø–ª–æ—â–∏–Ω—É –Ω–∞ —Ä–µ–≥—ñ–æ–Ω–∏ (<b>–∫–æ–º—ñ—Ä–∫–∏ –í–æ—Ä–æ–Ω–æ–≥–æ</b>) –Ω–∞ –æ—Å–Ω–æ–≤—ñ –Ω–∞–±–æ—Ä—É —Ç–æ—á–æ–∫ (—É –Ω–∞—à–æ–º—É –≤–∏–ø–∞–¥–∫—É ‚Äî —Ü–µ–Ω—Ç—Ä–æ—ó–¥—ñ–≤). –ö–æ–∂–Ω–∞ –∫–æ–º—ñ—Ä–∫–∞ $R_k$ –º—ñ—Å—Ç–∏—Ç—å —É—Å—ñ —Ç–æ—á–∫–∏ –ø–ª–æ—â–∏–Ω–∏, —è–∫—ñ –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è *–±–ª–∏–∂—á–µ* –¥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ $\mu_k$, –Ω—ñ–∂ –¥–æ –±—É–¥—å-—è–∫–æ–≥–æ —ñ–Ω—à–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞.
                </p>
                <ul>
                    <li><b>–ö—Ä–æ–∫ –ø—Ä–∏—Å–≤–æ—î–Ω–Ω—è</b> –≤ K-means ‚Äî —Ü–µ, –ø–æ —Å—É—Ç—ñ, –ø–æ–±—É–¥–æ–≤–∞ –¥—ñ–∞–≥—Ä–∞–º–∏ –í–æ—Ä–æ–Ω–æ–≥–æ –¥–ª—è –ø–æ—Ç–æ—á–Ω–∏—Ö —Ü–µ–Ω—Ç—Ä–æ—ó–¥—ñ–≤ —ñ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è, –≤ —è–∫—É –∫–æ–º—ñ—Ä–∫—É –ø–æ—Ç—Ä–∞–ø–ª—è—î –∫–æ–∂–Ω–∞ —Ç–æ—á–∫–∞ –¥–∞–Ω–∏—Ö.</li>
                    <li><b>–ö—Ä–æ–∫ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è</b> ‚Äî —Ü–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ –≤ "—Ü–µ–Ω—Ç—Ä –º–∞—Å" —É—Å—ñ—Ö —Ç–æ—á–æ–∫, —â–æ –æ–ø–∏–Ω–∏–ª–∏—Å—è –≤ –π–æ–≥–æ –∫–æ–º—ñ—Ä—Ü—ñ.</li>
                </ul>
                <p>
                    –£ —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ <b>—á–µ—Ä–≤–æ–Ω–∏–π –∫–æ–Ω—Ç—É—Ä</b> –Ω–∞ —Ç–æ—á—Ü—ñ (–ø—Ä–∏ —É–≤—ñ–º–∫–Ω–µ–Ω–∏—Ö –º–µ–∂–∞—Ö –í–æ—Ä–æ–Ω–æ–≥–æ) –æ–∑–Ω–∞—á–∞—î, —â–æ —Ü—è —Ç–æ—á–∫–∞ –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –æ–¥–Ω–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ (–∑–∞ –∫–æ–ª—å–æ—Ä–æ–º), –∞–ª–µ —Ñ—ñ–∑–∏—á–Ω–æ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –∫–æ–º—ñ—Ä—Ü—ñ –í–æ—Ä–æ–Ω–æ–≥–æ *—ñ–Ω—à–æ–≥–æ* —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞. –¶–µ –≤—ñ–∑—É–∞–ª—å–Ω–∏–π —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ç–æ–≥–æ, —â–æ –∞–ª–≥–æ—Ä–∏—Ç–º —â–µ <b>–Ω–µ –∑—ñ–π—à–æ–≤—Å—è</b>.
                </p>
                
                <h3>–î–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è K-means?</h3>
                <p>K-means —à–∏—Ä–æ–∫–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è:</p>
                <ul>
                    <li><b>–°–µ–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó —Ä–∏–Ω–∫—É:</b> –ì—Ä—É–ø—É–≤–∞–Ω–Ω—è –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑–∞ –ø–æ–≤–µ–¥—ñ–Ω–∫–æ—é –∞–±–æ –¥–µ–º–æ–≥—Ä–∞—Ñ—ñ—î—é.</li>
                    <li><b>–ê–Ω–∞–ª—ñ–∑—É –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤:</b> –ì—Ä—É–ø—É–≤–∞–Ω–Ω—è –Ω–æ–≤–∏–Ω –∞–±–æ —Å—Ç–∞—Ç–µ–π –∑–∞ —Ç–µ–º–∞–º–∏.</li>
                    <li><b>–í–∏—è–≤–ª–µ–Ω–Ω—è –∞–Ω–æ–º–∞–ª—ñ–π:</b> –¢–æ—á–∫–∏, —â–æ –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è –¥—É–∂–µ –¥–∞–ª–µ–∫–æ –≤—ñ–¥ –±—É–¥—å-—è–∫–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞, –º–æ–∂—É—Ç—å –±—É—Ç–∏ –≤–∏–∫–∏–¥–∞–º–∏.</li>
                    <li><b>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å (–í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –∫–æ–ª—å–æ—Ä—ñ–≤)</b>.</li>
                </ul>

                <hr>
                <h4>–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è: –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –∫–æ–ª—å–æ—Ä—ñ–≤ (Color Quantization)</h4>
                <p>
                    –û–¥–Ω–µ –∑ –Ω–∞–π—Ü—ñ–∫–∞–≤—ñ—à–∏—Ö –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω—å K-means ‚Äî —Ü–µ <b>—Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å</b> —à–ª—è—Ö–æ–º –∑–º–µ–Ω—à–µ–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∫–æ–ª—å–æ—Ä—ñ–≤ (–≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –∞–±–æ –∫–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è –∫–æ–ª—å–æ—Ä—ñ–≤).
                </p>
                <p>
                    –£—è–≤—ñ—Ç—å, —â–æ —É –≤–∞—Å —î –ø–æ–≤–Ω–æ–∫–æ–ª—ñ—Ä–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è (24-–±—ñ—Ç, True Color). –ö–æ–∂–µ–Ω –ø—ñ–∫—Å–µ–ª—å —É –Ω—å–æ–º—É –æ–ø–∏—Å—É—î—Ç—å—Å—è —Ç—Ä—å–æ–º–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏: $(R, G, B)$ ‚Äî –ß–µ—Ä–≤–æ–Ω–∏–π, –ó–µ–ª–µ–Ω–∏–π, –°–∏–Ω—ñ–π. –¶–µ –ø–æ–Ω–∞–¥ 16 –º—ñ–ª—å–π–æ–Ω—ñ–≤ –º–æ–∂–ª–∏–≤–∏—Ö –∫–æ–ª—å–æ—Ä—ñ–≤. –ù–∞—à–∞ –º–µ—Ç–∞ ‚Äî —Å–∫–æ—Ä–æ—Ç–∏—Ç–∏ —Ü—é –ø–∞–ª—ñ—Ç—Ä—É, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–æ $K=16$ –∫–æ–ª—å–æ—Ä—ñ–≤, –∑–±–µ—Ä—ñ–≥—à–∏ –ø—Ä–∏ —Ü—å–æ–º—É –≤—ñ–∑—É–∞–ª—å–Ω—É —è–∫—ñ—Å—Ç—å.
                </p>
                <p><b>–Ø–∫ K-means –≤–∏—Ä—ñ—à—É—î —Ü—é –∑–∞–¥–∞—á—É:</b></p>
                <ol>
                    <li>
                        <b>–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–∏—Ö:</b> –ö–æ–∂–µ–Ω –ø—ñ–∫—Å–µ–ª—å –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Å—Ç–∞—î —Ç–æ—á–∫–æ—é –¥–∞–Ω–∏—Ö. –¶–µ <b>—Ç—Ä–∏–≤–∏–º—ñ—Ä–Ω—ñ</b> –¥–∞–Ω—ñ (–≤–∏–º—ñ—Ä–∏: R, G, B). –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è 1000x800 –ø—ñ–∫—Å–µ–ª—ñ–≤ –¥–∞—î –Ω–∞–º $N=800,000$ —Ç–æ—á–æ–∫ —É 3D-–ø—Ä–æ—Å—Ç–æ—Ä—ñ –∫–æ–ª—å–æ—Ä—ñ–≤.
                    </li>
                    <li>
                       <b>–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—è:</b> –ú–∏ –∑–∞–ø—É—Å–∫–∞—î–º–æ K-means –∑ $K=16$. –ê–ª–≥–æ—Ä–∏—Ç–º –∑–Ω–∞—Ö–æ–¥–∏—Ç—å 16 "—Å–µ—Ä–µ–¥–Ω—ñ—Ö" –∫–æ–ª—å–æ—Ä—ñ–≤, —è–∫—ñ –Ω–∞–π–∫—Ä–∞—â–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç—å —É—Å—ñ –∫–æ–ª—å–æ—Ä–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è.
                    </li>
                    <li>
                        <b>–ó–∞–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—ñ–≤:</b> –ö–æ–∂–µ–Ω –ø—ñ–∫—Å–µ–ª—å –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑–∞–º—ñ–Ω—é—î—Ç—å—Å—è –Ω–∞ –Ω–∞–π–±–ª–∏–∂—á–∏–π —Ü–µ–Ω—Ç—Ä–æ—ó–¥ (–æ–¥–∏–Ω –∑ 16 –∫–æ–ª—å–æ—Ä—ñ–≤).
                    </li>
                </ol>
                <p>
                    <b>–†–µ–∑—É–ª—å—Ç–∞—Ç:</b> –ó–∞–º—ñ—Å—Ç—å —Ç–æ–≥–æ, —â–æ–± –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ 24 –±—ñ—Ç–∏ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø—ñ–∫—Å–µ–ª—è, –º–∏ —Ç–µ–ø–µ—Ä –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –Ω–µ–≤–µ–ª–∏–∫—É –ø–∞–ª—ñ—Ç—Ä—É ($K \times 24$ –±—ñ—Ç) —ñ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø—ñ–∫—Å–µ–ª—è –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –ª–∏—à–µ –π–æ–≥–æ —ñ–Ω–¥–µ–∫—Å —É —Ü—ñ–π –ø–∞–ª—ñ—Ç—Ä—ñ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è $K=16$ –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤—Å—å–æ–≥–æ 4 –±—ñ—Ç–∏ –Ω–∞ –ø—ñ–∫—Å–µ–ª—å). –¶–µ –æ—Å–Ω–æ–≤–∞ —Ç–∞–∫–∏—Ö —Ñ–æ—Ä–º–∞—Ç—ñ–≤, —è–∫ GIF.
                </p>
                <hr>
                <h3>–ü–µ—Ä–µ–≤–∞–≥–∏ —Ç–∞ –Ω–µ–¥–æ–ª—ñ–∫–∏</h3>
                <h4>‚úÖ –ü–µ—Ä–µ–≤–∞–≥–∏:</h4>
                <ul>
                    <li><b>–ü—Ä–æ—Å—Ç–æ—Ç–∞ —Ç–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—å:</b> –õ–µ–≥–∫–æ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏, –æ–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω–æ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π. –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å $O(N \cdot K \cdot I \cdot D)$, –¥–µ $N$ - —Ç–æ—á–∫–∏, $K$ - –∫–ª–∞—Å—Ç–µ—Ä–∏, $I$ - —ñ—Ç–µ—Ä–∞—Ü—ñ—ó, $D$ - —Ä–æ–∑–º—ñ—Ä–Ω—ñ—Å—Ç—å (—É –Ω–∞—Å $D=2$, —É –∑–∞–¥–∞—á—ñ –∑ –∫–æ–ª—å–æ—Ä–∞–º–∏ $D=3$).</li>
                </ul>
                <h4>‚ùå –ù–µ–¥–æ–ª—ñ–∫–∏:</h4>
                <ul>
                    <li><b>–ù–µ–æ–±—Ö—ñ–¥–Ω–æ –∑–Ω–∞—Ç–∏ $K$:</b> –ü–æ—Ç—Ä—ñ–±–Ω–æ –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å –≤–∫–∞–∑–∞—Ç–∏ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤.</li>
                    <li><b>–ß—É—Ç–ª–∏–≤—ñ—Å—Ç—å –¥–æ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:</b> –†—ñ–∑–Ω—ñ –ø–æ—á–∞—Ç–∫–æ–≤—ñ —Ü–µ–Ω—Ç—Ä–∏ –º–æ–∂—É—Ç—å –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ —Ä—ñ–∑–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤.</li>
                    <li><b>–§–æ—Ä–º–∞ –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤:</b> K-means "–æ—á—ñ–∫—É—î" –∑–Ω–∞–π—Ç–∏ –∫–ª–∞—Å—Ç–µ—Ä–∏ —Å—Ñ–µ—Ä–∏—á–Ω–æ—ó (Euclidean) –∞–±–æ —Ä–æ–º–±–æ–≤–∏–¥–Ω–æ—ó (Manhattan) —Ñ–æ—Ä–º–∏.</li>
                </ul>
            </details>
        </div>
    </div>

    <div id="tab-3d" class="tab-content">
        <div id="app-wrapper-3d">

            <div id="main-content-3d">
                
                <div id="simulation-container-3d">
                    <canvas id="three-canvas-3d"></canvas>
                    <div id="tooltip-3d">–õ–ö–ú+Drag: –æ–±–µ—Ä—Ç–∞—Ç–∏ | –ü–ö–ú+Drag: –ø–∞–Ω–æ—Ä–∞–º—É–≤–∞—Ç–∏ | –ö–æ–ª—ñ—â–∞—Ç–∫–æ: –∑—É–º</div>
                </div>
    
                <div id="main-controls-panel-3d">
                    
                    <div class="control-group-3d">
                        <label for="k-input-3d">–ö–ª–∞—Å—Ç–µ—Ä–∏ (K):</label>
                        <input type="number" id="k-input-3d" value="3" min="1" max="10">
                        
                        <label for="metric-select-3d">–ú–µ—Ç—Ä–∏–∫–∞:</label>
                        <select id="metric-select-3d">
                            <option value="euclidean">–ï–≤–∫–ª—ñ–¥–æ–≤–∞</option>
                            <option value="manhattan">–ú–∞–Ω—Ö–µ—Ç—Ç–µ–Ω—Å—å–∫–∞</option>
                        </select>
                    </div>
                    
                    <div class="control-group-3d">
                        <label for="density-slider-3d">–°–∫—É–ø—á–µ–Ω—ñ—Å—Ç—å:</label>
                        <div class="vertical-slider-container">
                            <input type="range" id="density-slider-3d" min="0" max="0.95" step="0.05" value="0.7">
                        </div>
                    </div>
    
                    <div class="control-group-3d">
                        <label>–î–∞–Ω—ñ:</label>
                        <button id="btn-gen-points-3d">–ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ (30)</button>
                        <button id="btn-random-centroids-3d">–ê–≤—Ç–æ-—Ü–µ–Ω—Ç—Ä–∏</button>
                        <button id="btn-manual-centroids-3d" class="btn-manual">–ó–∞–¥–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä–∏ –≤—Ä—É—á–Ω—É</button>
                    </div>
                    
                    <div class="control-group-3d">
                        <label>–°–∏–º—É–ª—è—Ü—ñ—è:</label>
                        <button id="btn-step-3d" disabled>–ö—Ä–æ–∫</button>
                        <button id="btn-run-3d" disabled>–ó–∞–ø—É—Å—Ç–∏—Ç–∏/–ó—É–ø–∏–Ω–∏—Ç–∏</button>
                        <button id="btn-reset-3d" class="btn-reset">–°–∫–∏–Ω—É—Ç–∏ –≤—Å–µ</button>
                    </div>
    
                    <div class="control-group-3d">
                        <label>–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è:</label>
                        <label class="checkbox-label-3d">
                            <input type="checkbox" id="chk-lines-3d" checked>
                            –ü–æ–∫–∞–∑–∞—Ç–∏ –ª—ñ–Ω—ñ—ó
                        </label>
                        <label class="checkbox-label-3d">
                            <input type="checkbox" id="chk-voronoi-3d">
                            –ú–µ–∂—ñ –í–æ—Ä–æ–Ω–æ–≥–æ (K=2, 3)
                        </label>
                    </div>
    
                </div>
    
            </div>
    
            <div id="theory-container-3d">
                <details open>
                    <summary>üìñ –¢–µ–æ—Ä—ñ—è: –ê–ª–≥–æ—Ä–∏—Ç–º K-means (3D)</summary>
                    
                    <h3>–©–æ —Ç–∞–∫–µ K-means?</h3>
                    <p>
                        <b>K-means (K-—Å–µ—Ä–µ–¥–Ω—ñ—Ö)</b> ‚Äî —Ü–µ –∞–ª–≥–æ—Ä–∏—Ç–º **–Ω–∞–≤—á–∞–Ω–Ω—è –±–µ–∑ –≤—á–∏—Ç–µ–ª—è** –¥–ª—è **–∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—ó**. –ô–æ–≥–æ –º–µ—Ç–∞ ‚Äî —Ä–æ–∑–¥—ñ–ª–∏—Ç–∏ –Ω–∞–±—ñ—Ä $N$ —Ç–æ—á–æ–∫ –¥–∞–Ω–∏—Ö (—É 3D-–ø—Ä–æ—Å—Ç–æ—Ä—ñ —Ü–µ $x_i = (x, y, z)$) –Ω–∞ $K$ –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤, –¥–µ –∫–æ–∂–Ω–∞ —Ç–æ—á–∫–∞ –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ –∑ –Ω–∞–π–±–ª–∏–∂—á–∏–º **—Ü–µ–Ω—Ç—Ä–æ—ó–¥–æ–º**.
                    </p>
    
                    <h3>–Ø–∫ –ø—Ä–∞—Ü—é—î –∞–ª–≥–æ—Ä–∏—Ç–º?</h3>
                    <p>–ê–ª–≥–æ—Ä–∏—Ç–º –ø—Ä–∞—Ü—é—î —ñ—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ, –ø–æ–≤—Ç–æ—Ä—é—é—á–∏ –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ñ –∫—Ä–æ–∫–∏:</p>
                    <ol>
                        <li>
                            <b>–ö—Ä–æ–∫ –ø—Ä–∏—Å–≤–æ—î–Ω–Ω—è (Assignment Step):</b>
                            –ö–æ–∂–Ω–∞ —Ç–æ—á–∫–∞ –¥–∞–Ω–∏—Ö $x_i$ –ø—Ä–∏—Å–≤–æ—é—î—Ç—å—Å—è –¥–æ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ $\mu_k$ –∑–∞ –æ–±—Ä–∞–Ω–æ—é –º–µ—Ç—Ä–∏–∫–æ—é $d$.
                            $$ S_k^{(t)} = \{ x_i : d(x_i, \mu_k^{(t)}) \le d(x_i, \mu_j^{(t)}) \text{ –¥–ª—è –≤—Å—ñ—Ö } j=1, \dots, K \} $$
                        </li>
                        <li>
                            <b>–ö—Ä–æ–∫ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è (Update Step):</b>
                            –ü–æ–∑–∏—Ü—ñ—è –∫–æ–∂–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ $\mu_k$ –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î—Ç—å—Å—è —è–∫ <b>—Å–µ—Ä–µ–¥–Ω—î –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–Ω–µ</b> (—Ü–µ–Ω—Ç—Ä –º–∞—Å) —É—Å—ñ—Ö —Ç–æ—á–æ–∫ $x_i$, —è–∫—ñ –±—É–ª–∏ –ø—Ä–∏—Å–≤–æ—î–Ω—ñ –¥–æ –π–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ $S_k^{(t)}$.
                            $$ \mu_k^{(t+1)} = \frac{1}{|S_k^{(t)}|} \sum_{x_i \in S_k^{(t)}} x_i $$
                        </li>
                    </ol>
                    
                    <h3>–ú–µ—Ç—Ä–∏–∫–∏ –≤—ñ–¥—Å—Ç–∞–Ω—ñ (—É 3D)</h3>
                    <ul>
                        <li>
                            <b>–ï–≤–∫–ª—ñ–¥–æ–≤–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (Euclidean, $L_2$):</b>
                            $$ d_E = \sqrt{(x_2 - x_1)^2 + (y_2 - y1)^2 + (z_2 - z_1)^2} $$
                        </li>
                        <li>
                            <b>–ú–∞–Ω—Ö–µ—Ç—Ç–µ–Ω—Å—å–∫–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (Manhattan, $L_1$):</b>
                            $$ d_M = |x_2 - x_1| + |y_2 - y_1| + |z_2 - z_1| $$
                        </li>
                    </ul>
    
                    <h3>–î—ñ–∞–≥—Ä–∞–º–∞ –í–æ—Ä–æ–Ω–æ–≥–æ (—É 3D)</h3>
                    <p>
                        –ú–µ–∂—ñ –í–æ—Ä–æ–Ω–æ–≥–æ –ø–æ–∫–∞–∑—É—é—Ç—å –æ–±–ª–∞—Å—Ç—ñ, –¥–µ –∫–æ–∂–Ω–∞ —Ç–æ—á–∫–∞ –ø—Ä–æ—Å—Ç–æ—Ä—É –±–ª–∏–∂—á–∞ –¥–æ –æ–¥–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞, –Ω—ñ–∂ –¥–æ —ñ–Ω—à–∏—Ö.
                    </p>
                    <ul>
                        <li><b>K=2:</b> –ú–µ–∂–∞ ‚Äî —Ü–µ –æ–¥–Ω–∞ –ø–ª–æ—â–∏–Ω–∞, —â–æ —Ç–µ–ø–µ—Ä –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä—ñ–∑–∞–Ω–∞ –º–µ–∂–∞–º–∏ —Å–∏–º—É–ª—è—Ü—ñ—ó.</li>
                        <li><b>K=3:</b> –ú–µ–∂—ñ ‚Äî —Ü–µ —Ç—Ä–∏ –Ω–∞–ø—ñ–≤–ø–ª–æ—â–∏–Ω–∏, —â–æ —Å—Ö–æ–¥—è—Ç—å—Å—è –Ω–∞ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–º—É —Ä–µ–±—Ä—ñ. –í–æ–Ω–∏ —Ç–∞–∫–æ–∂ –æ–±—Ä—ñ–∑–∞–Ω—ñ –º–µ–∂–∞–º–∏ —Å–∏–º—É–ª—è—Ü—ñ—ó.</li>
                    </ul>
                </details>
            </div>
    
        </div>
    </div>

    <script>
        function openTab(tabName) {
            // –ü—Ä–∏—Ö–æ–≤–∞—Ç–∏ –≤—Å—ñ –≤–∫–ª–∞–¥–∫–∏
            const tabContents = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove("active");
            }

            // –î–µ–∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –≤—Å—ñ –∫–Ω–æ–ø–∫–∏
            const tabButtons = document.getElementsByClassName("tab-button");
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove("active");
            }

            // –ü–æ–∫–∞–∑–∞—Ç–∏ –æ–±—Ä–∞–Ω—É
            document.getElementById("tab-" + tabName).classList.add("active");
            
            // –ó–Ω–∞–π—Ç–∏ –∫–Ω–æ–ø–∫—É, —è–∫–∞ –±—É–ª–∞ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∞ (—Ç—Ä–æ—Ö–∏ —Å–ø—Ä–æ—â–µ–Ω–æ)
            // –û—Å–∫—ñ–ª—å–∫–∏ —Ñ—É–Ω–∫—Ü—ñ—è –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∑ –∫–Ω–æ–ø–∫–∏, –º–∏ –º–æ–∂–µ–º–æ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∏–ª—ñ –∫–Ω–æ–ø–æ–∫
            const buttonsArray = Array.from(tabButtons);
            const targetBtn = buttonsArray.find(btn => btn.textContent.toLowerCase().includes(tabName));
            if(targetBtn) targetBtn.classList.add("active");

            // –í–ê–ñ–õ–ò–í–û: –ü—Ä–∏ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—ñ –Ω–∞ 3D, —Ç—Ä–µ–±–∞ –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –ø–æ–¥—ñ—é resize, 
            // —â–æ–± Three.js –ø–µ—Ä–µ—Ä–∞—Ö—É–≤–∞–≤ —Ä–æ–∑–º—ñ—Ä–∏ –∫–∞–Ω–≤–∏ (—ñ–Ω–∞–∫—à–µ –≤–æ–Ω–∞ –º–æ–∂–µ –±—É—Ç–∏ 0x0)
            if (tabName === '3d') {
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 50);
            }
        }
    </script>

    <script>
    // –Ü–∑–æ–ª—é—î–º–æ —Å–∫–æ—É–ø 2D –∑–º—ñ–Ω–Ω–∏—Ö
    (function() {
        document.addEventListener('DOMContentLoaded', () => {
            // –ü–µ—Ä–µ–≤—ñ—Ä–∏–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ (–Ω–∞ –≤–∏–ø–∞–¥–æ–∫, —è–∫—â–æ ID –∑–º—ñ–Ω–µ–Ω—ñ)
            if(!document.getElementById('main-canvas-2d')) return;

            // --- –ï–ª–µ–º–µ–Ω—Ç–∏ DOM ---
            const canvas = document.getElementById('main-canvas-2d');
            const ctx = canvas.getContext('2d');
            const voronoiCanvas = document.getElementById('voronoi-canvas-2d');
            const vCtx = voronoiCanvas.getContext('2d');
            
            const kInput = document.getElementById('k-input-2d');
            const metricSelect = document.getElementById('metric-select-2d');
            
            const chkLines = document.getElementById('chk-lines-2d');
            const chkVoronoi = document.getElementById('chk-voronoi-2d');
            const tooltip = document.getElementById('tooltip-2d');

            const btnGenPoints = document.getElementById('btn-gen-points-2d');
            const btnRandomCentroids = document.getElementById('btn-random-centroids-2d');
            const btnManualCentroids = document.getElementById('btn-manual-centroids-2d');
            const btnStep = document.getElementById('btn-step-2d');
            const btnRun = document.getElementById('btn-run-2d');
            const btnReset = document.getElementById('btn-reset-2d');

            // --- –°—Ç–∞–Ω —Å–∏–º—É–ª—è—Ü—ñ—ó ---
            let points = [];
            let centroids = [];
            let k = parseInt(kInput.value);
            
            // –ü–∞–ª—ñ—Ç—Ä–∞ –∫–æ–ª—å–æ—Ä—ñ–≤ (–¥–æ 10 –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤)
            const colors = [
                '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', 
                '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4'
            ];

            let algorithmState = 'assign'; // 'assign' or 'update'
            let runInterval = null;
            let settingCentroids = false; // –†–µ–∂–∏–º —Ä—É—á–Ω–æ–≥–æ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è —Ü–µ–Ω—Ç—Ä—ñ–≤
            
            // Drag & Drop
            let isDragging = false;
            let draggedPointIndex = -1;

            // –ü–æ—Ç–æ—á–Ω–∞ –º–µ—Ç—Ä–∏–∫–∞
            let currentMetric = 'euclidean';

            // --- –û—Å–Ω–æ–≤–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó ---

            function generatePoints(count = 50) {
                points = [];
                for (let i = 0; i < count; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        cluster: null
                    });
                }
                draw();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // –õ—ñ–Ω—ñ—ó –¥–æ —Ü–µ–Ω—Ç—Ä—ñ–≤
                if (chkLines.checked) {
                    for (const point of points) {
                        if (point.cluster !== null) {
                            const centroid = centroids[point.cluster];
                            ctx.beginPath();
                            ctx.moveTo(point.x, point.y);
                            
                            if (currentMetric === 'manhattan') {
                                // –ú–∞–ª—é—î–º–æ "–ª–∞–º–∞–Ω—É" –ª—ñ–Ω—ñ—é: –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ, –ø–æ—Ç—ñ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ
                                ctx.lineTo(centroid.x, point.y); // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç
                                ctx.lineTo(centroid.x, centroid.y); // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç
                            } else {
                                // –ú–∞–ª—é—î–º–æ –ø—Ä—è–º—É (–ï–≤–∫–ª—ñ–¥–æ–≤–∞)
                                ctx.lineTo(centroid.x, centroid.y);
                            }
                            
                            ctx.strokeStyle = colors[point.cluster];
                            ctx.stroke();
                        }
                    }
                }

                // –¢–æ—á–∫–∏
                for (const point of points) {
                    ctx.beginPath();
                    // –Ø–∫—â–æ –≤–≤—ñ–º–∫–Ω–µ–Ω–æ –í–æ—Ä–æ–Ω–æ–≥–æ —ñ —Ç–æ—á–∫–∏ –ø—Ä–∏—Å–≤–æ—î–Ω—ñ, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ "–∫–æ—Ä–µ–∫—Ç–Ω—ñ—Å—Ç—å"
                    // (—Ü–µ –±—ñ–ª—å—à–µ –¥–ª—è –∫—Ä–∞—Å–∏, –æ—Å–Ω–æ–≤–Ω–∞ –ª–æ–≥—ñ–∫–∞ - –∫–æ–ª—ñ—Ä)
                    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = (point.cluster !== null) ? colors[point.cluster] : '#999';
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    
                    // –Ø–∫—â–æ —Ç–æ—á–∫–∞ –≤—ñ–∑—É–∞–ª—å–Ω–æ –≤ "—á—É–∂—ñ–π" –∑–æ–Ω—ñ (—Ç—ñ–ª—å–∫–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó, —Ç—É—Ç —Å–ø—Ä–æ—â–µ–Ω–æ)
                    // –£ —Å–∫–ª–∞–¥–Ω—ñ–π –≤–µ—Ä—Å—ñ—ó –º–∏ –± –ø–µ—Ä–µ–≤—ñ—Ä—è–ª–∏ –≥–µ–æ–º–µ—Ç—Ä–∏—á–Ω–æ, –∞–ª–µ —Ç—É—Ç –ø–æ–∫–ª–∞–¥–∞—î–º–æ—Å—å –Ω–∞ –∫–æ–ª—ñ—Ä.
                    ctx.stroke();
                }

                // –¶–µ–Ω—Ç—Ä–æ—ó–¥–∏
                for (let i = 0; i < centroids.length; i++) {
                    const c = centroids[i];
                    ctx.beginPath();
                    // –ú–∞–ª—é—î–º–æ X
                    const size = 10;
                    ctx.moveTo(c.x - size, c.y - size);
                    ctx.lineTo(c.x + size, c.y + size);
                    ctx.moveTo(c.x + size, c.y - size);
                    ctx.lineTo(c.x - size, c.y + size);
                    
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = colors[i];
                    ctx.stroke();
                    ctx.lineWidth = 1; // Reset
                    
                    // –û–±–≤–æ–¥–∫–∞ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç—É
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
            }

            // Helper –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó hex –≤ rgb
            function hexToRgb(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            function drawVoronoi() {
                vCtx.clearRect(0, 0, voronoiCanvas.width, voronoiCanvas.height);
                vCtx.fillStyle = '#ffffff';
                vCtx.fillRect(0, 0, voronoiCanvas.width, voronoiCanvas.height);

                if (!chkVoronoi.checked || centroids.length === 0) {
                    draw(); // –ü–µ—Ä–µ–º–∞–ª—é–≤–∞—Ç–∏ –≥–æ–ª–æ–≤–Ω–∏–π –∫–∞–Ω–≤–∞—Å, –±–æ –≤—ñ–Ω –∑–≤–µ—Ä—Ö—É
                    return;
                }

                const imageData = vCtx.createImageData(voronoiCanvas.width, voronoiCanvas.height);
                const data = imageData.data;
                const rgbColors = colors.map(hexToRgb);

                // –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è: –ú–∞–ª—é—î–º–æ –í–æ—Ä–æ–Ω–æ–≥–æ –∑ –º–µ–Ω—à–æ—é —Ä–æ–∑–¥—ñ–ª—å–Ω–æ—é –∑–¥–∞—Ç–Ω—ñ—Å—Ç—é (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 4x4 –ø—ñ–∫—Å–µ–ª—ñ)
                const step = 4; 
                
                for (let y = 0; y < voronoiCanvas.height; y += step) {
                    for (let x = 0; x < voronoiCanvas.width; x += step) {
                        let minDist = Infinity;
                        let closestK = -1;
                        
                        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–±–ª–∏–∂—á–∏–π —Ü–µ–Ω—Ç—Ä–æ—ó–¥ –¥–ª—è –ø—ñ–∫—Å–µ–ª—è (x, y)
                        for (let i = 0; i < centroids.length; i++) {
                            const d = distance({x, y}, centroids[i]);
                            if (d < minDist) {
                                minDist = d;
                                closestK = i;
                            }
                        }

                        if (closestK !== -1) {
                            const c = rgbColors[closestK];
                            // –ó–∞–ø–æ–≤–Ω—é—î–º–æ –±–ª–æ–∫ step x step
                            for (let dy = 0; dy < step; dy++) {
                                for (let dx = 0; dx < step; dx++) {
                                    if (x + dx < voronoiCanvas.width && y + dy < voronoiCanvas.height) {
                                        const index = ((y + dy) * voronoiCanvas.width + (x + dx)) * 4;
                                        data[index] = c.r;
                                        data[index + 1] = c.g;
                                        data[index + 2] = c.b;
                                        data[index + 3] = 50; // –ü—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å (alpha)
                                    }
                                }
                            }
                        }
                    }
                }
                
                vCtx.putImageData(imageData, 0, 0);
                draw(); // –ü–µ—Ä–µ–º–∞–ª—é–≤–∞—Ç–∏ —Ç–æ—á–∫–∏ –ø–æ–≤–µ—Ä—Ö
            }

            function assignPointsToClusters() {
                if (centroids.length === 0) return false;
                let changed = false;
                for (const point of points) {
                    const bestCluster = findNearestCentroid(point);
                    if (point.cluster !== bestCluster) {
                        point.cluster = bestCluster;
                        changed = true;
                    }
                }
                algorithmState = 'update';
                return changed;
            }

            function updateCentroids() {
                if (centroids.length === 0) return;
                
                const clusterSums = Array(k).fill(0).map(() => ({ x: 0, y: 0 }));
                const clusterCounts = Array(k).fill(0);
                
                for (const point of points) {
                    if (point.cluster !== null) {
                        clusterSums[point.cluster].x += point.x;
                        clusterSums[point.cluster].y += point.y;
                        clusterCounts[point.cluster]++;
                    }
                }

                for (let i = 0; i < k; i++) {
                    if (clusterCounts[i] > 0) {
                        centroids[i].x = clusterSums[i].x / clusterCounts[i];
                        centroids[i].y = clusterSums[i].y / clusterCounts[i];
                    } else {
                        // –Ø–∫—â–æ –∫–ª–∞—Å—Ç–µ—Ä –ø–æ—Ä–æ–∂–Ω—ñ–π, –ø–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –≤ –≤–∏–ø–∞–¥–∫–æ–≤–µ –º—ñ—Å—Ü–µ (—Å—Ç—Ä–∞—Ç–µ–≥—ñ—è –ø–æ—Ä—è—Ç—É–Ω–∫—É)
                        centroids[i].x = Math.random() * canvas.width;
                        centroids[i].y = Math.random() * canvas.height;
                    }
                }
                algorithmState = 'assign';
                drawVoronoi(); // –ü–µ—Ä–µ–º–∞–ª—é–≤–∞—Ç–∏ –≤—Å–µ
            }

            // --- –§—É–Ω–∫—Ü—ñ—ó-–ø–æ–º—ñ—á–Ω–∏–∫–∏ ---
            function distance(p1, p2) {
                if (currentMetric === 'manhattan') {
                    return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
                }
                // Euclidean
                return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
            }

            function findNearestCentroid(point) {
                let minDistance = Infinity;
                let bestCluster = -1;
                for (let i = 0; i < centroids.length; i++) {
                    const dist = distance(point, centroids[i]);
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestCluster = i;
                    }
                }
                return bestCluster;
            }

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function findNearestPoint(pos) {
                for (let i = 0; i < points.length; i++) {
                    const dist = Math.sqrt((points[i].x - pos.x)**2 + (points[i].y - pos.y)**2);
                    if (dist < 10) return i;
                }
                return -1;
            }
            
            function findNearestCentroidIndex(pos) {
                 for (let i = 0; i < centroids.length; i++) {
                    const dist = Math.sqrt((centroids[i].x - pos.x)**2 + (centroids[i].y - pos.y)**2);
                    if (dist < 10) return i;
                }
                return -1;
            }

            function resetPointAssignments() {
                points.forEach(p => p.cluster = null);
            }

            // --- Event Listeners ---

            kInput.addEventListener('change', () => {
                k = parseInt(kInput.value);
                if (k > 10) kInput.value = 10;
                if (k < 1) kInput.value = 1;
                k = parseInt(kInput.value);
                
                centroids = [];
                settingCentroids = false;
                resetPointAssignments();
                updateButtonStates();
                drawVoronoi();
            });

            metricSelect.addEventListener('change', (e) => {
                currentMetric = e.target.value;
                drawVoronoi();
            });

            btnGenPoints.addEventListener('click', () => {
                generatePoints();
                resetPointAssignments();
                if (centroids.length > 0) {
                    assignPointsToClusters(); // –û–¥—Ä–∞–∑—É –ø—Ä–∏—Å–≤–æ—ó—Ç–∏, —è–∫—â–æ —Ü–µ–Ω—Ç—Ä–∏ —î
                    algorithmState = 'update';
                }
                draw();
            });

            btnRandomCentroids.addEventListener('click', () => {
                settingCentroids = false;
                centroids = [];
                for (let i = 0; i < k; i++) {
                    centroids.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    });
                }
                resetPointAssignments();
                algorithmState = 'assign';
                updateButtonStates();
                updateTooltip();
                drawVoronoi();
            });

            btnManualCentroids.addEventListener('click', () => {
                settingCentroids = true;
                centroids = [];
                resetPointAssignments();
                updateButtonStates();
                updateTooltip();
                drawVoronoi();
            });

            btnStep.addEventListener('click', () => {
                if (algorithmState === 'assign') {
                    assignPointsToClusters();
                    draw(); // –¢—É—Ç –¥–æ—Å—Ç–∞—Ç–Ω—å–æ draw, –º–µ–∂—ñ –Ω–µ –º—ñ–Ω—è—é—Ç—å—Å—è
                } else {
                    updateCentroids(); // –¢—É—Ç drawVoronoi –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ
                }
            });

            btnRun.addEventListener('click', () => {
                if (runInterval) {
                    clearInterval(runInterval);
                    runInterval = null;
                    btnRun.textContent = '–ó–∞–ø—É—Å—Ç–∏—Ç–∏';
                } else {
                    btnRun.textContent = '–ó—É–ø–∏–Ω–∏—Ç–∏';
                    runInterval = setInterval(() => {
                        if (algorithmState === 'assign') {
                            const changed = assignPointsToClusters();
                            draw();
                            if (!changed) {
                                clearInterval(runInterval);
                                runInterval = null;
                                btnRun.textContent = '–ó–∞–ø—É—Å—Ç–∏—Ç–∏';
                                alert("–ê–ª–≥–æ—Ä–∏—Ç–º –∑—ñ–π—à–æ–≤—Å—è!");
                            }
                        } else {
                            updateCentroids();
                        }
                    }, 500);
                }
            });

            btnReset.addEventListener('click', () => {
                if (runInterval) clearInterval(runInterval);
                runInterval = null;
                points = [];
                centroids = [];
                settingCentroids = false;
                algorithmState = 'assign';
                btnRun.textContent = '–ó–∞–ø—É—Å—Ç–∏—Ç–∏';
                updateButtonStates();
                updateTooltip();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                vCtx.clearRect(0, 0, voronoiCanvas.width, voronoiCanvas.height);
            });

            chkLines.addEventListener('change', draw);
            chkVoronoi.addEventListener('change', drawVoronoi);

            // Mouse interactions
            canvas.addEventListener('mousedown', (e) => {
                const pos = getMousePos(e);
                
                if (settingCentroids) {
                    if (centroids.length < k) {
                        centroids.push(pos);
                        updateButtonStates();
                        updateTooltip();
                        drawVoronoi();
                        if (centroids.length === k) {
                            settingCentroids = false;
                            updateButtonStates();
                            updateTooltip();
                            // Auto start assignment
                            resetPointAssignments();
                            algorithmState = 'assign';
                        }
                    }
                    return;
                }

                // Dragging check
                const pointIndex = findNearestPoint(pos);
                if (pointIndex !== -1) {
                    if (e.button === 2) { // Right click -> Delete
                        points.splice(pointIndex, 1);
                        draw();
                        e.preventDefault();
                    } else {
                        isDragging = true;
                        draggedPointIndex = pointIndex;
                    }
                    return;
                }
                
                // Dragging centroid
                 const centroidIndex = findNearestCentroidIndex(pos);
                if (centroidIndex !== -1 && !settingCentroids) {
                     // We could implement dragging centroids, but for standard k-means logic
                     // user usually drags data points. Let's stick to adding points.
                }

                // Add point
                if (!isDragging && e.button === 0) {
                    points.push({ x: pos.x, y: pos.y, cluster: null });
                    if (centroids.length > 0) {
                        // –®–≤–∏–¥–∫–∏–π update –¥–ª—è –Ω–æ–≤–æ—ó —Ç–æ—á–∫–∏
                        const best = findNearestCentroid(points[points.length-1]);
                        points[points.length-1].cluster = best;
                    }
                    draw();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                if (isDragging && draggedPointIndex !== -1) {
                    points[draggedPointIndex].x = pos.x;
                    points[draggedPointIndex].y = pos.y;
                    // Recalculate immediate cluster for visual feedback
                    if (centroids.length > 0) {
                         points[draggedPointIndex].cluster = findNearestCentroid(points[draggedPointIndex]);
                    }
                    draw();
                } else if (!settingCentroids) {
                    const pointIndex = findNearestPoint(pos);
                    canvas.style.cursor = (pointIndex !== -1) ? 'move' : 'crosshair';
                } else {
                     canvas.style.cursor = 'pointer';
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                draggedPointIndex = -1;
            });
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                draggedPointIndex = -1;
            });
            
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // --- –ö–µ—Ä—É–≤–∞–Ω–Ω—è —Å—Ç–∞–Ω–æ–º UI ---
            function updateButtonStates() {
                const hasCentroids = centroids.length > 0;
                btnStep.disabled = !hasCentroids || settingCentroids;
                btnRun.disabled = !hasCentroids || settingCentroids;
                
                if (settingCentroids) {
                    btnManualCentroids.textContent = `–í—Å—Ç–∞–Ω–æ–≤—ñ—Ç—å —Ü–µ–Ω—Ç—Ä ${centroids.length + 1}/${k}`;
                    btnManualCentroids.disabled = true;
                } else {
                    btnManualCentroids.textContent = '–ó–∞–¥–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä–∏ –≤—Ä—É—á–Ω—É';
                    btnManualCentroids.disabled = false;
                }
            }

            function updateTooltip() {
                if (settingCentroids) {
                    tooltip.textContent = `–ö–ª—ñ–∫–Ω—ñ—Ç—å, —â–æ–± –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —Ü–µ–Ω—Ç—Ä ${centroids.length + 1} –∑ ${k}`;
                } else {
                    tooltip.textContent = '–ö–ª—ñ–∫: –¥–æ–¥–∞—Ç–∏ —Ç–æ—á–∫—É | –ü–ö–ú: –≤–∏–¥–∞–ª–∏—Ç–∏ | Drag: –ø–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏';
                }
            }

            // --- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –∑–∞–ø—É—Å–∫ ---
            drawVoronoi();
        });
    })();
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏
        const BOX_SIZE = 100;
        const HALF_BOX = BOX_SIZE / 2;

        // –ü–ª–æ—â–∏–Ω–∏ –¥–ª—è –æ–±–º–µ–∂–µ–Ω–Ω—è (Clipping Planes)
        const clippingPlanes = [
            new THREE.Plane(new THREE.Vector3( 1, 0, 0), HALF_BOX),
            new THREE.Plane(new THREE.Vector3(-1, 0, 0), HALF_BOX),
            new THREE.Plane(new THREE.Vector3( 0, 1, 0), HALF_BOX),
            new THREE.Plane(new THREE.Vector3( 0,-1, 0), HALF_BOX),
            new THREE.Plane(new THREE.Vector3( 0, 0,-1), HALF_BOX),
            new THREE.Plane(new THREE.Vector3( 0, 0, 1), HALF_BOX)
        ];

        // --- –ï–ª–µ–º–µ–Ω—Ç–∏ DOM (3D) ---
        const canvas = document.getElementById('three-canvas-3d');
        const container = document.getElementById('simulation-container-3d'); 
        
        const kInput = document.getElementById('k-input-3d');
        const metricSelect = document.getElementById('metric-select-3d');
        const densitySlider = document.getElementById('density-slider-3d');
        
        const chkLines = document.getElementById('chk-lines-3d');
        const chkVoronoi = document.getElementById('chk-voronoi-3d');
        const tooltip = document.getElementById('tooltip-3d');
        
        const btnGenPoints = document.getElementById('btn-gen-points-3d');
        const btnRandomCentroids = document.getElementById('btn-random-centroids-3d');
        const btnManualCentroids = document.getElementById('btn-manual-centroids-3d');
        const btnStep = document.getElementById('btn-step-3d');
        const btnRun = document.getElementById('btn-run-3d');
        const btnReset = document.getElementById('btn-reset-3d');

        // --- –°—Ç–∞–Ω —Å–∏–º—É–ª—è—Ü—ñ—ó 3D ---
        let points = [];
        let centroids = [];
        let k = parseInt(kInput.value);
        const colorsTHREE = [
            0xE6194B, 0x3CB44B, 0xFFE119, 0x4363D8, 0xF58231, 
            0x911EB4, 0x42D4F4, 0xF032E6, 0xBFEF45, 0xFABED4
        ];
        const greyColor = 0xaaaaaa;

        let algorithmState = 'assign'; 
        let runInterval = null;
        let settingCentroids = false;
        let currentMetric = 'euclidean';

        // --- Three.js –∑–º—ñ–Ω–Ω—ñ ---
        let scene, camera, renderer, orbitControls, dragControls;
        let raycaster, mouse;
        let pointGroup, centroidGroup, lineGroup, voronoiGroup;
        let invisiblePlane; // –î–ª—è –∫–ª—ñ–∫—ñ–≤

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // –ö–∞–º–µ—Ä–∞
            // –°–ø–æ—á–∞—Ç–∫—É aspect –º–æ–∂–µ –±—É—Ç–∏ –Ω–µ–≤—ñ—Ä–Ω–∏–º, —è–∫—â–æ –≤–∫–ª–∞–¥–∫–∞ –ø—Ä–∏—Ö–æ–≤–∞–Ω–∞, –æ–Ω–æ–≤–∏—Ç—å—Å—è –ø—Ä–∏ resize
            const aspect = container.clientWidth / container.clientHeight || 1;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 5000);
            camera.position.set(0, 0, BOX_SIZE * 1.5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.localClippingEnabled = true;

            // –°–≤—ñ—Ç–ª–æ
            scene.add(new THREE.AmbientLight(0xaaaaaa));
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1);
            scene.add(light);

            // –ì—Ä—É–ø–∏ –æ–±'—î–∫—Ç—ñ–≤
            pointGroup = new THREE.Group();
            centroidGroup = new THREE.Group();
            lineGroup = new THREE.Group();
            voronoiGroup = new THREE.Group();
            scene.add(pointGroup, centroidGroup, lineGroup, voronoiGroup);

            // –î–æ–ø–æ–º—ñ–∂–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏
            const gridHelper = new THREE.GridHelper(BOX_SIZE, 10);
            gridHelper.rotation.x = Math.PI / 2; // Z-up visually or just flat
            scene.add(gridHelper);

            // Box outline
            const boxGeom = new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE);
            const edges = new THREE.EdgesGeometry(boxGeom);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true });
            const boxHelper = new THREE.LineSegments(edges, lineMat);
            scene.add(boxHelper);

            // –ù–µ–≤–∏–¥–∏–º–∞ –ø–ª–æ—â–∏–Ω–∞ –¥–ª—è —Ä–µ–π–∫–∞—Å—Ç—ñ–Ω–≥—É (Z=0) –¥–ª—è —Ä–æ–∑–º—ñ—â–µ–Ω–Ω—è —Ç–æ—á–æ–∫ "–Ω–∞ –ø—ñ–¥–ª–æ–∑—ñ" –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º, 
            // –∞–±–æ –ø—Ä–æ—Å—Ç–æ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–ø–ª–µ–Ω–Ω—è –∫–ª—ñ–∫—ñ–≤
            const planeGeom = new THREE.PlaneGeometry(BOX_SIZE, BOX_SIZE);
            const planeMat = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });
            invisiblePlane = new THREE.Mesh(planeGeom, planeMat);
            scene.add(invisiblePlane);

            // –ö–æ–Ω—Ç—Ä–æ–ª–∏
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Drag controls logic handled via standard Listeners because DragControls is tricky with points
            // –ê–ª–µ —Ç—É—Ç –º–∏ –º–æ–∂–µ–º–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –ø—Ä–æ—Å—Ç—É –ª–æ–≥—ñ–∫—É –∫–ª—ñ–∫—ñ–≤ –∑ Raycaster
            
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('mousedown', onMouseDown);
        }

        // --- –õ–æ–≥—ñ–∫–∞ 3D –°–∏–º—É–ª—è—Ü—ñ—ó ---

        function getRandomPos() {
            return (Math.random() - 0.5) * BOX_SIZE * 0.9;
        }

        function createPointMesh(color) {
            const geometry = new THREE.SphereGeometry(1.5, 16, 16);
            const material = new THREE.MeshStandardMaterial({ color: color });
            return new THREE.Mesh(geometry, material);
        }

        function addPoint(pos) {
            const mesh = createPointMesh(greyColor);
            mesh.position.copy(pos);
            pointGroup.add(mesh);
            points.push({ pos, mesh, cluster: null });
        }

        function generateData(count) {
            // –û—á–∏—Å—Ç–∏—Ç–∏ —Å—Ç–∞—Ä—ñ
            points = [];
            pointGroup.clear();

            const density = parseFloat(densitySlider.value);
            // –ó–º—ñ—à–∞–Ω–∞ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—è: —á–∞—Å—Ç–∏–Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤–æ, —á–∞—Å—Ç–∏–Ω–∞ —Å–∫—É–ø—á–µ–Ω–Ω—è–º–∏
            const numClusters = Math.floor(Math.random() * 3) + 2;
            const centers = [];
            for(let i=0; i<numClusters; i++) {
                centers.push(new THREE.Vector3(getRandomPos(), getRandomPos(), getRandomPos()));
            }

            for (let i = 0; i < count; i++) {
                let pos;
                if (Math.random() < density) {
                    // –ë–ª–∏–∑—å–∫–æ –¥–æ –≤–∏–ø–∞–¥–∫–æ–≤–æ–≥–æ —Ü–µ–Ω—Ç—Ä—É
                    const center = centers[Math.floor(Math.random() * centers.length)];
                    const offset = 20;
                    pos = new THREE.Vector3(
                        center.x + (Math.random()-0.5)*offset,
                        center.y + (Math.random()-0.5)*offset,
                        center.z + (Math.random()-0.5)*offset
                    );
                    // Clamp
                    pos.x = Math.max(-HALF_BOX, Math.min(HALF_BOX, pos.x));
                    pos.y = Math.max(-HALF_BOX, Math.min(HALF_BOX, pos.y));
                    pos.z = Math.max(-HALF_BOX, Math.min(HALF_BOX, pos.z));
                } else {
                    pos = new THREE.Vector3(getRandomPos(), getRandomPos(), getRandomPos());
                }
                addPoint(pos);
            }
        }

        function resetCentroids(clear = true) {
            centroids = [];
            centroidGroup.clear();
            voronoiGroup.clear();
            if(clear) {
                points.forEach(p => {
                    p.cluster = null;
                    p.mesh.material.color.setHex(greyColor);
                });
                lineGroup.clear();
            }
            algorithmState = 'assign';
            updateButtonStates();
        }

        function addCentroid(pos, clusterIndex) {
            const geometry = new THREE.OctahedronGeometry(3); // –Ü–Ω—à–∞ —Ñ–æ—Ä–º–∞
            const material = new THREE.MeshStandardMaterial({ 
                color: colorsTHREE[clusterIndex], 
                wireframe: true, 
                wireframeLinewidth: 2 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            centroidGroup.add(mesh);
            centroids.push({ pos, mesh });
        }

        function updatePointColors() {
            for (const point of points) {
                const color = (point.cluster !== null) ? colorsTHREE[point.cluster] : greyColor;
                point.mesh.material.color.setHex(color);
            }
        }

        function updateCentroidPositions() {
            for (let i = 0; i < centroids.length; i++) {
                centroids[i].mesh.position.copy(centroids[i].pos);
            }
        }

        function drawLines() {
            lineGroup.clear();
            if (!chkLines.checked) return;

            for (const point of points) {
                if (point.cluster === null) continue;
                const p1 = point.pos;
                const p2 = centroids[point.cluster].pos;
                const color = colorsTHREE[point.cluster];
                
                const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
                let pointsForLine = [];

                if (currentMetric === 'manhattan') {
                    // –ú–∞–Ω—Ö–µ—Ç—Ç–µ–Ω 3D: p1 -> (x2, y1, z1) -> (x2, y2, z1) -> p2
                    pointsForLine.push(p1.clone());
                    pointsForLine.push(new THREE.Vector3(p2.x, p1.y, p1.z));
                    pointsForLine.push(new THREE.Vector3(p2.x, p2.y, p1.z));
                    pointsForLine.push(p2.clone());
                } else {
                    pointsForLine.push(p1.clone());
                    pointsForLine.push(p2.clone());
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(pointsForLine);
                const line = new THREE.Line(geometry, material);
                lineGroup.add(line);
            }
        }

        // –§—É–Ω–∫—Ü—ñ—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–∑—É–∞–ª—å–Ω–æ—ó –ø–ª–æ—â–∏–Ω–∏ –¥–ª—è –í–æ—Ä–æ–Ω–æ–≥–æ
        function createVisualPlane(p1, p2, color, clipPlanes) {
             // –ù–æ—Ä–º–∞–ª—å –¥–æ –ø–ª–æ—â–∏–Ω–∏ - –≤–µ–∫—Ç–æ—Ä –º—ñ–∂ —Ü–µ–Ω—Ç—Ä–∞–º–∏
            const normal = new THREE.Vector3().subVectors(p2, p1).normalize();
            // –°–µ—Ä–µ–¥–Ω—è —Ç–æ—á–∫–∞
            const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –ø–ª–æ—â–∏–Ω–∏
            const constant = -normal.dot(midPoint);
            
            const plane = new THREE.Plane(normal, constant);
            
            // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è: –≤–µ–ª–∏–∫–∞ –ø–ª–æ—â–∏–Ω–∞, —è–∫—É –º–∏ –æ–±—Ä—ñ–∑–∞—î–º–æ
            // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ Stencil –∞–±–æ –ø—Ä–æ—Å—Ç–æ Clipping planes
            // –¢—É—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ clipping planes —Å—Ü–µ–Ω–∏ + –Ω–∞—à—É –ø–ª–æ—â–∏–Ω—É –¥–ª—è —Å—É—Å—ñ–¥–∞?
            // –ù—ñ, –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó –º–µ–∂—ñ –º—ñ–∂ 2 —Ç–æ—á–∫–∞–º–∏ —Ü–µ –ø—Ä–æ—Å—Ç–æ –ø–ª–æ—â–∏–Ω–∞, –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–∞ –≤—ñ–¥—Ä—ñ–∑–∫—É.
            
            const geom = new THREE.PlaneGeometry(BOX_SIZE*3, BOX_SIZE*3);
            const mat = new THREE.MeshBasicMaterial({
                color: color, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.2,
                clippingPlanes: [...clippingPlanes] // –û–±—Ä—ñ–∑–∞—î–º–æ –º–µ–∂–∞–º–∏ –∫—É–±–∞
            });
            const mesh = new THREE.Mesh(geom, mat);
            
            // –û—Ä—ñ—î–Ω—Ç—É—î–º–æ
            mesh.lookAt(normal);
            mesh.position.copy(midPoint);
            
            return mesh;
        }

        function drawVoronoi() {
            voronoiGroup.clear();
            if (!chkVoronoi.checked || currentMetric !== 'euclidean') return;

            // –°–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–ª—è K=2 —Ç–∞ K=3 –¥–ª—è –Ω–∞–æ—á–Ω–æ—Å—Ç—ñ, 
            // –ø–æ–≤–Ω–∞ 3D –¥—ñ–∞–≥—Ä–∞–º–∞ –í–æ—Ä–æ–Ω–æ–≥–æ —Å–∫–ª–∞–¥–Ω–∞ –¥–ª—è —Ä–µ–Ω–¥–µ—Ä—É mesh'–∞–º–∏ –≤ JS
            if (k === 2 && centroids.length === 2) {
                const mesh = createVisualPlane(centroids[0].pos, centroids[1].pos, 0x000000, clippingPlanes);
                voronoiGroup.add(mesh);
            } 
            else if (k === 3 && centroids.length === 3) {
                // –î–ª—è 3 —Ç–æ—á–æ–∫: –∑–Ω–∞—Ö–æ–¥–∏–º–æ —Å–ø—ñ–ª—å–Ω—É –ª—ñ–Ω—ñ—é –ø–µ—Ä–µ—Ç–∏–Ω—É –ø–ª–æ—â–∏–Ω –±—ñ—Å–µ–∫—Ç—Ä–∏—Å
                // –¶–µ —Å–∫–ª–∞–¥–Ω—ñ—à–µ, —Ç–æ–º—É –ø—Ä–æ—Å—Ç–æ –º–∞–ª—é—î–º–æ 3 –±—ñ—Å–µ–∫—Ç—Ä–∏—Å–∏ –ø–æ–ø–∞—Ä–Ω–æ, 
                // –∞–ª–µ –≤—ñ–∑—É–∞–ª—å–Ω–æ —Ü–µ –º–æ–∂–µ –≤–∏–≥–ª—è–¥–∞—Ç–∏ —è–∫ –∫–∞—à–∞.
                // –°–ø—Ä–æ–±—É—î–º–æ –Ω–∞–º–∞–ª—é–≤–∞—Ç–∏ –ø–ª–æ—â–∏–Ω—É –º—ñ–∂ 0-1, 1-2, 2-0
                const pairs = [[0,1], [1,2], [2,0]];
                pairs.forEach(pair => {
                     // –î–æ–¥–∞—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π clipping plane, —â–æ–± –≤—ñ–¥—Å—ñ–∫—Ç–∏ "–∑–∞–π–≤–µ" –∑ –±–æ–∫—É 3-–≥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞?
                     // –¶–µ —Å–∫–ª–∞–¥–Ω–æ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –¥–∏–Ω–∞–º—ñ—á–Ω–æ –±–µ–∑ CSG.
                     // –¢–æ–º—É –ø—Ä–æ—Å—Ç–æ –º–∞–ª—é—î–º–æ –ø–ª–æ—â–∏–Ω–∏ "—è–∫ —î", –≤–æ–Ω–∏ –±—É–¥—É—Ç—å –ø–µ—Ä–µ—Ç–∏–Ω–∞—Ç–∏—Å—è.
                     const mesh = createVisualPlane(
                         centroids[pair[0]].pos, 
                         centroids[pair[1]].pos, 
                         0x000000, 
                         clippingPlanes
                     );
                     voronoiGroup.add(mesh);
                });
            }
        }

        // –ê–ª–≥–æ—Ä–∏—Ç–º
        function distance(p1, p2) {
            if (currentMetric === 'manhattan') {
                return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) + Math.abs(p1.z - p2.z);
            }
            return p1.distanceTo(p2);
        }

        function findNearestCentroid(pointPos) {
            let minDistance = Infinity;
            let bestCluster = -1;
            for (let i = 0; i < centroids.length; i++) {
                const dist = distance(pointPos, centroids[i].pos);
                if (dist < minDistance) {
                    minDistance = dist;
                    bestCluster = i;
                }
            }
            return bestCluster;
        }

        function assignPointsToClusters() {
            if (centroids.length === 0) return false;
            let changed = false;
            for (const point of points) {
                const bestCluster = findNearestCentroid(point.pos);
                if (point.cluster !== bestCluster) {
                    point.cluster = bestCluster;
                    changed = true;
                }
            }
            algorithmState = 'update';
            return changed;
        }

        function updateCentroidsStep() {
            if (centroids.length === 0) return;
            const clusterSums = Array(k).fill(0).map(() => new THREE.Vector3(0, 0, 0));
            const clusterCounts = Array(k).fill(0);
            
            for (const point of points) {
                if (point.cluster !== null) {
                    clusterSums[point.cluster].add(point.pos);
                    clusterCounts[point.cluster]++;
                }
            }

            for (let i = 0; i < k; i++) {
                if (clusterCounts[i] > 0) {
                    centroids[i].pos.copy(clusterSums[i].divideScalar(clusterCounts[i]));
                } else {
                    centroids[i].pos.set(getRandomPos(), getRandomPos(), getRandomPos());
                }
            }
            algorithmState = 'assign';
            updateCentroidPositions();
            drawVoronoi();
        }

        // --- UI Handlers ---
        function updateButtonStates() {
            const hasCentroids = centroids.length > 0;
            btnStep.disabled = !hasCentroids || settingCentroids;
            btnRun.disabled = !hasCentroids || settingCentroids;
            
            if (settingCentroids) {
                btnManualCentroids.textContent = `–í—Å—Ç–∞–Ω–æ–≤—ñ—Ç—å —Ü–µ–Ω—Ç—Ä ${centroids.length + 1}/${k}`;
                btnManualCentroids.disabled = true;
            } else {
                btnManualCentroids.textContent = '–ó–∞–¥–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä–∏ –≤—Ä—É—á–Ω—É';
                btnManualCentroids.disabled = false;
            }
        }
        
        function updateTooltipLocal() {
            if (settingCentroids) {
                tooltip.textContent = `–ö–ª—ñ–∫–Ω—ñ—Ç—å –Ω–∞ '–ø—ñ–¥–ª–æ–≥—É' (Z=0), —â–æ–± –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —Ü–µ–Ω—Ç—Ä ${centroids.length + 1}/${k}`;
            } else {
                tooltip.textContent = '–õ–ö–ú+Drag: –æ–±–µ—Ä—Ç–∞—Ç–∏ | –ü–ö–ú: –ø–∞–Ω–æ—Ä–∞–º—É–≤–∞—Ç–∏ | –õ–ö–ú –Ω–∞ —Ç–æ—á—Ü—ñ: –≤–∏–¥–∞–ª–∏—Ç–∏?';
            }
        }

        // Listeners
        kInput.addEventListener('change', () => {
            k = parseInt(kInput.value);
            if(k > 10) k = 10;
            resetCentroids();
        });

        metricSelect.addEventListener('change', (e) => {
            currentMetric = e.target.value;
            if(currentMetric !== 'euclidean') {
                chkVoronoi.checked = false;
                voronoiGroup.clear();
            }
            if (centroids.length > 0) {
                assignPointsToClusters();
                updatePointColors();
                drawLines();
            }
        });

        btnGenPoints.addEventListener('click', () => {
            generateData(30);
            resetCentroids();
        });

        btnRandomCentroids.addEventListener('click', () => {
            settingCentroids = false;
            resetCentroids();
            for (let i = 0; i < k; i++) {
                const pos = new THREE.Vector3(getRandomPos(), getRandomPos(), getRandomPos());
                addCentroid(pos, i);
            }
            assignPointsToClusters(); // Initial assign
            updatePointColors();
            drawLines();
            drawVoronoi();
            updateButtonStates();
        });

        btnManualCentroids.addEventListener('click', () => {
            settingCentroids = true;
            resetCentroids();
            updateButtonStates();
            updateTooltipLocal();
        });

        btnStep.addEventListener('click', () => {
            if (algorithmState === 'assign') {
                assignPointsToClusters();
                updatePointColors();
                drawLines();
            } else {
                updateCentroidsStep();
                drawLines();
            }
        });

        btnRun.addEventListener('click', () => {
             if (runInterval) {
                clearInterval(runInterval);
                runInterval = null;
                btnRun.textContent = '–ó–∞–ø—É—Å—Ç–∏—Ç–∏';
            } else {
                btnRun.textContent = '–ó—É–ø–∏–Ω–∏—Ç–∏';
                runInterval = setInterval(() => {
                    if (algorithmState === 'assign') {
                        const changed = assignPointsToClusters();
                        updatePointColors();
                        drawLines();
                        if (!changed) {
                            clearInterval(runInterval);
                            runInterval = null;
                            btnRun.textContent = '–ó–∞–ø—É—Å—Ç–∏—Ç–∏';
                        }
                    } else {
                        updateCentroidsStep();
                        drawLines();
                    }
                }, 500);
            }
        });

        btnReset.addEventListener('click', () => {
            if(runInterval) clearInterval(runInterval);
            runInterval = null;
            resetCentroids();
            points = [];
            pointGroup.clear();
            lineGroup.clear();
            settingCentroids = false;
            btnRun.textContent = '–ó–∞–ø—É—Å—Ç–∏—Ç–∏';
            updateButtonStates();
        });

        chkLines.addEventListener('change', drawLines);
        chkVoronoi.addEventListener('change', drawVoronoi);

        // Mouse Interaction
        function onMouseDown(event) {
            if (event.button !== 0) return; // Only left click

            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (settingCentroids) {
                // Raycast to invisible plane
                const intersects = raycaster.intersectObject(invisiblePlane);
                if (intersects.length > 0) {
                    const pos = intersects[0].point;
                    addCentroid(pos, centroids.length);
                    
                    if (centroids.length === k) {
                        settingCentroids = false;
                        assignPointsToClusters();
                        updatePointColors();
                        drawVoronoi();
                    }
                    updateButtonStates();
                    updateTooltipLocal();
                }
            }
            // Manual delete point? (optional, not implemented in detail to avoid conflict with rotate)
        }

        function onWindowResize() {
            // –¶—è —Ñ—É–Ω–∫—Ü—ñ—è –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–∏ —Ä–µ—Å–∞–π–∑—ñ –≤—ñ–∫–Ω–∞
            // –ê–ë–û –≤—Ä—É—á–Ω—É –ø—Ä–∏ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—ñ –≤–∫–ª–∞–¥–∫–∏
            if (!container || container.clientWidth === 0) return;
            
            const aspect = container.clientWidth / container.clientHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
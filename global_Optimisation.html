<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Global Optimization Simulator (Ultimate Edition)</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
        }
      }
    </script>
    
    <script>
      window.MathJax = {
        tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <style>
        :root { 
            --bg: #121212; --panel: #1e1e1e; --accent: #2196f3; 
            --text: #e0e0e0; --danger: #e74c3c; --success: #2ecc71; 
            --warning: #f1c40f; --info: #9b59b6;
        }
        body { 
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; margin: 0; 
            background-color: var(--bg); color: var(--text); 
            overflow: hidden; display: flex; height: 100vh;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 400px; background: var(--panel); 
            display: flex; flex-direction: column;
            box-shadow: 4px 0 15px rgba(0,0,0,0.6); z-index: 10;
            border-right: 1px solid #333;
        }
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .fixed-bottom { padding: 15px; background: #181818; border-top: 1px solid #333; }

        h2 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent); text-transform: uppercase; border-bottom: 2px solid #333; padding-bottom: 5px; }
        h3 { margin: 15px 0 5px 0; font-size: 0.95rem; color: #ccc; border-left: 3px solid var(--accent); padding-left: 8px; background: rgba(255,255,255,0.05); }

        .control-group { margin-bottom: 12px; }
        label { font-size: 0.85rem; display: flex; justify-content: space-between; margin-bottom: 2px; color: #aaa; align-items: center; }
        
        input[type="number"], select { 
            background: #2c2c2c; border: 1px solid #444; color: white; 
            border-radius: 4px; padding: 3px 6px; width: 70px; text-align: right;
        }
        select { width: 100%; margin-bottom: 5px; }
        input[type="range"] { width: 100%; margin: 5px 0; accent-color: var(--accent); cursor: pointer; }

        /* Method Tabs */
        .method-tabs { display: flex; gap: 2px; margin-bottom: 15px; background: #111; padding: 3px; border-radius: 6px; }
        .tab-btn {
            flex: 1; padding: 10px; background: transparent; border: none; color: #666;
            cursor: pointer; font-weight: bold; font-size: 0.8rem; border-radius: 4px;
            transition: 0.2s;
        }
        .tab-btn.active { background: var(--accent); color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .tab-btn:hover:not(.active) { background: #333; color: #ddd; }

        .settings-panel { display: none; }
        .settings-panel.active { display: block; animation: fadeIn 0.3s; }

        /* Buttons */
        .btn-row { display: flex; gap: 8px; margin-top: 5px; }
        .btn {
            flex: 1; border: none; border-radius: 4px; cursor: pointer;
            font-weight: bold; text-transform: uppercase; padding: 10px 0;
            color: white; font-size: 0.75rem; transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .btn-primary { background: var(--accent); }
        .btn-danger { background: var(--danger); }
        .btn-theory { background: var(--warning); color: #222; }
        .btn:hover { filter: brightness(1.15); transform: translateY(-1px); }
        .btn:active { transform: translateY(1px); }
        .btn:disabled { background: #333; color: #666; cursor: not-allowed; transform: none; }

        /* Legend */
        .legend-box { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; margin-top: 10px; border: 1px solid #333; }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 0.8rem; margin-top: 4px; color: #ccc; }
        .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; box-shadow: 0 0 3px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); }

        /* 3D Canvas */
        #scene-container { flex: 1; position: relative; background: #000; overflow: hidden; }
        #info-overlay {
            position: absolute; top: 15px; left: 15px; pointer-events: none;
            color: rgba(255,255,255,0.7); font-family: 'Consolas', monospace; font-size: 0.9rem;
            background: rgba(0,0,0,0.6); padding: 12px; border-radius: 6px; backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .val-highlight { color: var(--success); font-weight: bold; font-size: 1.1em; }

        /* Modal (Theory) */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 2000;
            justify-content: center; align-items: center; backdrop-filter: blur(5px);
        }
        .modal-content {
            background: #1e1e1e; width: 85%; max-width: 900px; max-height: 90vh;
            border-radius: 8px; border: 1px solid #444; display: flex; flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        .modal-header {
            padding: 15px 25px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; background: #252525;
        }
        .modal-title { font-size: 1.2rem; color: var(--warning); font-weight: bold; }
        .close-btn { background: none; border: none; color: #888; font-size: 1.8rem; cursor: pointer; transition: 0.2s; }
        .close-btn:hover { color: white; }
        .modal-body { padding: 30px; overflow-y: auto; color: #ddd; line-height: 1.7; font-size: 1rem; }
        
        .math-block { background: rgba(0,0,0,0.3); padding: 15px; text-align: center; margin: 20px 0; border-radius: 6px; border: 1px solid #333; }
        .concept-box { border-left: 4px solid var(--accent); background: rgba(33, 150, 243, 0.1); padding: 15px; margin: 15px 0; }
        strong { color: white; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="scroll-area">
        <h2>–ì–ª–æ–±–∞–ª—å–Ω–∞ –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è</h2>

        <h3>1. –ú–µ—Ç–æ–¥ (–ê–ª–≥–æ—Ä–∏—Ç–º)</h3>
        <div class="method-tabs">
            <button class="tab-btn active" onclick="setMethod('pso')" id="btn-pso">–†—ñ–π (PSO)</button>
            <button class="tab-btn" onclick="setMethod('sa')" id="btn-sa">–í—ñ–¥–ø–∞–ª (SA)</button>
            <button class="tab-btn" onclick="setMethod('ga')" id="btn-ga">–ì–µ–Ω–µ—Ç–∏—á–Ω–∏–π (GA)</button>
        </div>

        <div id="settings-pso" class="settings-panel active">
            <div class="control-group">
                <label>–ö—ñ–ª—å–∫—ñ—Å—Ç—å —á–∞—Å—Ç–∏–Ω–æ–∫ (N): <input type="number" id="psoParticles" value="50" min="5" max="500"></label>
            </div>
            
            <div class="control-group">
                <label>–Ü–Ω–µ—Ä—Ü—ñ—è (w): <span id="val-psoInertia">0.70</span></label>
                <input type="range" id="psoInertia" min="0" max="1.2" step="0.01" value="0.7" oninput="updateLabel(this)">
                <small style="color:#666">–í–ø–ª–∏–≤ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó —à–≤–∏–¥–∫–æ—Å—Ç—ñ</small>
            </div>
            
            <div class="control-group">
                <label>–ö–æ–≥–Ω—ñ—Ç–∏–≤–Ω–∏–π (c1): <span id="val-psoC1">1.4</span></label>
                <input type="range" id="psoC1" min="0" max="4" step="0.1" value="1.4" oninput="updateLabel(this)">
                <small style="color:#666">–¢—è–≥–∞ –¥–æ –≤–ª–∞—Å–Ω–æ–≥–æ –∫—Ä–∞—â–æ–≥–æ (pBest)</small>
            </div>
            
            <div class="control-group">
                <label>–°–æ—Ü—ñ–∞–ª—å–Ω–∏–π (c2): <span id="val-psoC2">1.4</span></label>
                <input type="range" id="psoC2" min="0" max="4" step="0.1" value="1.4" oninput="updateLabel(this)">
                <small style="color:#666">–¢—è–≥–∞ –¥–æ –ª—ñ–¥–µ—Ä–∞ –∑–≥—Ä–∞—ó (gBest)</small>
            </div>

            <div class="legend-box">
                <div class="legend-item"><span class="dot" style="background:#2196f3; box-shadow: 0 0 5px #2196f3;"></span> –ß–∞—Å—Ç–∏–Ω–∫–∞</div>
                <div class="legend-item"><span class="dot" style="background:rgba(255, 0, 255, 0.5); border-radius:0; width:15px; height:4px;"></span> –†—ñ–≤–µ–Ω—å –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ</div>
            </div>
        </div>

        <div id="settings-sa" class="settings-panel">
            <div class="control-group">
                <label>–ü–æ—á–∞—Ç–∫–æ–≤–∞ –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (T): <input type="number" id="saTemp" value="1000" min="10" max="5000"></label>
            </div>

            <div class="control-group">
                <label>–ö–æ–µ—Ñ. –æ—Ö–æ–ª–æ–¥–∂–µ–Ω–Ω—è (Alpha): <span id="val-saCooling">0.99</span></label>
                <input type="range" id="saCooling" min="0.800" max="0.999" step="0.001" value="0.99" oninput="updateLabel(this)">
                <small style="color:#666">–ß–∏–º –±–ª–∏–∂—á–µ –¥–æ 1, —Ç–∏–º –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ —Ö–æ–ª–æ–Ω–µ</small>
            </div>
            
            <div class="control-group">
                <label>–†–æ–∑–º—ñ—Ä –∫—Ä–æ–∫—É: <span id="val-saStep">1.5</span></label>
                <input type="range" id="saStep" min="0.1" max="5.0" step="0.1" value="1.5" oninput="updateLabel(this)">
            </div>
            
            <div class="legend-box">
                <div class="legend-item"><span class="dot" style="background:#ff9800;"></span> –ü–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω</div>
                <div class="legend-item"><span class="dot" style="background:#2ecc71; box-shadow: 0 0 8px #2ecc71;"></span> –ù–∞–π–∫—Ä–∞—â–∏–π –∑–Ω–∞–π–¥–µ–Ω–∏–π</div>
                <div class="legend-item"><span class="dot" style="background:rgba(255, 0, 255, 0.5); border-radius:0; width:15px; height:4px;"></span> –†—ñ–≤–µ–Ω—å –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ</div>
            </div>
        </div>

        <div id="settings-ga" class="settings-panel">
            <div class="control-group">
                <label>–†–æ–∑–º—ñ—Ä –ø–æ–ø—É–ª—è—Ü—ñ—ó: <input type="number" id="gaPopSize" value="60" min="10" max="300"></label>
            </div>
            
            <div class="control-group">
                <label>–®–∞–Ω—Å –º—É—Ç–∞—Ü—ñ—ó: <span id="val-gaMutation">0.3</span></label>
                <input type="range" id="gaMutation" min="0" max="1" step="0.05" value="0.3" oninput="updateLabel(this)">
            </div>
            
            <div class="control-group">
                <label>–°–∏–ª–∞ –º—É—Ç–∞—Ü—ñ—ó: <span id="val-gaMutPower">4</span></label>
                <input type="range" id="gaMutPower" min="0.1" max="6" step="0.1" value="4" oninput="updateLabel(this)">
            </div>
            
            <div class="control-group">
                <label>–†–æ–∑–º—ñ—Ä —Ç—É—Ä–Ω—ñ—Ä—É (Selection): <input type="number" id="gaTournament" value="4" min="2" max="10"></label>
            </div>

            <div class="control-group">
                <label>–ï–ª—ñ—Ç–∞—Ä–∏–∑–º (–ó–±–µ—Ä–µ–≥—Ç–∏ –Ω–∞–π–∫—Ä–∞—â–∏—Ö): <input type="number" id="gaElites" value="2" min="0" max="10"></label>
            </div>

            <div class="legend-box">
                <div class="legend-item"><span class="dot" style="background:#2ecc71;"></span> <b>–ï–ª—ñ—Ç–∞</b> (–í–∏–∂–∏–≤–∞—é—Ç—å)</div>
                <div class="legend-item"><span class="dot" style="background:#f1c40f;"></span> <b>–°—Ç–∞–Ω–¥–∞—Ä—Ç</b></div>
                <div class="legend-item"><span class="dot" style="background:#e74c3c;"></span> <b>–ì—ñ—Ä—à—ñ</b> (–í –∑–æ–Ω—ñ —Ä–∏–∑–∏–∫—É)</div>
                <hr style="border:0; border-top:1px solid #444; margin:5px 0;">
                <div class="legend-item"><span class="dot" style="background:rgba(255, 0, 255, 0.5); border-radius:0; width:15px; height:4px;"></span> –†—ñ–≤–µ–Ω—å —Ä–µ–∫–æ—Ä–¥—É (Best)</div>
                <div class="legend-item"><span class="dot" style="background:rgba(255, 0, 0, 0.4); border-radius:0; width:15px; height:4px;"></span> <b>–†—ñ–≤–µ–Ω—å –≤–∏–∂–∏–≤–∞–Ω–Ω—è</b></div>
            </div>
        </div>

        <h3>2. –§—É–Ω–∫—Ü—ñ—è (–õ–∞–Ω–¥—à–∞—Ñ—Ç)</h3>
        <select id="funcSelect" onchange="changeFunction()">
           <option value="random">1. –í–∏–ø–∞–¥–∫–æ–≤–∏–π –õ–∞–Ω–¥—à–∞—Ñ—Ç (Spline)</option>
		   <option value="complex">2. –°–∫–ª–∞–¥–Ω–∞ (Rastrigin Modified)</option>
			
            <option value="ackley">3. Ackley (–ë–∞–≥–∞—Ç–æ –ª–æ–∫–∞–ª—å–Ω–∏—Ö –º—ñ–Ω—ñ–º—É–º—ñ–≤)</option>
           
        </select>
        
        <h3>3. –ö–æ–Ω—Ç—Ä–æ–ª—å –ß–∞—Å—É</h3>
        <div class="control-group">
            <label>–®–≤–∏–¥–∫—ñ—Å—Ç—å (Slow <-> Fast)</label>
            <input type="range" id="simSpeed" min="1" max="20" value="10" oninput="updateLabel(this)">
            <span id="val-simSpeed" style="display:none"></span>
        </div>

        <div class="control-group">
            <label>–ú–∞—Å—à—Ç–∞–± –í–∏—Å–æ—Ç–∏ (Visual):</label>
            <input type="range" id="vScaleSlider" min="0.1" max="3.0" step="0.1" value="0.5" oninput="updateVisualScale()">
        </div>

    </div>

    <div class="fixed-bottom">
        <div style="margin-bottom: 10px; font-size: 0.8rem; color: #888; display: flex; justify-content: space-between;">
            <span>–°—Ç–∞—Ç—É—Å: <b id="status-text" style="color: white;">–ì–û–¢–û–í–û</b></span>
            <span>–†–µ–∂–∏–º: <b id="mode-text" style="color: var(--accent);">–ê–í–¢–û</b></span>
        </div>
        <div class="btn-row">
            <button class="btn btn-theory" onclick="openModal()">üìñ –¢–µ–æ—Ä—ñ—è</button>
            <button class="btn btn-primary" onclick="togglePlay()" id="btn-play">Pause</button>
            <button class="btn btn-primary" style="background: #444;" onclick="step()" id="btn-step" disabled>Step</button>
            <button class="btn btn-danger" onclick="resetSim()">Reset</button>
        </div>
    </div>
</div>

<div id="scene-container">
    <div id="info-overlay">
        <div><b>Global Best (Z):</b> <span id="gbest-val" class="val-highlight">--</span></div>
        <div style="font-size: 0.8em; color: #aaa; margin-top: 5px;">–õ–ö–ú: –û–±–µ—Ä—Ç–∞–Ω–Ω—è | –ü–ö–ú: –ó–º—ñ—â–µ–Ω–Ω—è | –ö–æ–ª–µ—Å–æ: –ó—É–º</div>
    </div>
</div>

<div id="theoryModal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">–¢–µ–æ—Ä—ñ—è –ì–ª–æ–±–∞–ª—å–Ω–æ—ó –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó</div>
            <button class="close-btn" onclick="closeModal()">√ó</button>
        </div>
        <div class="modal-body">
            
            <div class="concept-box">
                <p><b>–ì–ª–æ–±–∞–ª—å–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è</b> ‚Äî —Ü–µ –ø–æ—à—É–∫ "–Ω–∞–π–≥–ª–∏–±—à–æ—ó —è–º–∏" (–≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –º—ñ–Ω—ñ–º—É–º—É) –Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ–π –ø–æ–≤–µ—Ä—Ö–Ω—ñ, —è–∫–∞ –º–∞—î –±–∞–≥–∞—Ç–æ "—Ñ–∞–ª—å—à–∏–≤–∏—Ö —è–º" (–ª–æ–∫–∞–ª—å–Ω–∏—Ö –º—ñ–Ω—ñ–º—É–º—ñ–≤). –ö–ª–∞—Å–∏—á–Ω—ñ –º–µ—Ç–æ–¥–∏ (–≥—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫) —á–∞—Å—Ç–æ –∑–∞—Å—Ç—Ä—è–≥–∞—é—Ç—å —É –Ω–∞–π–±–ª–∏–∂—á—ñ–π —è–º—ñ. –ï–≤–æ–ª—é—Ü—ñ–π–Ω—ñ —Ç–∞ —Ä–æ–π–æ–≤—ñ –º–µ—Ç–æ–¥–∏ –Ω–∞–º–∞–≥–∞—é—Ç—å—Å—è –¥–æ—Å–ª—ñ–¥–∏—Ç–∏ –≤—Å—é –ø–æ–≤–µ—Ä—Ö–Ω—é.</p>
            </div>

            <h3>1. –ú–µ—Ç–æ–¥ –†–æ—é –ß–∞—Å—Ç–∏–Ω–æ–∫ (PSO - Particle Swarm Optimization)</h3>
            <p>–¶–µ–π –º–µ—Ç–æ–¥ –Ω–∞—Ç—Ö–Ω–µ–Ω–Ω–∏–π —Å–æ—Ü—ñ–∞–ª—å–Ω–æ—é –ø–æ–≤–µ–¥—ñ–Ω–∫–æ—é –∑–≥—Ä–∞–π –ø—Ç–∞—Ö—ñ–≤ –∞–±–æ –∫–æ—Å—è–∫—ñ–≤ —Ä–∏–±. –ú–∏ –∑–∞–ø—É—Å–∫–∞—î–º–æ "—Ä—ñ–π" —á–∞—Å—Ç–∏–Ω–æ–∫, —è–∫—ñ –ª—ñ—Ç–∞—é—Ç—å –Ω–∞–¥ –ª–∞–Ω–¥—à–∞—Ñ—Ç–æ–º.</p>
            <ul>
                <li>–ö–æ–∂–Ω–∞ —á–∞—Å—Ç–∏–Ω–∫–∞ –ø–∞–º'—è—Ç–∞—î —Å–≤–æ—î –æ—Å–æ–±–∏—Å—Ç–µ –Ω–∞–π–∫—Ä–∞—â–µ –∑–Ω–∞–π–¥–µ–Ω–µ –º—ñ—Å—Ü–µ ($p_{best}$).</li>
                <li>–í—Å—ñ —á–∞—Å—Ç–∏–Ω–∫–∏ –∑–Ω–∞—é—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–µ –Ω–∞–π–∫—Ä–∞—â–µ –º—ñ—Å—Ü–µ, –∑–Ω–∞–π–¥–µ–Ω–µ –±—É–¥—å-–∫–∏–º —ñ–∑ –∑–≥—Ä–∞—ó ($g_{best}$).</li>
                <li>–®–≤–∏–¥–∫—ñ—Å—Ç—å —á–∞—Å—Ç–∏–Ω–∫–∏ –∫–æ—Ä–∏–≥—É—î—Ç—å—Å—è –Ω–∞ –∫–æ–∂–Ω–æ–º—É –∫—Ä–æ—Ü—ñ, –ø—Ä–∏—Ç—è–≥—É—é—á–∏—Å—å –¥–æ —Ü–∏—Ö –¥–≤–æ—Ö —Ç–æ—á–æ–∫.</li>
            </ul>
            <div class="math-block">
                $$ v_{t+1} = w \cdot v_{t} + c_1 r_1 (p_{best} - x_{t}) + c_2 r_2 (g_{best} - x_{t}) $$
                $$ x_{t+1} = x_{t} + v_{t+1} $$
            </div>
            <p>–î–µ $w$ ‚Äî <b>—ñ–Ω–µ—Ä—Ü—ñ—è</b> (—è–∫ –≤–∞–∂–∫–æ –ø—Ç–∞—Ö—É –∑–º—ñ–Ω–∏—Ç–∏ –∫—É—Ä—Å), $c_1$ ‚Äî <b>–∫–æ–≥–Ω—ñ—Ç–∏–≤–Ω–∏–π –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç</b> (–¥–æ–≤—ñ—Ä–∞ —Å–æ–±—ñ), $c_2$ ‚Äî <b>—Å–æ—Ü—ñ–∞–ª—å–Ω–∏–π –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç</b> (–¥–æ–≤—ñ—Ä–∞ –∑–≥—Ä–∞—ó).</p>

            <h3>2. –Ü–º—ñ—Ç–∞—Ü—ñ—è –í—ñ–¥–ø–∞–ª—É (SA - Simulated Annealing)</h3>
            <p>–ú–µ—Ç–æ–¥ –Ω–∞—Ç—Ö–Ω–µ–Ω–Ω–∏–π –ø—Ä–æ—Ü–µ—Å–æ–º –≤—ñ–¥–ø–∞–ª—É –≤ –º–µ—Ç–∞–ª—É—Ä–≥—ñ—ó. –ö–æ–ª–∏ –º–µ—Ç–∞–ª –≥–∞—Ä—è—á–∏–π, –∞—Ç–æ–º–∏ —Ä—É—Ö–∞—é—Ç—å—Å—è —Ö–∞–æ—Ç–∏—á–Ω–æ (–≤–∏—Å–æ–∫–∞ –µ–Ω–µ—Ä–≥—ñ—è). –ö–æ–ª–∏ –≤—ñ–Ω —Ö–æ–ª–æ–Ω–µ, –∞—Ç–æ–º–∏ —à–∏–∫—É—é—Ç—å—Å—è –≤ –∫—Ä–∏—Å—Ç–∞–ª—ñ—á–Ω—É —Ä–µ—à—ñ—Ç–∫—É (–º—ñ–Ω—ñ–º—É–º –µ–Ω–µ—Ä–≥—ñ—ó).</p>
            <ul>
                <li>–ê–≥–µ–Ω—Ç –±–ª—É–∫–∞—î –≤–∏–ø–∞–¥–∫–æ–≤–æ.</li>
                <li>–Ø–∫—â–æ –≤—ñ–Ω –∑–Ω–∞—Ö–æ–¥–∏—Ç—å –∫—Ä–∞—â—É —Ç–æ—á–∫—É ‚Äî –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å —Ç—É–¥–∏.</li>
                <li>–Ø–∫—â–æ –≤—ñ–Ω –∑–Ω–∞—Ö–æ–¥–∏—Ç—å <b>–≥—ñ—Ä—à—É</b> —Ç–æ—á–∫—É ‚Äî –≤—ñ–Ω –≤—Å–µ –æ–¥–Ω–æ –º–æ–∂–µ —Ç—É–¥–∏ –ø–µ—Ä–µ–π—Ç–∏, –∞–ª–µ –∑ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—é $P$, —è–∫–∞ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∏ $T$.</li>
            </ul>
            <div class="math-block">
                $$ P = \exp\left( \frac{-\Delta E}{T} \right) $$
            </div>
            <p>–°–ø–æ—á–∞—Ç–∫—É $T$ –≤–∏—Å–æ–∫–∞ (–º–∏ –º–æ–∂–µ–º–æ –≤–∏—Å—Ç—Ä–∏–±–Ω—É—Ç–∏ –∑ –±—É–¥—å-—è–∫–æ—ó —è–º–∏), –ø–æ—Ç—ñ–º $T$ –ø–∞–¥–∞—î (–º–∏ –æ—Å—ñ–¥–∞—î–º–æ –Ω–∞ –¥–Ω—ñ).</p>

            <h3>3. –ì–µ–Ω–µ—Ç–∏—á–Ω–∏–π –ê–ª–≥–æ—Ä–∏—Ç–º (GA)</h3>
            <p>–°–∏–º—É–ª—è—Ü—ñ—è –ø—Ä–∏—Ä–æ–¥–Ω–æ–≥–æ –≤—ñ–¥–±–æ—Ä—É –î–∞—Ä–≤—ñ–Ω–∞. –£ –Ω–∞—Å —î –ø–æ–ø—É–ª—è—Ü—ñ—è —Ä—ñ—à–µ–Ω—å ("—Ö—Ä–æ–º–æ—Å–æ–º").</p>
            <ul>
                <li><b>–°–µ–ª–µ–∫—Ü—ñ—è (Selection):</b> –û–±–∏—Ä–∞—î–º–æ –±–∞—Ç—å–∫—ñ–≤. –ö—Ä–∞—â—ñ —Ä—ñ—à–µ–Ω–Ω—è –º–∞—é—Ç—å –±—ñ–ª—å—à–µ —à–∞–Ω—Å—ñ–≤ —Å—Ç–∞—Ç–∏ –±–∞—Ç—å–∫–∞–º–∏ (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è "—Ç—É—Ä–Ω—ñ—Ä–Ω–∏–π –≤—ñ–¥–±—ñ—Ä").</li>
                <li><b>–ö—Ä–æ—Å–∏–Ω–≥–æ–≤–µ—Ä (Crossover):</b> –ë–∞—Ç—å–∫–∏ –æ–±–º—ñ–Ω—é—é—Ç—å—Å—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏, —Å—Ç–≤–æ—Ä—é—é—á–∏ –Ω–∞—â–∞–¥–∫–∞ (—Å—É–º—ñ—à –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π).</li>
                <li><b>–ú—É—Ç–∞—Ü—ñ—è (Mutation):</b> –í–∏–ø–∞–¥–∫–æ–≤–∞ –∑–º—ñ–Ω–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞—â–∞–¥–∫–∞. –¶–µ –¥–æ–¥–∞—î —Ä—ñ–∑–Ω–æ–º–∞–Ω—ñ—Ç—Ç—è —ñ –¥–æ–∑–≤–æ–ª—è—î –∑–Ω–∞—Ö–æ–¥–∏—Ç–∏ –Ω–æ–≤—ñ –æ–±–ª–∞—Å—Ç—ñ.</li>
                <li><b>–ï–ª—ñ—Ç–∞—Ä–∏–∑–º:</b> –ù–∞–π–∫—Ä–∞—â—ñ –æ—Å–æ–±–∏–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–Ω–æ—Å—è—Ç—å—Å—è –≤ –Ω–∞—Å—Ç—É–ø–Ω–µ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è.</li>
                <li><b>–†—ñ–≤–µ–Ω—å –≤–∏–∂–∏–≤–∞–Ω–Ω—è:</b> –û—Å–æ–±–∏–Ω–∏, —â–æ –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è "–≤–∏—â–µ" (–Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É) –ø–µ–≤–Ω–æ—ó –º–µ–∂—ñ, –≤–≤–∞–∂–∞—é—Ç—å—Å—è —Å–ª–∞–±–∫–∏–º–∏ —ñ –∑–∞–º—ñ–Ω—é—é—Ç—å—Å—è.</li>
            </ul>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // === GLOBAL CONFIGURATION ===
    const STATE = {
        method: 'pso',
        func: 'random',
        isAuto: true,
        isPlaying: true,
        visualScale: 0.5,
        range: 6, // Simulation boundary [-6, 6]
        maxStepsPerFrame: 1
    };

    // === THREE.JS VARIABLES ===
    let scene, camera, renderer, controls;
    let surfaceMesh, wireframeMesh;
    let bestPlane;    // Shows the best Z found (Magenta)
    let survivalPlane; // Shows the "cutoff" Z for GA (Red)
    let markers = []; // Agent visuals
    let bestMarker;   // Specifically for SA/Single best visualization
    let gBestVal = Infinity; // Global best value (Z height)
    let survivalZ = Infinity; // For GA visuals

    // === ALGORITHM DATA ===
    let particles = []; // PSO Data
    let saState = {};   // SA Data
    let gaPop = [];     // GA Data
    let randomHills = []; // Random Landscape Data

    // ==========================================
    // 1. MATH & LANDSCAPE FUNCTIONS
    // ==========================================

    function calculateSpline(points) {
        const n = points.length - 1;
        const a = [], b = [], c = [], d = [], h = [], alpha = [];
        const l = [], mu = [], z = [];

        for (let i = 0; i < n; i++) h[i] = points[i + 1].p - points[i].p;
        for (let i = 1; i < n; i++) {
            alpha[i] = (3 / h[i]) * (points[i + 1].val - points[i].val) - (3 / h[i - 1]) * (points[i].val - points[i - 1].val);
        }

        l[0] = 1; mu[0] = 0; z[0] = 0;
        for (let i = 1; i < n; i++) {
            l[i] = 2 * (points[i + 1].p - points[i - 1].p) - h[i - 1] * mu[i - 1];
            mu[i] = h[i] / l[i];
            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
        }
        l[n] = 1; z[n] = 0; c[n] = 0;

        for (let j = n - 1; j >= 0; j--) {
            c[j] = z[j] - mu[j] * c[j + 1];
            b[j] = (points[j + 1].val - points[j].val) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
            d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            a[j] = points[j].val;
        }

        let coeffs = [];
        for (let i = 0; i < n; i++) {
            coeffs.push({ a: a[i], b: b[i], c: c[i], d: d[i], x: points[i].p });
        }
        return coeffs;
    }

    function evaluateSpline(t, coeffs) {
        if (!coeffs) return 0;
        let seg = 0;
        for (let i = 0; i < coeffs.length; i++) {
            if (t >= coeffs[i].x) seg = i;
        }
        const { a, b, c, d, x } = coeffs[seg];
        const dx = t - x;
        return a + b * dx + c * dx * dx + d * dx * dx * dx;
    }

 function generateSplineData() {
    randomHills = [];
    const numHills = 25; // –ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø–∞–≥–æ—Ä–±—ñ–≤
    
    for(let i=0; i < numHills; i++) {
        randomHills.push({
            x: (Math.random() * 12) - 6, // –í–∏–ø–∞–¥–∫–æ–≤–∞ –ø–æ–∑–∏—Ü—ñ—è X –≤—ñ–¥ -6 –¥–æ 6
            y: (Math.random() * 12) - 6, // –í–∏–ø–∞–¥–∫–æ–≤–∞ –ø–æ–∑–∏—Ü—ñ—è Y –≤—ñ–¥ -6 –¥–æ 6
            h: (Math.random() - 0.5) * 8, // –í–∏—Å–æ—Ç–∞ (–º–æ–∂–µ –±—É—Ç–∏ —è–º–∞, —è–∫—â–æ –≤—ñ–¥'—î–º–Ω–∞)
            s: 0.5 + Math.random() * 1.5  // –®–∏—Ä–∏–Ω–∞ ("—Ç–æ–≤—â–∏–Ω–∞") –ø–∞–≥–æ—Ä–±–∞
        });
    }
}

    const Functions = {
        complex: (x, y) => {
            const z = (x*x + y*y)/20 - Math.cos(x)*Math.cos(y) + Math.sin(x*x/10 + y*y/10);
            return z * 2; 
        },
        ackley: (x, y) => {
            const part1 = -20 * Math.exp(-0.2 * Math.sqrt(0.5 * (x*x + y*y)));
            const part2 = -Math.exp(0.5 * (Math.cos(2*Math.PI*x) + Math.cos(2*Math.PI*y)));
            return (part1 + part2 + 20 + Math.E) * 0.4 - 2; 
        },
      random: (x, y) => {
    let z = 0;
    // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ –≤—Å—ñ—Ö –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–∏—Ö –ø–∞–≥–æ—Ä–±–∞—Ö
    for (let hill of randomHills) {
        // –†–∞—Ö—É—î–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—å –≤—ñ–¥ —Ç–æ—á–∫–∏ (x,y) –¥–æ —Ü–µ–Ω—Ç—Ä—É –ø–∞–≥–æ—Ä–±–∞
        const dx = x - hill.x;
        const dy = y - hill.y;
        const distSq = dx*dx + dy*dy;
        
        // –§–æ—Ä–º—É–ª–∞ –ì–∞—É—Å–∞ (–¥–∑–≤—ñ–Ω): –≤–∏—Å–æ—Ç–∞ * exp(-–≤—ñ–¥—Å—Ç–∞–Ω—å / —à–∏—Ä–∏–Ω—É)
        z += hill.h * Math.exp(-distSq / hill.s);
    }
    return z;
}
    };

    function getZ(x, y) {
        return Functions[STATE.func](x, y);
    }

    // ==========================================
    // 2. THREE.JS SCENE SETUP
    // ==========================================

    function initThree() {
        const container = document.getElementById('scene-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 10, 50);

        // Camera
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(12, 10, 12);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(0x2196f3, 0.5, 20);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // Grid
        const grid = new THREE.GridHelper(30, 30, 0x333333, 0x111111);
        grid.position.y = -3;
        scene.add(grid);

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // 1. BEST Plane (Purple - Record)
        const tGeo = new THREE.PlaneGeometry(12.5, 12.5);
        const tMat = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, 
            transparent: true, 
            opacity: 0.15, 
            side: THREE.DoubleSide,
            depthWrite: false
        });
        bestPlane = new THREE.Mesh(tGeo, tMat);
        bestPlane.rotation.x = -Math.PI/2;
        bestPlane.visible = false;
        scene.add(bestPlane);

        // 2. SURVIVAL Plane (Red - GA cutoff)
        const sMat = new THREE.MeshBasicMaterial({ 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0.15, 
            side: THREE.DoubleSide,
            depthWrite: false
        });
        survivalPlane = new THREE.Mesh(tGeo, sMat);
        survivalPlane.rotation.x = -Math.PI/2;
        survivalPlane.visible = false;
        scene.add(survivalPlane);
    }

    function drawSurface() {
        if(surfaceMesh) {
            scene.remove(surfaceMesh);
            scene.remove(wireframeMesh);
            surfaceMesh.geometry.dispose();
            wireframeMesh.geometry.dispose();
        }

        const segments = 100;
        const range = STATE.range; // 6
        const geo = new THREE.PlaneGeometry(range*2, range*2, segments, segments);
        
        const pos = geo.attributes.position;
        const colors = [];
        
        // Colors for gradient (Height map)
        const cLow = new THREE.Color(0x000033);
        const cMid = new THREE.Color(0x2196f3);
        const cHigh = new THREE.Color(0xffffff);

        let minZ = Infinity, maxZ = -Infinity;

        // 1. Calculate Z and Find Min/Max
        for(let i=0; i < pos.count; i++) {
            const x = pos.getX(i);
            const y = -pos.getY(i); 
            const z = getZ(x, y);
            pos.setZ(i, z * STATE.visualScale);
            if(z < minZ) minZ = z;
            if(z > maxZ) maxZ = z;
        }
        
        geo.computeVertexNormals();

        // 2. Colorize
        for(let i=0; i < pos.count; i++) {
            const zRaw = pos.getZ(i) / STATE.visualScale;
            let t = (zRaw - minZ) / (maxZ - minZ + 0.0001);
            const c = new THREE.Color();
            if(t < 0.5) c.lerpColors(cLow, cMid, t*2);
            else c.lerpColors(cMid, cHigh, (t-0.5)*2);
            colors.push(c.r, c.g, c.b);
        }
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // Material
        const mat = new THREE.MeshStandardMaterial({ 
            vertexColors: true, 
            roughness: 0.3, 
            metalness: 0.1,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.75 
        });

        surfaceMesh = new THREE.Mesh(geo, mat);
        surfaceMesh.rotation.x = -Math.PI / 2; 
        scene.add(surfaceMesh);

        // Wireframe Overlay
        const wireMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, wireframe: true, transparent: true, opacity: 0.08 });
        wireframeMesh = new THREE.Mesh(geo, wireMat);
        wireframeMesh.rotation.x = -Math.PI / 2;
        scene.add(wireframeMesh);
    }

    // ==========================================
    // 3. OPTIMIZATION ALGORITHMS
    // ==========================================

    function resetSim() {
        gBestVal = Infinity;
        survivalZ = Infinity;
        document.getElementById('gbest-val').innerText = "--";
        
        // Remove markers
        markers.forEach(m => scene.remove(m));
        markers = [];
        if(bestMarker) { scene.remove(bestMarker); bestMarker = null; }
        
        // Reset Planes
        bestPlane.visible = true;
        bestPlane.position.y = 5; 
        
        // Survival plane only for GA
        survivalPlane.visible = (STATE.method === 'ga');
        survivalPlane.position.y = 6; 

        if(STATE.method === 'pso') initPSO();
        else if(STATE.method === 'sa') initSA();
        else if(STATE.method === 'ga') initGA();
        
        updateControlsState();
    }

    // --- PSO ---
    function initPSO() {
        const n = parseInt(document.getElementById('psoParticles').value);
        particles = [];
        
        const sphereGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const sphereMat = new THREE.MeshStandardMaterial({ color: 0x2196f3, emissive: 0x002244 });

        for(let i=0; i<n; i++) {
            const x = (Math.random()*2 - 1) * STATE.range;
            const y = (Math.random()*2 - 1) * STATE.range;
            const val = getZ(x,y);
            
            const p = {
                x: x, y: y,
                vx: (Math.random()-0.5), vy: (Math.random()-0.5),
                pBestX: x, pBestY: y, pBestVal: val,
                val: val
            };
            particles.push(p);

            const mesh = new THREE.Mesh(sphereGeo, sphereMat);
            mesh.position.set(x, val * STATE.visualScale, y);
            scene.add(mesh);
            markers.push(mesh);
        }

        // Find initial global best
        if(particles.length > 0) {
            particles.gBestVal = Infinity;
            particles.forEach(p => {
                if(p.val < particles.gBestVal) {
                    particles.gBestVal = p.val;
                    particles.gBestX = p.x;
                    particles.gBestY = p.y;
                }
            });
            gBestVal = particles.gBestVal;
        }
    }

    function updatePSO() {
        const w = parseFloat(document.getElementById('psoInertia').value);
        const c1 = parseFloat(document.getElementById('psoC1').value);
        const c2 = parseFloat(document.getElementById('psoC2').value);
        const rLimit = STATE.range;

        particles.forEach((p, idx) => {
            const r1 = Math.random();
            const r2 = Math.random();

            p.vx = w * p.vx + c1 * r1 * (p.pBestX - p.x) + c2 * r2 * (particles.gBestX - p.x);
            p.vy = w * p.vy + c1 * r1 * (p.pBestY - p.y) + c2 * r2 * (particles.gBestY - p.y);

            const maxV = 2.0;
            p.vx = Math.max(-maxV, Math.min(maxV, p.vx));
            p.vy = Math.max(-maxV, Math.min(maxV, p.vy));

            p.x += p.vx * 0.1; 
            p.y += p.vy * 0.1;

            if(p.x < -rLimit) { p.x = -rLimit; p.vx *= -0.5; }
            if(p.x > rLimit) { p.x = rLimit; p.vx *= -0.5; }
            if(p.y < -rLimit) { p.y = -rLimit; p.vy *= -0.5; }
            if(p.y > rLimit) { p.y = rLimit; p.vy *= -0.5; }

            p.val = getZ(p.x, p.y);

            if(p.val < p.pBestVal) {
                p.pBestVal = p.val;
                p.pBestX = p.x;
                p.pBestY = p.y;
            }
            if(p.val < particles.gBestVal) {
                particles.gBestVal = p.val;
                particles.gBestX = p.x;
                particles.gBestY = p.y;
            }

            markers[idx].position.set(p.x, p.val * STATE.visualScale, p.y);
        });
        gBestVal = particles.gBestVal;
    }

    // --- SA ---
    function initSA() {
        const temp = parseFloat(document.getElementById('saTemp').value);
        saState = {
            x: (Math.random()*2 - 1) * STATE.range,
            y: (Math.random()*2 - 1) * STATE.range,
            temp: temp,
            bestX: 0, bestY: 0, bestVal: Infinity
        };
        saState.val = getZ(saState.x, saState.y);
        saState.bestX = saState.x;
        saState.bestY = saState.y;
        saState.bestVal = saState.val;
        gBestVal = saState.bestVal;

        const currentGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const currentMat = new THREE.MeshStandardMaterial({ color: 0xff9800, emissive: 0xaa4400 });
        const currentMesh = new THREE.Mesh(currentGeo, currentMat);
        scene.add(currentMesh);
        markers.push(currentMesh);

        const bestGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const bestMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71, emissive: 0x005500 });
        bestMarker = new THREE.Mesh(bestGeo, bestMat);
        bestMarker.position.set(saState.bestX, saState.bestVal * STATE.visualScale, saState.bestY);
        scene.add(bestMarker);
        
        currentMesh.position.set(saState.x, saState.val * STATE.visualScale, saState.y);
    }

    function updateSA() {
        const cooling = parseFloat(document.getElementById('saCooling').value);
        const stepSize = parseFloat(document.getElementById('saStep').value);
        const rLimit = STATE.range;

        let nx = saState.x + (Math.random()*2 - 1) * stepSize;
        let ny = saState.y + (Math.random()*2 - 1) * stepSize;
        
        nx = Math.max(-rLimit, Math.min(rLimit, nx));
        ny = Math.max(-rLimit, Math.min(rLimit, ny));

        const nVal = getZ(nx, ny);
        const delta = nVal - saState.val;

        if (delta < 0 || Math.random() < Math.exp(-delta * 10 / (saState.temp * 0.01))) { 
            saState.x = nx;
            saState.y = ny;
            saState.val = nVal;
        }

        if (saState.val < saState.bestVal) {
            saState.bestVal = saState.val;
            saState.bestX = saState.x;
            saState.bestY = saState.y;
            bestMarker.position.set(saState.bestX, saState.bestVal * STATE.visualScale, saState.bestY);
        }

        saState.temp *= cooling;
        gBestVal = saState.bestVal;

        markers[0].position.set(saState.x, saState.val * STATE.visualScale, saState.y);
    }

    // --- GA ---
    function initGA() {
        const n = parseInt(document.getElementById('gaPopSize').value);
        gaPop = [];
        
        const sphereGeo = new THREE.SphereGeometry(0.15, 16, 16);

        window.gaMats = {
            elite: new THREE.MeshStandardMaterial({ color: 0x2ecc71, emissive: 0x004400 }), // Green
            norm: new THREE.MeshStandardMaterial({ color: 0xf1c40f }), // Yellow
            worst: new THREE.MeshStandardMaterial({ color: 0xe74c3c })  // Red
        };

        for(let i=0; i<n; i++) {
            const x = (Math.random()*2 - 1) * STATE.range;
            const y = (Math.random()*2 - 1) * STATE.range;
            const val = getZ(x, y);
            
            gaPop.push({ x, y, val, type: 'norm' });
            
            const mesh = new THREE.Mesh(sphereGeo, window.gaMats.norm);
            mesh.position.set(x, val * STATE.visualScale, y);
            scene.add(mesh);
            markers.push(mesh);
        }
        updateGAVisualsOnly();
    }

    function updateGAVisualsOnly() {
        gaPop.sort((a, b) => a.val - b.val);
        gBestVal = gaPop[0].val;
        
        const n = gaPop.length;
        const elites = parseInt(document.getElementById('gaElites').value);
        
        // Determing survival/worst threshold
        // Let's assume bottom 30% are "Worst" (Red)
        const cutoffIndex = Math.floor(n * 0.7);
        survivalZ = gaPop[cutoffIndex].val;

        gaPop.forEach((ind, i) => {
            let m = markers[i];
            m.position.set(ind.x, ind.val * STATE.visualScale, ind.y);
            
            if(i < elites) m.material = window.gaMats.elite;
            else if (i >= cutoffIndex) m.material = window.gaMats.worst;
            else m.material = window.gaMats.norm;
        });
    }

    function updateGA() {
        const mutRate = parseFloat(document.getElementById('gaMutation').value);
        const mutPower = parseFloat(document.getElementById('gaMutPower').value);
        const tournamentSize = parseInt(document.getElementById('gaTournament').value);
        const numElites = parseInt(document.getElementById('gaElites').value);
        const rLimit = STATE.range;
        const popSize = gaPop.length;

        gaPop.sort((a, b) => a.val - b.val);
        gBestVal = gaPop[0].val;

        let newPop = [];

        // Elitism
        for(let i=0; i<numElites; i++) {
            if (i < gaPop.length) {
                newPop.push({ ...gaPop[i] });
            }
        }

        function tournament() {
            let best = null;
            for(let i=0; i<tournamentSize; i++) {
                let ind = gaPop[Math.floor(Math.random() * popSize)];
                if(!best || ind.val < best.val) best = ind;
            }
            return best;
        }

        while(newPop.length < popSize) {
            let p1 = tournament();
            let p2 = tournament();

            let child = {
                x: (p1.x + p2.x)/2,
                y: (p1.y + p2.y)/2,
            };

            if(Math.random() < mutRate) {
                child.x += (Math.random()*2 - 1) * mutPower;
                child.y += (Math.random()*2 - 1) * mutPower;
            }

            child.x = Math.max(-rLimit, Math.min(rLimit, child.x));
            child.y = Math.max(-rLimit, Math.min(rLimit, child.y));
            child.val = getZ(child.x, child.y);

            newPop.push(child);
        }

        gaPop = newPop;
        updateGAVisualsOnly();
    }

    // ==========================================
    // 4. MAIN LOOP
    // ==========================================

    function performStep() {
        if (STATE.method === 'pso') updatePSO();
        else if (STATE.method === 'sa') updateSA();
        else if (STATE.method === 'ga') updateGA();
    }

    let frameCount = 0;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (STATE.isPlaying && STATE.isAuto) {
            const speedVal = parseInt(document.getElementById('simSpeed').value);
            frameCount++;

            let shouldUpdate = false;
            let loops = 1;

            if (speedVal < 10) {
                // Throttling for slow speed
                const waitFrames = (10 - speedVal) * 2; 
                if (frameCount % waitFrames === 0) {
                    shouldUpdate = true;
                    loops = 1;
                }
            } else {
                // Multi-step for fast speed
                shouldUpdate = true;
                loops = (speedVal - 9);
            }

            if (shouldUpdate) {
                for(let k=0; k < loops; k++) {
                    performStep();
                }
            }
        }
        
        // UI Updates
        if(gBestVal !== Infinity && gBestVal !== undefined) {
             const el = document.getElementById('gbest-val');
             if(el) el.innerText = gBestVal.toFixed(4);
             
             // Move Best Plane
             if(bestPlane && bestPlane.visible) {
                 let targetY = gBestVal * STATE.visualScale;
                 bestPlane.position.y += (targetY - bestPlane.position.y) * 0.1;
             }

             // Move Survival Plane (GA only)
             if(survivalPlane && survivalPlane.visible && survivalZ !== Infinity) {
                 let targetY = survivalZ * STATE.visualScale;
                 // Lerp smooth
                 survivalPlane.position.y += (targetY - survivalPlane.position.y) * 0.1;
             }
        }

        renderer.render(scene, camera);
    }

    // ==========================================
    // 5. INTERFACE BINDINGS
    // ==========================================
    
    window.setMethod = (m) => {
        STATE.method = m;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + m).classList.add('active');
        document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
        document.getElementById('settings-' + m).classList.add('active');
        resetSim();
    };

    window.changeFunction = () => {
        STATE.func = document.getElementById('funcSelect').value;
        if(STATE.func === 'random') generateSplineData();
        drawSurface();
        resetSim();
    };

    window.togglePlay = () => {
        STATE.isAuto = !STATE.isAuto;
        document.getElementById('mode-text').innerText = STATE.isAuto ? '–ê–í–¢–û' : '–ü–û–ö–†–û–ö–û–í–ò–ô';
        document.getElementById('btn-play').innerText = STATE.isAuto ? 'PAUSE' : 'PLAY';
        document.getElementById('btn-step').disabled = STATE.isAuto;
        document.getElementById('status-text').innerText = STATE.isAuto ? '–ü–†–ê–¶–Æ–Ñ...' : '–ü–ê–£–ó–ê';
    };

    window.step = () => {
        STATE.isAuto = false;
        performStep();
    };

    window.resetSim = resetSim;

    window.updateLabel = (el) => {
        const label = document.getElementById('val-' + el.id);
        if(label) label.innerText = el.value;
    };
    
    window.updateVisualScale = () => {
        STATE.visualScale = parseFloat(document.getElementById('vScaleSlider').value);
        drawSurface();
        
        if(STATE.method === 'pso') {
            particles.forEach((p, i) => markers[i].position.y = p.val * STATE.visualScale);
        } else if(STATE.method === 'sa') {
            markers[0].position.y = saState.val * STATE.visualScale;
            if(bestMarker) bestMarker.position.y = saState.bestVal * STATE.visualScale;
        } else if(STATE.method === 'ga') {
            gaPop.forEach((p, i) => markers[i].position.y = p.val * STATE.visualScale);
        }
    };
    
    window.updateControlsState = () => {
        document.querySelectorAll('input[type="range"]').forEach(input => window.updateLabel(input));
    };

    window.openModal = () => { document.getElementById('theoryModal').style.display = 'flex'; };
    window.closeModal = () => { document.getElementById('theoryModal').style.display = 'none'; };

    // ==========================================
    // INITIALIZATION
    // ==========================================
    initThree();
    generateSplineData();
    drawSurface();
    resetSim();
    animate();

</script>
</body>
</html>
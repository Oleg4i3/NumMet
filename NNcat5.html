<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Sketch v5.0: Animated</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
	
	<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


    <style>
        :root { --bg: #f8fafc; --panel: #ffffff; --text: #334155; --accent: #4f46e5; --border: #e2e8f0; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        .main-layout { display: grid; grid-template-columns: 340px 1fr; gap: 20px; max-width: 1400px; width: 100%; }
        .panel { background: var(--panel); padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); border: 1px solid var(--border); }
        
        /* Left Column */
        .canvas-container { display: flex; flex-direction: column; align-items: center; gap: 10px; }
        canvas.draw { border: 3px solid #cbd5e1; cursor: crosshair; background: white; border-radius: 8px; touch-action: none; }
        canvas.pixelated { image-rendering: pixelated; border: 1px solid #94a3b8; }
        
        .mode-badge { padding: 4px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: bold; text-transform: uppercase; margin-bottom: 10px; display: inline-block; width: 100%; text-align: center; }
        .mode-collect { background: #fee2e2; color: #991b1b; }
        .mode-train { background: #fef3c7; color: #92400e; }
        .mode-test { background: #dcfce7; color: #166534; }
        .mode-auto { background: #e0e7ff; color: #3730a3; } /* –ù–æ–≤–∏–π —Å—Ç–∏–ª—å –¥–ª—è –∞–≤—Ç–æ */

        .controls-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; width: 100%; margin-top: 15px; }
        button { padding: 10px 5px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.85rem; transition: transform 0.1s; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; }
        button:active { transform: scale(0.98); }
        
        .btn-cls-0 { background: #dcfce7; color: #166534; border: 1px solid #86efac; }
        .btn-cls-1 { background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; }
        .btn-cls-2 { background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; }
        
        .btn-action { grid-column: span 3; padding: 12px; font-size: 1rem; color: white; background: var(--accent); margin-top: 10px; }
        .btn-action:disabled { background: #cbd5e1; cursor: not-allowed; }
        .btn-secondary { background: #f1f5f9; color: #64748b; margin-top: 5px; width: 100%; }

        /* Bars */
        .pred-box { width: 100%; margin-top: 20px; padding-top: 15px; border-top: 2px dashed #e2e8f0; }
        .pred-row { display: flex; align-items: center; margin-bottom: 6px; font-size: 0.9rem; }
        .bar-bg { flex-grow: 1; height: 10px; background: #e2e8f0; margin: 0 10px; border-radius: 5px; overflow: hidden; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.2s; }
        .result-text { text-align: center; font-weight: bold; font-size: 1.1rem; min-height: 1.5rem; margin-bottom: 10px; color: var(--accent); }

        /* Right Column */
        .vis-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .plot-container { height: 350px; width: 100%; }
        
        .weights-section { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; display: flex; justify-content: center; gap: 30px; }
        .weight-card { text-align: center; }
        
        .hidden { display: none; }
    </style>
</head>
<body>

    <div style="text-align: center; margin-bottom: 5px;">
        <h1 style="margin:0;">–ú–∞—à–∏–Ω–Ω–∏–π –∑—ñ—Ä</h1>
		
	
	<details class="theory-spoiler" style="background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
    <summary style="cursor: pointer; font-weight: bold; color: #4f46e5; font-size: 1.1em;">üìö –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –î–æ–≤—ñ–¥–∫–∞: –©–æ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ (–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞)</summary>
    <div class="theory-content" style="padding-top: 15px; line-height: 1.6; color: #334155; text-align: justify;">
        
		
        <p>
            –ú–µ—Ä–µ–∂–∞ –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è –≤—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏ –Ω–∞ –ø–∏—Ç–∞–Ω–Ω—è: <em>"–Ø–∫–∞ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å, —â–æ —Ü–µ–π –º–∞–ª—é–Ω–æ–∫ ‚Äî —Ü–µ –í–µ—Å–µ–ª–∏–π —Å–º–∞–π–ª–∏–∫ (–∞–±–æ –°—É–º–Ω–∏–π, –∞–±–æ –ö—ñ—Ç)?"</em>.
        </p>

        <h3> –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –ú–µ—Ä–µ–∂—ñ</h3>
        <ul>
            <li><strong>Input Layer (256 –Ω–µ–π—Ä–æ–Ω—ñ–≤):</strong> –¶–µ –Ω–∞—à–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è 16x16 –ø—ñ–∫—Å–µ–ª—ñ–≤.</li>
            <li><strong>Hidden Layer (2 –Ω–µ–π—Ä–æ–Ω–∏):</strong> –¶–µ –Ω–∞—à "—Å—Ç–∏—Å–Ω—É—Ç–∏–π" –ø—Ä–æ—Å—Ç—ñ—Ä (Latent Space). –ú–∏ —Å—Ç–∏—Å–∫–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ–π–Ω—ñ –≤–µ–∫—Ç–æ—Ä–∏ 256-–≤–∏–º—ñ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É (–∑–Ω–∞—á–µ–Ω–Ω—è —è—Å–∫—Ä–∞–≤–æ—Å—Ç—ñ –∫–æ–∂–Ω–æ–≥–æ –ø—ñ–∫—Å–µ–ª—è) –¥–æ –≤—Å—å–æ–≥–æ 2 —á–∏—Å–µ–ª $(z_1, z_2)$, —â–æ –≤—ñ–∑—É–∞–ª—ñ–∑—É—î—Ç—å—Å—è —è–∫ —Ç–æ—á–∫–∞ –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ (–¥–≤–æ–≤–∏–º—ñ—Ä–Ω–æ–º—É –ø—Ä–æ—Å—Ç–æ—Ä—ñ).
                           </li>
            <li><strong>Output Layer (3 –Ω–µ–π—Ä–æ–Ω–∏):</strong> –ü–æ –æ–¥–Ω–æ–º—É –Ω–µ–π—Ä–æ–Ω—É –Ω–∞ –∫–æ–∂–µ–Ω –∫–ª–∞—Å (Happy, Sad, Cat).
               
            </li>
		
        <h3>1. –í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ (–í–µ–∫—Ç–æ—Ä $\mathbf{x}$)</h3>
        <p>
            –í—Å–µ –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ –≤–∞—à–æ–≥–æ –º–∞–ª—é–Ω–∫–∞. –ö–æ–º–ø'—é—Ç–µ—Ä –±–∞—á–∏—Ç—å –π–æ–≥–æ —è–∫ –Ω–∞–±—ñ—Ä –ø—ñ–∫—Å–µ–ª—ñ–≤. –û—Å–∫—ñ–ª—å–∫–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –º–∞—î —Ä–æ–∑–º—ñ—Ä 16x16, –º–∏ –≤–∏—Ç—è–≥—É—î–º–æ —ó—ó –≤ –æ–¥–∏–Ω –¥–æ–≤–≥–∏–π —Ä—è–¥–æ–∫:
        </p>
        <p>
            $$ \mathbf{x} = [x_1, x_2, ..., x_{256}] $$
        </p>
        <p>–¶–µ <strong>–í–µ–∫—Ç–æ—Ä</strong> (–ø—Ä–æ—Å—Ç–æ —Å–ø–∏—Å–æ–∫ —ñ–∑ 256 —á–∏—Å–µ–ª, –¥–µ 0 ‚Äî –±—ñ–ª–∏–π –∫–æ–ª—ñ—Ä, 1 ‚Äî —á–æ—Ä–Ω–∏–π).</p>

        <h3>2. –°—Ç–∏—Å–Ω–µ–Ω–Ω—è (Encoder)</h3>
        <p>
            –ú–∏ —Ö–æ—á–µ–º–æ —Å—Ç–∏—Å–Ω—É—Ç–∏ —Ü—ñ 256 —á–∏—Å–µ–ª —É –≤—Å—å–æ–≥–æ 2 —á–∏—Å–ª–∞ (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É). –î–ª—è —Ü—å–æ–≥–æ –º–∏ –º–Ω–æ–∂–∏–º–æ –≤—Ö—ñ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä –Ω–∞ –ú–∞—Ç—Ä–∏—Ü—é –í–∞–≥ –ø–µ—Ä—à–æ–≥–æ —à–∞—Ä—É.
        </p>
        <div class="math-block">
            $$ \mathbf{z} = \sigma(\mathbf{W}^{(1)} \cdot \mathbf{x} + \mathbf{b}^{(1)}) $$
        </div>
        <ul>
            <li>$\mathbf{W}^{(1)}$ ‚Äî —Ü–µ <strong>–ú–∞—Ç—Ä–∏—Ü—è</strong> (—Ç–∞–±–ª–∏—Ü—è –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤) —Ä–æ–∑–º—ñ—Ä–æ–º $2 \times 256$. –í–æ–Ω–∞ –º—ñ—Å—Ç–∏—Ç—å "—Ñ—ñ–ª—å—Ç—Ä–∏", —è–∫—ñ —à—É–∫–∞—é—Ç—å –ø–µ–≤–Ω—ñ —Ñ–æ—Ä–º–∏.</li>
            <li>$\mathbf{x}$ ‚Äî –Ω–∞—à –≤—Ö—ñ–¥–Ω–∏–π <strong>–≤–µ–∫—Ç–æ—Ä</strong> (256).</li>
            <li>$\mathbf{b}^{(1)}$ ‚Äî –≤–µ–∫—Ç–æ—Ä <strong>–∑—Å—É–≤—É</strong> (bias). –î–æ–¥–∞—î –≥–Ω—É—á–∫–æ—Å—Ç—ñ, –¥–æ–∑–≤–æ–ª—è—é—á–∏ –∑—Å—É–≤–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç.</li>
            <li>$\sigma$ (—Å–∏–≥–º–∞) ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó (Tanh, —Å—ñ–≥–º–æ—ó–¥–∞ –∞–±–æ ReLU). –í–æ–Ω–∞ –≤–∏–∫—Ä–∏–≤–ª—è—î –ø—Ä–æ—Å—Ç—ñ—Ä, —â–æ–± –º–∏ –º–æ–≥–ª–∏ —Ä–æ–∑–¥—ñ–ª—è—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ –∫–ª–∞—Å–∏.</li>
        </ul>
         <p>
            –£ –ø—Ä–∏—Ä–æ–¥—ñ –Ω–µ–π—Ä–æ–Ω –Ω–µ –ø—Ä–æ—Å—Ç–æ —Å—É–º—É—î —Å–∏–≥–Ω–∞–ª–∏, –≤—ñ–Ω –º–∞—î –ø–æ—Ä—ñ–≥ –∑–±—É–¥–∂–µ–Ω–Ω—è —ñ "–Ω–∞—Å–∏—á–µ–Ω–Ω—è" (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—É —á–∞—Å—Ç–æ—Ç—É —ñ–º–ø—É–ª—å—Å—ñ–≤). –©–æ–± –∑–º–æ–¥–µ–ª—é–≤–∞—Ç–∏ —Ü–µ, –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–µ–ª—ñ–Ω—ñ–π–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é. –û–¥–Ω–∞ –∑ –Ω–∞–π–ø–æ–ø—É–ª—è—Ä–Ω—ñ—à–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó -—Ü–µ <strong>–°–∏–≥–º–æ—ó–¥–∞ (Sigmoid)</strong>:
        </p>
        <div class="math-block">
            $$ \sigma(u) = \frac{1}{1 + e^{-u}} $$
        </div>
        <p>
            <strong>–ù–∞–≤—ñ—â–æ —Ü–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ?</strong> –Ø–∫–±–∏ –º–∏ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–ª–∏ $\sigma$, –≤—Å—è –º–µ—Ä–µ–∂–∞ $ z = W^{(2)}(W^{(1)}x $ –∑–≤–µ–ª–∞—Å—è –± –¥–æ –æ–¥–Ω—ñ—î—ó –ª—ñ–Ω—ñ–π–Ω–æ—ó –º–∞—Ç—Ä–∏—Ü—ñ $W = W^{(2)}W^{(1)}$. –ù–µ–ª—ñ–Ω—ñ–π–Ω—ñ—Å—Ç—å –¥–æ–∑–≤–æ–ª—è—î –º–µ—Ä–µ–∂—ñ –≤–∏–≤—á–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ –∫—Ä–∏–≤–æ–ª—ñ–Ω—ñ–π–Ω—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö, –∞ –Ω–µ —Ç—ñ–ª—å–∫–∏ –ø–ª–æ—Å–∫—ñ –≥—ñ–ø–µ—Ä–ø–ª–æ—â–∏–Ω–∏.
        </p>
		
		<p>
            –†–µ–∑—É–ª—å—Ç–∞—Ç $\mathbf{z}$ ‚Äî —Ü–µ <strong>–≤–µ–∫—Ç–æ—Ä —ñ–∑ 2 —á–∏—Å–µ–ª</strong>: $[z_1, z_2]$. –°–∞–º–µ —Ü—ñ –¥–≤–∞ —á–∏—Å–ª–∞ –º–∏ –º–∞–ª—é—î–º–æ —è–∫ —Ç–æ—á–∫—É $(x, y)$ –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É.
        </p>

        <h3>3. –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è (Decoder)</h3>
        <p>
            –¢–µ–ø–µ—Ä –º–µ—Ä–µ–∂–∞ –º–∞—î –≤–≥–∞–¥–∞—Ç–∏ –∫–ª–∞—Å (–í–µ—Å–µ–ª–∏–π, –°—É–º–Ω–∏–π, –ö—ñ—Ç) –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ü–∏—Ö –¥–≤–æ—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç. –ú–∏ –∑–Ω–æ–≤—É –º–Ω–æ–∂–∏–º–æ, —Ç–µ–ø–µ—Ä –Ω–∞ –¥—Ä—É–≥—É –º–∞—Ç—Ä–∏—Ü—é:
        </p>
        <div class="math-block">
            $$ \mathbf{logits} = \mathbf{W}^{(2)} \cdot \mathbf{z} + \mathbf{b}^{(2)} $$
        </div>
        <ul>
            <li>$\mathbf{W}^{(2)}$ ‚Äî <strong>–ú–∞—Ç—Ä–∏—Ü—è</strong> —Ä–æ–∑–º—ñ—Ä–æ–º $3 \times 2$. –í–æ–Ω–∞ –ø–æ–≤'—è–∑—É—î –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∑ –∫–ª–∞—Å–∞–º–∏.</li>
            <li>$\mathbf{logits}$ ‚Äî —Ü–µ "—Å–∏—Ä–∏–π" —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –≤–µ–∫—Ç–æ—Ä: $[2.5, -0.1, 1.2]$. –ß–∏–º –±—ñ–ª—å—à–µ —á–∏—Å–ª–æ, —Ç–∏–º –≤–ø–µ–≤–Ω–µ–Ω—ñ—à–∞ –º–µ—Ä–µ–∂–∞, –∞–ª–µ —Ü–µ —â–µ –Ω–µ –≤—ñ–¥—Å–æ—Ç–∫–∏.</li>
        </ul>

        <h3>4. –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è —É –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ (Softmax)</h3>
        <p>
            –©–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ –∑—Ä–æ–∑—É–º—ñ–ª—ñ –≤—ñ–¥—Å–æ—Ç–∫–∏ (–π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ), –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é <strong>Softmax</strong>. –í–æ–Ω–∞ –±–µ—Ä–µ —Å–∏—Ä—ñ —á–∏—Å–ª–∞ ($\mathbf{logits}$) —ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î —ó—Ö –Ω–∞ –≤–µ–∫—Ç–æ—Ä –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç–µ–π $\mathbf{p}$.
        </p>
        <div class="math-block">
            $$ p_i = \frac{e^{logits_i}}{e^{logits_1} + e^{logits_2} + e^{logits_3}} $$
        </div>
        <p>
            –¢—É—Ç $p_i$ ‚Äî —Ü–µ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ $i$-–≥–æ –∫–ª–∞—Å—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 1-–π ‚Äî –í–µ—Å–µ–ª–∏–π, 2-–π ‚Äî –°—É–º–Ω–∏–π, 3-–π ‚Äî –ö—ñ—Ç). –ó–Ω–∞–º–µ–Ω–Ω–∏–∫ (—Å—É–º–∞ –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç) –≥–∞—Ä–∞–Ω—Ç—É—î, —â–æ —Å—É–º–∞ –≤—Å—ñ—Ö –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç–µ–π –¥–æ—Ä—ñ–≤–Ω—é—î 100% (–∞–±–æ 1.0).
        </p>

        <h3>5. –ù–∞–≤—á–∞–Ω–Ω—è (Cross-Entropy Loss)</h3>
        <p>
            –ú–∏ –ø–æ—Ä—ñ–≤–Ω—é—î–º–æ –ø—Ä–æ–≥–Ω–æ–∑ –º–µ—Ä–µ–∂—ñ $\mathbf{p}$ –∑ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—é –≤—ñ–¥–ø–æ–≤—ñ–¥–¥—é $\mathbf{t}$ (target).
        </p>
        <ul>
            <li>–ù–µ—Ö–∞–π –ø—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å "–ö—ñ—Ç" (—Ü–µ 3-–π –∫–ª–∞—Å). –¢–æ–¥—ñ –≤–µ–∫—Ç–æ—Ä —ñ—Å—Ç–∏–Ω–∏ $\mathbf{t} = [0, 0, 1]$.</li>
            <li>–ú–µ—Ä–µ–∂–∞ —Å–∫–∞–∑–∞–ª–∞: $\mathbf{p} = [0.1, 0.2, 0.7]$ (70% —â–æ –∫—ñ—Ç).</li>
        </ul>
        <p>–ú–∏ —Ä–∞—Ö—É—î–º–æ –ø–æ–º–∏–ª–∫—É (Loss) –∑–∞ —Ñ–æ—Ä–º—É–ª–æ—é –ø–µ—Ä–µ—Ö—Ä–µ—Å–Ω–æ—ó –µ–Ω—Ç—Ä–æ–ø—ñ—ó:</p>
        <div class="math-block">
            $$ L = - \sum_{i=1}^{3} t_i \cdot \log(p_i) $$
        </div>
        <p>
            –£ –Ω–∞—à–æ–º—É –ø—Ä–∏–∫–ª–∞–¥—ñ —Ü–µ –±—É–¥–µ –ø—Ä–æ—Å—Ç–æ $-\log(0.7)$. –ú–µ—Ä–µ–∂–∞ –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è –∑—Ä–æ–±–∏—Ç–∏ –ø–æ–º–∏–ª–∫—É $L$ —è–∫–æ–º–æ–≥–∞ –º–µ–Ω—à–æ—é, –ø—ñ–¥–∫—Ä—É—á—É—é—á–∏ –º–∞—Ç—Ä–∏—Ü—ñ $\mathbf{W}$ —Ç–∞ –≤–µ–∫—Ç–æ—Ä–∏ $\mathbf{b}$ –º–µ—Ç–æ–¥–æ–º –≥—Ä–∞–¥—ñ—î–Ω—Ç–Ω–æ–≥–æ —Å–ø—É—Å–∫—É.
        </p>
		 <h3>6. Backpropagation</h3>
        <p>
            –ü–æ—Ö—ñ–¥–Ω–∞ –≤—ñ–¥ Cross-Entropy + Softmax –≤–∏–≥–ª—è–¥–∞—î –¥—É–∂–µ –ø—Ä–æ—Å—Ç–æ:
            $$ \frac{\partial L}{\partial logits} = p - t $$
            –¢–æ–±—Ç–æ –ø–æ–º–∏–ª–∫–∞ ‚Äî —Ü–µ –ø—Ä–æ—Å—Ç–æ —Ä—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ –ø—Ä–æ–≥–Ω–æ–∑–æ–º (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 0.7) —ñ —ñ—Å—Ç–∏–Ω–æ—é (1.0). –¶–µ–π —Å–∏–≥–Ω–∞–ª –ø–æ–º–∏–ª–∫–∏ –º–∏ –ø–µ—Ä–µ–¥–∞—î–º–æ –Ω–∞–∑–∞–¥ (Backpropagation) —á–µ—Ä–µ–∑ –º–µ—Ä–µ–∂—É, —â–æ–± –æ–Ω–æ–≤–∏—Ç–∏ –≤–∞–≥–∏ $W^{(1)}$ —Ç–∞ $W^{(2)}$ (–≥—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫).
        </p>
    </div>
</details>



        <p style="color: #64748b; margin: 2px;">–ù–∞–º–∞–ª—é–π –≤–µ—Å–µ–ª–æ–≥–æ —Å–º–∞–π–ª–∏–∫–∞, –∞–±–æ —Å—É–º–Ω–æ–≥–æ —Å–º–∞–π–ª–∏–∫–∞, –∞–±–æ –∫–æ—Ç–∞
		<p> –ù–∞–º–∞–ª—é–π –º—ñ–Ω—ñ–º—É–º –ø–æ 3 –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –¥–ª—è –Ω–∞–≤—á–∞–Ω–Ω—è </p>
		</p>
    </div>

    <div class="main-layout">
        
        <div class="panel">
            <div id="statusBadge" class="mode-badge mode-collect">–ï—Ç–∞–ø 1: –ó–±—ñ—Ä –¥–∞–Ω–∏—Ö</div>
			            
            <div class="canvas-container">
                <canvas id="bigCanvas" width="200" height="200" class="draw"></canvas>
                <div style="display: flex; align-items: center; gap: 10px; font-size: 0.8rem; color: #64748b;">
                    <span>–í—Ö—ñ–¥ (200px)</span> 
                    <span>‚Æï 16x16 ‚Æï</span> <br>
					
                    <canvas id="smallCanvas" width="16" height="16" class="pixelated" style="width:32px; height:32px"></canvas>
                </div>
            </div>

            <div id="predictionBlock" class="pred-box hidden">
                <div id="finalResult" class="result-text">...</div>
                <div class="pred-row"><span style="width:20px">üôÇ</span><div class="bar-bg"><div id="bar0" class="bar-fill" style="background:#16a34a"></div></div><span id="val0">0%</span></div>
                <div class="pred-row"><span style="width:20px">‚òπÔ∏è</span><div class="bar-bg"><div id="bar1" class="bar-fill" style="background:#dc2626"></div></div><span id="val1">0%</span></div>
                <div class="pred-row"><span style="width:20px">üê±</span><div class="bar-bg"><div id="bar2" class="bar-fill" style="background:#2563eb"></div></div><span id="val2">0%</span></div>
            </div>

            <div class="controls-grid">
                <button class="btn-cls-0" id="btnCls0" onclick="handleAddSample(0)">
                    <span>üôÇ</span> <span id="lbl0">–í–µ—Å–µ–ª–∏–π</span> <span id="cnt0" style="font-size:0.7em">(0)</span>
                </button>
                <button class="btn-cls-1" id="btnCls1" onclick="handleAddSample(1)">
                    <span>‚òπÔ∏è</span> <span id="lbl1">–°—É–º–Ω–∏–π</span> <span id="cnt1" style="font-size:0.7em">(0)</span>
                </button>
                <button class="btn-cls-2" id="btnCls2" onclick="handleAddSample(2)">
                    <span>üê±</span> <span id="lbl2">–ö—ñ—Ç</span> <span id="cnt2" style="font-size:0.7em">(0)</span>
                </button>
                
                <button id="btnClear" class="btn-secondary hidden" style="grid-column: span 3" onclick="clearCanvas(true)">üßπ –û—á–∏—Å—Ç–∏—Ç–∏ –∫–∞–Ω–≤—É</button>
            </div>

            <button id="btnTrain" class="btn-action" onclick="toggleTraining()" disabled>
                ‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –Ω–∞–≤—á–∞–Ω–Ω—è
            </button>
            <button id="btnAuto" class="btn-secondary" onclick="runAutoAnimation()">
                –ê–≤—Ç–æ-–º–∞–ª—é–≤–∞–Ω–Ω—è (–¥–ª—è –ª—ñ–Ω–∏–≤–∏—Ö)
            </button>
            <button id="btnReset" class="btn-secondary" style="color:#dc2626; margin-top:10px" onclick="resetAll()">
                üóëÔ∏è –°–∫–∏–Ω—É—Ç–∏ –≤—Å–µ
            </button>
        </div>

        <div class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2 style="margin:0; font-size:1.1rem;">–õ–∞—Ç–µ–Ω—Ç–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä (2 –Ω–µ–π—Ä–æ–Ω–∏)</h2>
                <div>
                    <label style="font-size:0.85rem">–ê–∫—Ç–∏–≤–∞—Ü—ñ—è: </label>
                    <select id="actFunc" onchange="changeActivation()">
                        <option value="tanh">Tanh (-1..1)</option>
                        <option value="sigmoid">Sigmoid (0..1)</option>
                        <option value="relu">ReLU (0..‚àû)</option>
						<option value="linear">Linear (–ë–µ–∑ –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó)</option>
                    </select>
                </div>
            </div>

            <div class="vis-grid">
                <div>
                    <div id="latentPlot" class="plot-container"></div>
                </div>
                <div>
                    <div id="lossPlot" class="plot-container"></div>
                </div>
            </div>

            <div class="weights-section">
                <div class="weight-card">
                    <canvas id="wView0" width="16" height="16" class="pixelated" style="width:80px; height:80px; border:1px solid #ccc;"></canvas>
                    <div style="font-size:0.8rem; color:#666; margin-top:5px;">–§—ñ–ª—å—Ç—Ä –ù–µ–π—Ä–æ–Ω–∞ X</div>
                </div>
                <div class="weight-card">
                    <canvas id="wView1" width="16" height="16" class="pixelated" style="width:80px; height:80px; border:1px solid #ccc;"></canvas>
                    <div style="font-size:0.8rem; color:#666; margin-top:5px;">–§—ñ–ª—å—Ç—Ä –ù–µ–π—Ä–æ–Ω–∞ Y</div>
                </div>
                <div style="font-size:0.8rem; color:#888; max-width: 200px; display:flex; align-items:center;">
                    ü°Ñ –¶–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ø–æ–∫–∞–∑—É—é—Ç—å, –Ω–∞ —è–∫—ñ –ø–∞—Ç–µ—Ä–Ω–∏ –≤—Ö—ñ–¥–Ω–æ–≥–æ –º–∞–ª—é–Ω–∫–∞ —Ä–µ–∞–≥—É—é—Ç—å –Ω–µ–π—Ä–æ–Ω–∏ –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ —à–∞—Ä—É.
                </div>
            </div>
        </div>
    </div>

<script>
// --- CONFIG ---
const INPUT_DIM = 256; // 16x16
const LATENT_DIM = 2;
const OUTPUT_DIM = 3; 

// --- STATE ---
let state = {
    mode: 'collect', // collect, training, test, auto
    samples: [],     // { input:[], label:int }
    counts: [0,0,0],
    losses: [],
    trainInterval: null,
    actName: 'tanh',
    cachedBackground: null,
    lastDrawTime: 0
};

// --- NEURAL NET ---
let net = {
    W1: new Float32Array(INPUT_DIM * LATENT_DIM),
    b1: new Float32Array(LATENT_DIM),
    W2: new Float32Array(LATENT_DIM * OUTPUT_DIM),
    b2: new Float32Array(OUTPUT_DIM),
    
    acts: {
        tanh: { f: x=>Math.tanh(x), d: y=>1-y*y },
        sigmoid: { f: x=>1/(1+Math.exp(-x)), d: y=>y*(1-y) },
        relu: { f: x=>x>0?x:0, d: y=>y>0?1:0 },
		linear: { f: x => x, d: y => 1 }
    },

    init() {
        for(let i=0; i<this.W1.length; i++) this.W1[i] = (Math.random()-0.5)*0.1;
        for(let i=0; i<this.W2.length; i++) this.W2[i] = (Math.random()-0.5)*0.5;
        this.b1.fill(0); this.b2.fill(0);
        state.losses = [];
    },

    forward(input) {
        const act = this.acts[state.actName];
        let h = [0,0];
        // Layer 1
        for(let j=0; j<LATENT_DIM; j++) {
            let s = this.b1[j];
            for(let i=0; i<INPUT_DIM; i++) s += input[i]*this.W1[i*LATENT_DIM+j];
            h[j] = act.f(s);
        }
        // Layer 2
        let z = [0,0,0];
        for(let k=0; k<OUTPUT_DIM; k++) {
            let s = this.b2[k];
            for(let j=0; j<LATENT_DIM; j++) s += h[j]*this.W2[j*OUTPUT_DIM+k];
            z[k] = s;
        }
        // Softmax
        let max = Math.max(...z);
        let exps = z.map(v=>Math.exp(v-max));
        let sum = exps.reduce((a,b)=>a+b,0);
        return { h, probs: exps.map(v=>v/sum) };
    },

    trainStep(lr=0.05) {
        let totalLoss = 0;
        const act = this.acts[state.actName];
        state.samples.sort(()=>Math.random()-0.5);

        for(let s of state.samples) {
            const fwd = this.forward(s.input);
            totalLoss += -Math.log(fwd.probs[s.label] + 1e-10);

            // Backprop
            let dZ2 = [...fwd.probs];
            dZ2[s.label] -= 1;

            let dW2 = new Float32Array(this.W2.length);
            let dH = [0,0];

            for(let j=0; j<LATENT_DIM; j++) {
                for(let k=0; k<OUTPUT_DIM; k++) {
                    dW2[j*OUTPUT_DIM+k] = fwd.h[j]*dZ2[k];
                    dH[j] += dZ2[k]*this.W2[j*OUTPUT_DIM+k];
                }
            }
            
            let dZ1 = dH.map((v,j) => v * (state.actName==='relu' ? (fwd.h[j]>0?1:0) : act.d(fwd.h[j])));
            
            let dW1 = new Float32Array(this.W1.length);
            for(let i=0; i<INPUT_DIM; i++) {
                for(let j=0; j<LATENT_DIM; j++) {
                    dW1[i*LATENT_DIM+j] = s.input[i]*dZ1[j];
                }
            }

            // Update
            for(let i=0; i<this.W1.length; i++) this.W1[i] -= lr*dW1[i];
            for(let i=0; i<this.b1.length; i++) this.b1[i] -= lr*dZ1[i];
            for(let i=0; i<this.W2.length; i++) this.W2[i] -= lr*dW2[i];
            
            // --- FIX: Correct Loop Variable 'i' instead of 'k' ---
            for(let i=0; i<this.b2.length; i++) this.b2[i] -= lr*dZ2[i]; 
        }
        return totalLoss / state.samples.length;
    }
};
net.init();

// --- CANVAS & INPUT ---
const bigC = document.getElementById('bigCanvas');
const bigCtx = bigC.getContext('2d', {willReadFrequently:true});
const smallC = document.getElementById('smallCanvas');
const smallCtx = smallC.getContext('2d', {willReadFrequently:true});
let isDrawing = false;

bigCtx.fillStyle="white"; bigCtx.fillRect(0,0,200,200);
bigCtx.lineWidth=15; bigCtx.lineCap='round'; bigCtx.lineJoin='round';

function getPos(e) {
    const r=bigC.getBoundingClientRect();
    const x=(e.clientX||e.touches[0].clientX)-r.left;
    const y=(e.clientY||e.touches[0].clientY)-r.top;
    return { x: x*(bigC.width/r.width), y: y*(bigC.height/r.height) };
}

bigC.addEventListener('mousedown', e=>{ 
    if(state.mode === 'auto') return;
    isDrawing=true; bigCtx.beginPath(); bigCtx.moveTo(getPos(e).x, getPos(e).y); e.preventDefault(); 
});
bigC.addEventListener('touchstart', e=>{ 
    if(state.mode === 'auto') return;
    isDrawing=true; bigCtx.beginPath(); bigCtx.moveTo(getPos(e).x, getPos(e).y); e.preventDefault(); 
}, {passive:false});

const moveHandler = (e) => {
    if(!isDrawing) return;
    e.preventDefault();
    const p = getPos(e);
    bigCtx.lineTo(p.x, p.y);
    bigCtx.stroke();
    
    smallCtx.drawImage(bigC, 0,0,16,16);

    const now = Date.now();
    if(state.mode === 'test' && now - state.lastDrawTime > 2500) {//was 100 freezed
        state.lastDrawTime = now;
		predictCurrent(false); // <--- FALSE: —Ü–µ "—à–≤–∏–¥–∫–µ" –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
       
    }
};

bigC.addEventListener('mousemove', moveHandler);
bigC.addEventListener('touchmove', moveHandler, {passive:false});

const endHandler = () => { isDrawing=false; if(state.mode==='test') predictCurrent(true); };
document.addEventListener('mouseup', endHandler);
document.addEventListener('touchend', endHandler);
/*
function getPixels() {
    smallCtx.drawImage(bigC, 0,0,16,16);
    const img = smallCtx.getImageData(0,0,16,16);
    let arr = [];
    for(let i=0; i<img.data.length; i+=4) arr.push(1.0 - img.data[i]/255.0);
    return arr;
}
*/

function getPixels() {
    // 1. –û—Ç—Ä–∏–º—É—î–º–æ "—Å–∏—Ä—ñ" –¥–∞–Ω—ñ –∑ –≤–µ–ª–∏–∫–æ—ó –∫–∞–Ω–≤–∏, —â–æ–± –∑–Ω–∞–π—Ç–∏ –º–µ–∂—ñ –º–∞–ª—é–Ω–∫–∞
    const rawData = bigCtx.getImageData(0, 0, 200, 200);
    const data = rawData.data;
    let minX = 200, minY = 200, maxX = 0, maxY = 0;
    let found = false;

    // –°–∫–∞–Ω—É—î–º–æ –ø—ñ–∫—Å–µ–ª—ñ, —â–æ–± –∑–Ω–∞–π—Ç–∏ –¥–µ –Ω–∞–º–∞–ª—å–æ–≤–∞–Ω–æ (–Ω–µ –±—ñ–ª–∏–π –∫–æ–ª—ñ—Ä)
    for(let y=0; y<200; y++) {
        for(let x=0; x<200; x++) {
            // data[i] = R, data[i+1] = G, data[i+2] = B. –ë—ñ–ª–∏–π = 255,255,255
            const i = (y * 200 + x) * 4;
            // –Ø–∫—â–æ –ø—ñ–∫—Å–µ–ª—å —Ç–µ–º–Ω–∏–π (–Ω–µ –±—ñ–ª–∏–π)
            if(data[i] < 240 || data[i+1] < 240 || data[i+2] < 240) {
                if(x < minX) minX = x;
                if(x > maxX) maxX = x;
                if(y < minY) minY = y;
                if(y > maxY) maxY = y;
                found = true;
            }
        }
    }

    // –û—á–∏—â–∞—î–º–æ –º–∞–ª–µ–Ω—å–∫—É –∫–∞–Ω–≤—É –ø–µ—Ä–µ–¥ –º–∞–ª—é–≤–∞–Ω–Ω—è–º
    smallCtx.fillStyle = "white";
    smallCtx.fillRect(0, 0, 16, 16);

    if (found) {
        // –î–æ–¥–∞—î–º–æ –Ω–µ–≤–µ–ª–∏–∫–∏–π –≤—ñ–¥—Å—Ç—É–ø (padding), —â–æ–± –∫—Ä–∞—ó –Ω–µ –æ–±—Ä—ñ–∑–∞–ª–∏—Å—å
        const pad = 10; 
        minX = Math.max(0, minX - pad);
        minY = Math.max(0, minY - pad);
        maxX = Math.min(200, maxX + pad);
        maxY = Math.min(200, maxY + pad);

        let w = maxX - minX;
        let h = maxY - minY;

        // –†–æ–±–∏–º–æ –≤–∏–±—ñ—Ä–∫—É –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ—é, —â–æ–± –Ω–µ —Å–ø–æ—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –ø—Ä–æ–ø–æ—Ä—Ü—ñ—ó (–∫–æ–ª–æ –Ω–µ —Å—Ç–∞–ª–æ –æ–≤–∞–ª–æ–º)
        if (w > h) {
            minY -= (w - h) / 2;
            h = w;
        } else {
            minX -= (h - w) / 2;
            w = h;
        }

        // –ú–∞–ª—é—î–º–æ –≤–∏—Ä—ñ–∑–∞–Ω–∏–π —à–º–∞—Ç–æ–∫ –Ω–∞ –º–∞–ª–µ–Ω—å–∫—É –∫–∞–Ω–≤—É 16x16
        smallCtx.drawImage(bigC, minX, minY, w, h, 0, 0, 16, 16);
    } else {
        // –Ø–∫—â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ ‚Äî –ø—Ä–æ—Å—Ç–æ –º–∞–ª—é—î–º–æ –≤—Å–µ —è–∫ —î (–ø—É—Å—Ç–æ—Ç–∞)
        smallCtx.drawImage(bigC, 0, 0, 16, 16);
    }

    // –¢–µ–ø–µ—Ä –∑—á–∏—Ç—É—î–º–æ –≤–∂–µ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ 16x16 –ø—ñ–∫—Å–µ–ª—ñ–≤ –¥–ª—è –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ
    const img = smallCtx.getImageData(0, 0, 16, 16);
    let arr = [];
    for(let i=0; i<img.data.length; i+=4) {
        // –Ü–Ω–≤–µ—Ä—Ç—É—î–º–æ: 1.0 = —á–æ—Ä–Ω–∏–π, 0.0 = –±—ñ–ª–∏–π (—Ç–∞–∫ –∫—Ä–∞—â–µ –¥–ª—è –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂)
        arr.push(1.0 - img.data[i]/255.0);
    }
    return arr;
}
function clearCanvas(visualOnly=false) {
    bigCtx.fillStyle="white"; bigCtx.fillRect(0,0,200,200);
    smallCtx.fillStyle="white"; smallCtx.fillRect(0,0,16,16);
    if(state.mode === 'test') {
        document.getElementById('finalResult').innerText = "...";
        ['bar0','bar1','bar2'].forEach(id => document.getElementById(id).style.width='0%');
        updatePlotWithCurrent(null); 
    }
}

// --- APP LOGIC ---

function handleAddSample(label) {
    if(state.mode === 'auto') return; 
    const input = getPixels();
    if(input.reduce((a,b)=>a+b,0) < 0.5) { alert("–ù–∞–º–∞–ª—é–π—Ç–µ —â–æ—Å—å!"); return; }

    state.samples.push({ input, label });
    state.counts[label]++;
    
    document.getElementById(`cnt${label}`).innerText = `(${state.counts[label]})`;
    
    if(state.mode === 'collect') {
        clearCanvas();
        checkReadyToTrain();
        updatePlotWithCurrent(null); 
    } else if(state.mode === 'test') {
        // Test mode: Adding new data
        document.getElementById('btnTrain').disabled = false;
        document.getElementById('btnTrain').innerText = "üîÑ –î–æ–Ω–∞–≤—á–∏—Ç–∏ (–Ñ –Ω–æ–≤—ñ –¥–∞–Ω—ñ)";
        document.getElementById('btnTrain').style.background = "#ea580c";
        clearCanvas();
        updatePlotWithCurrent(null);
    }
}

function checkReadyToTrain() {
    const min = 3;
    const ready = state.counts.every(c => c >= min);
    document.getElementById('btnTrain').disabled = !ready;
    if(ready) document.getElementById('btnTrain').innerText = "‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –Ω–∞–≤—á–∞–Ω–Ω—è";
}

function toggleTraining() {
    if(state.trainInterval) stopTraining();
    else startTraining();
}

function startTraining() {
    state.mode = 'training';
    document.getElementById('statusBadge').className = 'mode-badge mode-train';
    document.getElementById('statusBadge').innerText = '–ï—Ç–∞–ø 2: –ù–∞–≤—á–∞–Ω–Ω—è...';
    document.getElementById('btnTrain').innerText = "‚èπ –°—Ç–æ–ø";
    document.getElementById('btnTrain').style.background = "#dc2626";
    document.getElementById('btnAuto').disabled = true;
    
    let iter = 0;
    state.trainInterval = setInterval(() => {
        const loss = net.trainStep();
        state.losses.push(loss);
        iter++;
        
        if(iter % 5 === 0) {
            updateLossPlot();
            state.cachedBackground = null; 
            updatePlotWithCurrent(null);
            updateWeightsViz();
        }

        if(loss < 0.02 && iter > 50) stopTraining();
    }, 50);
}

function stopTraining() {
    clearInterval(state.trainInterval);
    state.trainInterval = null;
    state.mode = 'test';
    
    document.getElementById('statusBadge').className = 'mode-badge mode-test';
    document.getElementById('statusBadge').innerText = '–ï—Ç–∞–ø 3: –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è';
    document.getElementById('predictionBlock').classList.remove('hidden');
    document.getElementById('btnClear').classList.remove('hidden');
    
    document.getElementById('btnTrain').innerText = "üîÑ –î–æ–Ω–∞–≤—á–∏—Ç–∏";
    document.getElementById('btnTrain').style.background = "#4f46e5";
    document.getElementById('btnTrain').disabled = true; 
    document.getElementById('btnAuto').classList.add('hidden');
    
    ['–í–µ—Å–µ–ª–∏–π', '–°—É–º–Ω–∏–π', '–ö—ñ—Ç'].forEach((t, i) => document.getElementById(`lbl${i}`).innerText = `–¶–µ ${t}`);
    
    state.cachedBackground = generateVoronoiBackground(); 
    updatePlotWithCurrent(null);
    updateWeightsViz();
}

function predictCurrent(isFinal = false) {
    const inp = getPixels();
    const res = net.forward(inp);
    
    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–æ–≤–ø—á–∏–∫—ñ–≤ (HTML - —Ü–µ —à–≤–∏–¥–∫–æ)
    const labels = ["–í–µ—Å–µ–ª–∏–π üôÇ", "–°—É–º–Ω–∏–π ‚òπÔ∏è", "–ö—ñ—Ç üê±"];
    let maxP = 0, maxI = 0;
    res.probs.forEach((p, i) => {
        document.getElementById(`bar${i}`).style.width = (p*100)+'%';
        document.getElementById(`val${i}`).innerText = Math.round(p*100)+'%';
        if(p>maxP) { maxP=p; maxI=i; }
    });
    
    document.getElementById('finalResult').innerText = maxP > 0.6 ? `–∑–¥–∞—î—Ç—å—Å—è, —Ü–µ ${labels[maxI]}` : "–ù–µ –≤–ø–µ–≤–Ω–µ–Ω–∏–π...";
    
    // --- –ì–û–õ–û–í–ù–ê –ó–ú–Ü–ù–ê –¢–£–¢ ---
    if (isFinal) {
        // –Ø–∫—â–æ –º–∏ –∑–∞–∫—ñ–Ω—á–∏–ª–∏ –º–∞–ª—é–≤–∞—Ç–∏ (mouseup) - —Ä–æ–±–∏–º–æ –ø–æ–≤–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è (—â–æ–± –ø—ñ–¥—ñ–≥–Ω–∞—Ç–∏ –º–µ–∂—ñ/zoom)
        updatePlotWithCurrent(res.h);
    } else {
        // –Ø–∫—â–æ –º–∏ –≤ –ø—Ä–æ—Ü–µ—Å—ñ –º–∞–ª—é–≤–∞–Ω–Ω—è - —Ç—ñ–ª—å–∫–∏ —Ä—É—Ö–∞—î–º–æ —Ç–æ—á–∫—É (–±–µ–∑ –ª–∞–≥—ñ–≤)
        fastMoveCross(res.h);
    }
}

// --- VISUALIZATION ---

function updateWeightsViz() {
    const drawW = (canvId, neuronIdx) => {
        const ctx = document.getElementById(canvId).getContext('2d');
        const img = ctx.createImageData(16,16);
        let max = 0;
        for(let i=0; i<INPUT_DIM; i++) {
            let val = Math.abs(net.W1[i*LATENT_DIM + neuronIdx]);
            if(val > max) max = val;
        }
        if(max===0) max=1;

        for(let i=0; i<INPUT_DIM; i++) {
            let val = net.W1[i*LATENT_DIM + neuronIdx];
            let norm = val/max; 
            
            let r=200, g=200, b=200;
            if(norm > 0) { r=255; g=200 - norm*200; b=200 - norm*200; }
            else { b=255; r=200 - Math.abs(norm)*200; g=200 - Math.abs(norm)*200; }
            
            let p = i*4;
            img.data[p]=r; img.data[p+1]=g; img.data[p+2]=b; img.data[p+3]=255;
        }
        ctx.putImageData(img, 0, 0);
    };
    drawW('wView0', 0);
    drawW('wView1', 1);
}

// 1. –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –º–µ–∂
function getDynamicBounds(currPoint = null) {
    // –ë–∞–∑–æ–≤—ñ –º–µ–∂—ñ, —è–∫—â–æ —Ç–æ—á–æ–∫ —â–µ –Ω–µ–º–∞—î
    let minX = -1.5, maxX = 1.5, minY = -1.5, maxY = 1.5;
    
    // –Ø–∫—â–æ —î –Ω–∞–≤—á–∞–ª—å–Ω—ñ —Ç–æ—á–∫–∏, –±–µ—Ä–µ–º–æ —ó—Ö –º—ñ–Ω—ñ–º—É–º/–º–∞–∫—Å–∏–º—É–º
    if (state.samples.length > 0) {
        const pts = state.samples.map(s => net.forward(s.input).h);
        minX = Math.min(...pts.map(p => p[0]));
        maxX = Math.max(...pts.map(p => p[0]));
        minY = Math.min(...pts.map(p => p[1]));
        maxY = Math.max(...pts.map(p => p[1]));
    }

    // --- –ì–û–õ–û–í–ù–ê –ü–†–ê–í–ö–ê –¢–£–¢ ---
    // –Ø–∫—â–æ —î –ø–æ—Ç–æ—á–Ω–∏–π —Ö—Ä–µ—Å—Ç–∏–∫, –≤—Ä–∞—Ö–æ–≤—É—î–º–æ —ñ –π–æ–≥–æ!
    if (currPoint) {
        minX = Math.min(minX, currPoint[0]);
        maxX = Math.max(maxX, currPoint[0]);
        minY = Math.min(minY, currPoint[1]);
        maxY = Math.max(maxY, currPoint[1]);
    }

    // –û–±–º–µ–∂–µ–Ω–Ω—è –¥–ª—è Tanh/Sigmoid, —â–æ–± –Ω–µ –∑—É–º–∏—Ç–∏—Å—å –Ω–∞–¥—Ç–æ —Å–∏–ª—å–Ω–æ –≤ —Ü–µ–Ω—Ç—Ä
  if (state.actName === 'tanh') { 
        minX = Math.min(minX, -1.1); maxX = Math.max(maxX, 1.1);
        minY = Math.min(minY, -1.1); maxY = Math.max(maxY, 1.1); // <--- –¶—å–æ–≥–æ –Ω–µ –≤–∏—Å—Ç–∞—á–∞–ª–æ
    }
    if (state.actName === 'sigmoid') { 
        minX = Math.min(minX, -0.1); maxX = Math.max(maxX, 1.1);
        minY = Math.min(minY, -0.1); maxY = Math.max(maxY, 1.1); // <--- –Ü —Ü—å–æ–≥–æ
    }
    // –î–æ–¥–∞—î–º–æ 15% –≤—ñ–¥—Å—Ç—É–ø—É (padding)
    const padX = (maxX - minX) * 0.15 || 0.5;
    const padY = (maxY - minY) * 0.15 || 0.5;

    return {
        x: [minX - padX, maxX + padX],
        y: [minY - padY, maxY + padY]
    };
}
/*
function getDynamicBounds() {
    // –Ø–∫—â–æ –¥–∞–Ω–∏—Ö –Ω–µ–º–∞—î, –¥–∞—î–º–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ñ –º–µ–∂—ñ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó
    if (state.samples.length === 0) {
        if (state.actName === 'tanh') return { x: [-1.5, 1.5], y: [-1.5, 1.5] };
        if (state.actName === 'sigmoid') return { x: [-0.5, 1.5], y: [-0.5, 1.5] };
        return { x: [-2, 5], y: [-2, 5] }; // –î–ª—è ReLU/Linear –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
    }

    // –ó–±–∏—Ä–∞—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –≤—Å—ñ—Ö —Ç–æ—á–æ–∫
    const pts = state.samples.map(s => net.forward(s.input).h);
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    pts.forEach(p => {
        if(p[0] < minX) minX = p[0];
        if(p[0] > maxX) maxX = p[0];
        if(p[1] < minY) minY = p[1];
        if(p[1] > maxY) maxY = p[1];
    });

    // –Ø–∫—â–æ –∞–∫—Ç–∏–≤–∞—Ü—ñ—è –æ–±–º–µ–∂–µ–Ω–∞ (Tanh/Sigmoid), –Ω–µ –¥–∞—î–º–æ –∑—É–º–∏—Ç–∏—Å—å –Ω–∞–¥—Ç–æ —Å–∏–ª—å–Ω–æ –≤—Å–µ—Ä–µ–¥–∏–Ω—É
    if (state.actName === 'tanh') { minX = Math.min(minX, -1.1); maxX = Math.max(maxX, 1.1); }
    if (state.actName === 'sigmoid') { minX = Math.min(minX, -0.1); maxX = Math.max(maxX, 1.1); }

    // –î–æ–¥–∞—î–º–æ –≤—ñ–¥—Å—Ç—É–ø–∏ (padding) 15%
    const padX = (maxX - minX) * 0.15 || 0.5;
    const padY = (maxY - minY) * 0.15 || 0.5;

    return {
        x: [minX - padX, maxX + padX],
        y: [minY - padY, maxY + padY]
    };
}
*/
// 2. –û–Ω–æ–≤–ª–µ–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ñ–æ–Ω—É (—Ç–µ–ø–µ—Ä –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –¥–∏–Ω–∞–º—ñ—á–Ω—ñ –º–µ–∂—ñ)
function generateVoronoiBackground() {
    let centers = [];
    for(let c=0; c<3; c++) {
        let pts = state.samples.filter(s=>s.label===c).map(s=>net.forward(s.input).h);
        if(pts.length>0) {
            let ax=pts.reduce((a,b)=>a+b[0],0)/pts.length;
            let ay=pts.reduce((a,b)=>a+b[1],0)/pts.length;
            centers.push({x:ax, y:ay, c:c});
        }
    }
    if(centers.length===0) return null;

    // –û–¢–†–ò–ú–£–Ñ–ú–û –ú–ï–ñ–Ü
    const bounds = getDynamicBounds();
    const xR = bounds.x;
    const yR = bounds.y;
    
    let X=[], Y=[], Z=[];
    // –ì–µ–Ω–µ—Ä—É—î–º–æ —Å—ñ—Ç–∫—É 30x30 —É —Ü–∏—Ö –º–µ–∂–∞—Ö
    for(let i=0; i<30; i++) { 
        let x = xR[0] + (xR[1]-xR[0])*(i/29);
        for(let j=0; j<30; j++) {
            let y = yR[0] + (yR[1]-yR[0])*(j/29);
            let minDist=999, cls=0;
            for(let cen of centers) {
                let d = Math.hypot(x-cen.x, y-cen.y);
                if(d<minDist) { minDist=d; cls=cen.c; }
            }
            X.push(x); Y.push(y); Z.push(cls);
        }
    }
    
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –º–µ–∂—ñ –ø—Ä—è–º–æ –≤ –æ–±'—î–∫—Ç—ñ —Ñ–æ–Ω—É, —â–æ–± –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –≤ Layout
    return {
        x: X, y: Y, mode: 'markers',
        marker: { 
            color: Z, colorscale: [[0, 'rgba(220, 252, 231, 0.3)'], [0.5, 'rgba(254, 226, 226, 0.3)'], [1, 'rgba(219, 234, 254, 0.3)']],
            size: 14, symbol: 'square'
        },
        type: 'scatter', hoverinfo: 'none', showlegend: false,
        _bounds: bounds // –ø—Ä–∏—Ö–æ–≤–∞–Ω–∞ –≤–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å –¥–ª—è –ø–µ—Ä–µ–¥–∞—á—ñ –º–µ–∂
    };
}


function fastMoveCross(h) {
    const div = document.getElementById('latentPlot');
    if (!div || !div.data) return;

    // –®—É–∫–∞—î–º–æ —ñ–Ω–¥–µ–∫—Å —Å–ª—ñ–¥—É (trace), —è–∫–∏–π —î –Ω–∞—à–∏–º —Ö—Ä–µ—Å—Ç–∏–∫–æ–º
    const crossIndex = div.data.findIndex(trace => trace.name === '–í–∏ —Ç—É—Ç');

    if (crossIndex !== -1) {
        // –û–Ω–æ–≤–ª—é—î–º–æ –¢–Ü–õ–¨–ö–ò –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ü—å–æ–≥–æ —Å–ª—ñ–¥—É. –¶–µ –¥—É–∂–µ —à–≤–∏–¥–∫–æ.
        Plotly.restyle('latentPlot', {
            x: [[h[0]]],
            y: [[h[1]]]
        }, [crossIndex]);
    } else {
        // –Ø–∫—â–æ —Ö—Ä–µ—Å—Ç–∏–∫–∞ —â–µ –Ω–µ–º–∞—î (–ø–µ—Ä—à–∏–π —Ä–∞–∑) - –º–∞–ª—é—î–º–æ –ø–æ-—Å—Ç–∞—Ä–æ–º—É
        updatePlotWithCurrent(h);
    }
}


// 3. –û–Ω–æ–≤–ª–µ–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫–∞ (—Ç–µ–ø–µ—Ä –∑–∞—Å—Ç–æ—Å–æ–≤—É—î –º–µ–∂—ñ –∑ —Ñ–æ–Ω—É)
function updatePlotWithCurrent(currH) {
    let traces = [];
    
    // 1. –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –º–µ–∂—ñ (–≤—Ä–∞—Ö–æ–≤—É—é—á–∏ —Ö—Ä–µ—Å—Ç–∏–∫ currH!)
    // –ù–∞–≤—ñ—Ç—å —è–∫—â–æ —Ñ–æ–Ω –∑–∞–∫–µ—à–æ–≤–∞–Ω–∏–π –¥–ª—è –º–µ–Ω—à–æ—ó –æ–±–ª–∞—Å—Ç—ñ, –≥—Ä–∞—Ñ—ñ–∫ —Ä–æ–∑—à–∏—Ä–∏—Ç—å—Å—è
    const currentBounds = getDynamicBounds(currH);

    // 2. Background (–í–æ—Ä–æ–Ω–æ–≥–æ)
    if(state.mode !== 'collect' && state.mode !== 'auto') {
        if(!state.cachedBackground) state.cachedBackground = generateVoronoiBackground();
        if(state.cachedBackground) {
            traces.push(state.cachedBackground);
        }
    }

    // 3. –ù–∞–≤—á–∞–ª—å–Ω—ñ —Ç–æ—á–∫–∏
    const colors = ['#16a34a', '#dc2626', '#2563eb'];
    for(let c=0; c<3; c++) {
        const pts = state.samples.filter(s=>s.label===c).map(s=>net.forward(s.input).h);
        if(pts.length>0) {
            traces.push({
                x: pts.map(p=>p[0]), y: pts.map(p=>p[1]),
                mode: 'markers', type: 'scatter', name: ['Happy','Sad','Cat'][c],
                marker: { color: colors[c], size: 8, line:{width:1, color:'black'} }
            });
        }
    }

    // 4. –ü–æ—Ç–æ—á–Ω–∏–π —Ö—Ä–µ—Å—Ç–∏–∫ (Current Cross)
    if(currH) {
        traces.push({
            x: [currH[0]], y: [currH[1]],
            mode: 'markers', type: 'scatter', name: '–í–∏ —Ç—É—Ç',
            marker: { symbol: 'cross', size: 20, color: 'black', line:{width:4} }
        });
    }

    // 5. Layout –∑ –Ω–æ–≤–∏–º–∏ –º–µ–∂–∞–º–∏
    const layout = {
        margin: {t:30, l:30, r:10, b:30},
        xaxis: { range: currentBounds.x, title:'–ù–µ–π—Ä–æ–Ω 1', automargin: true },
        yaxis: { range: currentBounds.y, title:'–ù–µ–π—Ä–æ–Ω 2', automargin: true },
        showlegend: false, hovermode: false
    };

    Plotly.react('latentPlot', traces, layout);
}
/*
function updatePlotWithCurrent(currH) {
    let traces = [];
    let currentBounds = null;

    // 1. Background
    if(state.mode !== 'collect' && state.mode !== 'auto') {
        if(!state.cachedBackground) state.cachedBackground = generateVoronoiBackground();
        if(state.cachedBackground) {
            traces.push(state.cachedBackground);
            currentBounds = state.cachedBackground._bounds; // –î—ñ—Å—Ç–∞—î–º–æ –º–µ–∂—ñ –∑ —Ñ–æ–Ω—É
        }
    }

    // –Ø–∫—â–æ —Ñ–æ–Ω—É –Ω–µ–º–∞—î (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —â–µ –Ω–µ –≤—á–∏–ª–∏—Å—å), —Ä–∞—Ö—É—î–º–æ –º–µ–∂—ñ –∑–∞—Ä–∞–∑
    if (!currentBounds) currentBounds = getDynamicBounds();

    // 2. Training Points
    const colors = ['#16a34a', '#dc2626', '#2563eb'];
    for(let c=0; c<3; c++) {
        const pts = state.samples.filter(s=>s.label===c).map(s=>net.forward(s.input).h);
        if(pts.length>0) {
            traces.push({
                x: pts.map(p=>p[0]), y: pts.map(p=>p[1]),
                mode: 'markers', type: 'scatter', name: ['Happy','Sad','Cat'][c],
                marker: { color: colors[c], size: 8, line:{width:1, color:'black'} }
            });
        }
    }

    // 3. Current Cross
    if(currH) {
        traces.push({
            x: [currH[0]], y: [currH[1]],
            mode: 'markers', type: 'scatter', name: '–í–∏ —Ç—É—Ç',
            marker: { symbol: 'cross', size: 20, color: 'black', line:{width:4} }
        });
    }

    // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è Layout –∑ –¥–∏–Ω–∞–º—ñ—á–Ω–∏–º–∏ –º–µ–∂–∞–º–∏
    const layout = {
        margin: {t:30, l:30, r:10, b:30},
        xaxis: { range: currentBounds.x, title:'–ù–µ–π—Ä–æ–Ω 1', automargin: true },
        yaxis: { range: currentBounds.y, title:'–ù–µ–π—Ä–æ–Ω 2', automargin: true },
        showlegend: false, hovermode: false
    };

    Plotly.react('latentPlot', traces, layout);
}

*/

function updateLossPlot() {
    Plotly.newPlot('lossPlot', [{
        y: state.losses, type: 'scatter', mode: 'lines', line: {color:'#4f46e5'}
    }], {
        margin: {t:20,l:40,r:10,b:30}, title:'Loss', xaxis:{title:'Epochs'}, yaxis:{range:[0, Math.max(1,...state.losses)]}
    }, {staticPlot:true});
}

async function runAutoAnimation() {
    // 1. –ü–†–ò–ë–†–ê–õ–ò –ø–µ—Ä–µ–≤—ñ—Ä–∫—É confirm —ñ –æ—á–∏—â–µ–Ω–Ω—è (state.samples=[])
    // –¢–µ–ø–µ—Ä –º–∏ –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –≤ —Ä–µ–∂–∏–º "auto" —ñ –¥–æ–¥–∞—î–º–æ –¥–∞–Ω—ñ –ø–æ–≤–µ—Ä—Ö —ñ—Å–Ω—É—é—á–∏—Ö
    
    state.mode = 'auto';
    document.getElementById('statusBadge').className = 'mode-badge mode-auto';
    document.getElementById('statusBadge').innerText = '–ï—Ç–∞–ø 1: –ê–≤—Ç–æ-–≥–µ–Ω–µ—Ä–∞—Ü—ñ—è (–ê–Ω—ñ–º–∞—Ü—ñ—è)...';
    
    // –ë–ª–æ–∫—É—î–º–æ –∫–Ω–æ–ø–∫–∏
    ['btnTrain','btnAuto','btnReset','btnCls0','btnCls1','btnCls2'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.disabled=true;
    });

    // 2. –ó–ú–Ü–ù–ò–õ–ò –õ–û–ì–Ü–ö–£ –¶–ò–ö–õ–£
    // –î–æ–¥–∞—î–º–æ 30 –Ω–æ–≤–∏—Ö –ø—Ä–∏–∫–ª–∞–¥—ñ–≤ (–ø–æ 10 –∫–æ–∂–Ω–æ–≥–æ –≤–∏–¥—É), –Ω–µ –æ–≥–ª—è–¥–∞—é—á–∏—Å—å –Ω–∞ —Ç–µ, —Å–∫—ñ–ª—å–∫–∏ –≤–∂–µ —î.
    const totalNewSamples = 30;

    for(let i=0; i<totalNewSamples; i++) {
        // –ü—Ä–æ—Å—Ç–æ —á–µ—Ä–≥—É—î–º–æ: 0 (–í–µ—Å–µ–ª–∏–π), 1 (–°—É–º–Ω–∏–π), 2 (–ö—ñ—Ç)...
        let lbl = i % 3;

        drawRandomShape(lbl);
        smallCtx.drawImage(bigC, 0,0,16,16); // –æ–Ω–æ–≤–ª—é—î–º–æ UI
        
        // –ß–µ–∫–∞—î–º–æ 100–º—Å (—Ç—Ä–æ—Ö–∏ —à–≤–∏–¥—à–µ, —â–æ–± –Ω–µ —á–µ–∫–∞—Ç–∏ –≤—ñ—á–Ω—ñ—Å—Ç—å)
        await new Promise(r => setTimeout(r, 100));

        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ
        const input = getPixels();
        state.samples.push({input, label:lbl});
        state.counts[lbl]++;
        document.getElementById(`cnt${lbl}`).innerText = `(${state.counts[lbl]})`;
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —Ç—ñ–ª—å–∫–∏ —Ç–æ—á–∫–∏ –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É
        updatePlotWithCurrent(null);
    }

    // –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è
    clearCanvas();
    state.mode = 'collect';
    document.getElementById('statusBadge').className = 'mode-badge mode-collect';
    document.getElementById('statusBadge').innerText = '–ï—Ç–∞–ø 1: –ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–æ';
    
    // –†–æ–∑–±–ª–æ–∫—É—î–º–æ –∫–Ω–æ–ø–∫–∏
    ['btnAuto','btnReset','btnCls0','btnCls1','btnCls2'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.disabled=false;
    });
    
    checkReadyToTrain();
}
/*
// --- ANIMATED AUTO-GENERATION ---
async function runAutoAnimation() {
    if(state.samples.length>0 && !confirm("–í–∏–¥–∞–ª–∏—Ç–∏ –ø–æ—Ç–æ—á–Ω—ñ –¥–∞–Ω—ñ?")) return;
    
    // UI Setup
    state.samples=[]; state.counts=[0,0,0];
    state.mode = 'auto';
    document.getElementById('statusBadge').className = 'mode-badge mode-auto';
    document.getElementById('statusBadge').innerText = '–ï—Ç–∞–ø 1: –ê–≤—Ç–æ-–≥–µ–Ω–µ—Ä–∞—Ü—ñ—è (–ê–Ω—ñ–º–∞—Ü—ñ—è)...';
    
    // Lock buttons
    ['btnTrain','btnAuto','btnReset','btnCls0','btnCls1','btnCls2'].forEach(id=>document.getElementById(id).disabled=true);

    const samplesPerClass = 10;
    const total = 3 * samplesPerClass;

    for(let i=0; i<total; i++) {
        // Randomly pick a class that isn't full yet
        let lbl;
        do { lbl = Math.floor(Math.random()*3); } 
        while(state.counts[lbl] >= samplesPerClass);

        drawRandomShape(lbl);
        smallCtx.drawImage(bigC, 0,0,16,16); // force UI update
        
        // Wait 200ms
        await new Promise(r => setTimeout(r, 200));

        // Save
        const input = getPixels();
        state.samples.push({input, label:lbl});
        state.counts[lbl]++;
        document.getElementById(`cnt${lbl}`).innerText = `(${state.counts[lbl]})`;
        
        // Update Plot (just points)
        updatePlotWithCurrent(null);
    }

    // Finish
    clearCanvas();
    state.mode = 'collect';
    document.getElementById('statusBadge').className = 'mode-badge mode-collect';
    document.getElementById('statusBadge').innerText = '–ï—Ç–∞–ø 1: –ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–æ';
    
    // Unlock
    ['btnAuto','btnReset','btnCls0','btnCls1','btnCls2'].forEach(id=>document.getElementById(id).disabled=false);
    checkReadyToTrain();
}


*/


function drawRandomShape(type) {
    bigCtx.fillStyle="white"; bigCtx.fillRect(0,0,200,200);
    bigCtx.strokeStyle="black"; bigCtx.lineWidth=15; bigCtx.lineJoin='round'; bigCtx.lineCap='round';
    
    // 1. –ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è (—â–æ–± –ø—Ä–∏–≤—á–∏—Ç–∏ –º–µ—Ä–µ–∂—É –¥–æ —Ä—ñ–∑–Ω–∏—Ö —Ä–æ–∑–º—ñ—Ä—ñ–≤)
    const scale = 0.5 + Math.random() * 0.5; 
    
    const noise = () => (Math.random()-0.5)*20;
    const cx = 100 + noise(); 
    const cy = 100 + noise();
    
    bigCtx.save();
    bigCtx.translate(cx, cy);
    bigCtx.scale(scale, scale);
    bigCtx.translate(-cx, -cy);
    
    // –ì–æ–ª–æ–≤–∞ (–°–ø—ñ–ª—å–Ω–∞ –¥–ª—è –≤—Å—ñ—Ö)
    bigCtx.beginPath(); bigCtx.arc(cx, cy, 75, 0, Math.PI*2); bigCtx.stroke();
    
    // –û—á—ñ (–°–ø—ñ–ª—å–Ω—ñ)
    bigCtx.fillStyle="black";
    bigCtx.fillRect(cx-30, cy-30, 15, 15);
    bigCtx.fillRect(cx+15, cy-30, 15, 15);
    
    bigCtx.beginPath();
    
    if(type===0) { // –í–µ—Å–µ–ª–∏–π (Happy)
        bigCtx.arc(cx, cy, 50, 0.2*Math.PI, 0.8*Math.PI);
    } else if(type===1) { // –°—É–º–Ω–∏–π (Sad)
        bigCtx.arc(cx, cy+60, 50, 1.2*Math.PI, 1.8*Math.PI);
    } else { // –ö—ñ—Ç (Cat)
        // --- –ù–û–í–Ü –í–£–•–ê (–ó–≤–µ—Ä—Ö—É, —à–∏—Ä–æ–∫—ñ —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫–∏) ---
        // –õ—ñ–≤–µ –≤—É—Ö–æ
        bigCtx.moveTo(cx - 55, cy - 45);  // –°—Ç–∞—Ä—Ç –∑–±–æ–∫—É –≥–æ–ª–æ–≤–∏ (–≤–∏—â–µ –Ω—ñ–∂ —Ä–∞–Ω—ñ—à–µ)
        bigCtx.lineTo(cx - 50, cy - 110); // –ö—ñ–Ω—á–∏–∫ –≤–≥–æ—Ä—É
        bigCtx.lineTo(cx - 15, cy - 70);  // –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –Ω–∞ –º–∞–∫—ñ–≤–∫—É
        
        // –ü—Ä–∞–≤–µ –≤—É—Ö–æ
        bigCtx.moveTo(cx + 55, cy - 45);
        bigCtx.lineTo(cx + 50, cy - 110);
        bigCtx.lineTo(cx + 15, cy - 70);

        // --- –ù–û–í–ò–ô –ù–Ü–°-–†–û–¢ (–ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç–∞ –¢) ---
        // –ù—ñ—Å (–º–∞–ª–µ–Ω—å–∫–∏–π —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫)
        bigCtx.moveTo(cx - 10, cy + 10);
        bigCtx.lineTo(cx + 10, cy + 10);
        bigCtx.lineTo(cx, cy + 20);
        bigCtx.lineTo(cx - 10, cy + 10);

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ —Ä–∏—Å–∫–∞
        bigCtx.moveTo(cx, cy + 20);
        bigCtx.lineTo(cx, cy + 40);

        // –†–æ—Ç (–¥—É–∂–∫–∏ –≤ —Å—Ç–æ—Ä–æ–Ω–∏)
        bigCtx.moveTo(cx - 20, cy + 45); 
        bigCtx.quadraticCurveTo(cx, cy + 50, cx + 20, cy + 45);
    }
    bigCtx.stroke();
    
    bigCtx.restore();
}
function changeActivation() {
    state.actName = document.getElementById('actFunc').value;
    state.cachedBackground = null;
    updatePlotWithCurrent(null); 
}

function resetAll() { location.reload(); }

// Init plots
Plotly.newPlot('latentPlot', [], {title:' '});
Plotly.newPlot('lossPlot', [], {title:' '});

</script>
</body>
</html>
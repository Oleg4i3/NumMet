<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–∏–º—É–ª—è—Ç–æ—Ä –°–ø–ª–∞–π–Ω—ñ–≤ (v5.3 - –∑ Catmull-Rom)</title>
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .controls {
            flex: 1;
            min-width: 300px;
            background: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .canvas-container {
            flex: 2;
            min-width: 400px;
            position: relative;
        }
        canvas {
            border: 1px solid #aaa;
            background-color: #fff;
            border-radius: 8px;
            cursor: crosshair;
        }
        .controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .controls select, .controls button {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; 
        }
        .controls button {
            background-color: #e74c3c;
            color: white;
            border: none;
            cursor: pointer;
        }
        .controls button:hover {
            background-color: #c0392b;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #ecf0f1;
        }
        td input {
            width: 90%;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            text-align: center;
        }

        #gradient-controls {
            display: none; 
            background-color: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .slider-container {
            margin-bottom: 10px;
        }
        .slider-container label {
            font-size: 0.9em;
            font-weight: normal;
            display: flex;
            justify-content: space-between;
        }
        .slider-container input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        #view-controls {
            margin-bottom: 10px; 
            padding: 10px; 
            background: #f9f9f9; 
            border-radius: 4px; 
            border: 1px solid #ddd; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 10px; 
            align-items: center; 
            font-size: 0.9em;
        }
        #view-controls label {
            display: inline-block;
            margin-bottom: 0;
            font-weight: normal;
        }
        #view-controls input {
            width: 60px;
            padding: 4px;
        }
        #view-controls button {
            width: auto;
            padding: 5px 10px;
            margin-bottom: 0;
            font-size: 0.9em;
        }
        
        .hidden-control {
            display: none !important;
        }

        #equations-container {
            width: 100%;
            margin-top: 20px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #equations-container h3 {
            margin-top: 0;
        }
        #equations-container div {
            font-family: "Courier New", Courier, monospace;
            font-size: 0.95em;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 5px;
            overflow-x: auto; 
        }
        #equations-container .mathjax-explanation {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 0.9em;
            color: #333;
            margin-top: 10px;
            line-height: 1.6;
        }
        
        #theory {
            width: 100%;
            margin-top: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #theory summary {
            padding: 20px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            color: #2980b9;
        }
        #theory-content {
            padding: 0 20px 20px 20px;
            border-top: 1px solid #eee;
            font-family: "Times New Roman", Times, serif;
            font-size: 1.1em;
            line-height: 1.7;
        }
    </style>
</head>
<body>

    <h1>üìê –°–∏–º—É–ª—è—Ç–æ—Ä –°–ø–ª–∞–π–Ω—ñ–≤ </h1>

    <div class="container">
        <div class="controls">
            <h2>–ü–∞–Ω–µ–ª—å –∫–µ—Ä—É–≤–∞–Ω–Ω—è</h2>
            
            <label for="splineType">–¢–∏–ø —Å–ø–ª–∞–π–Ω–∞:</label>
            <select id="splineType">
                <option value="cubic">–ö—É–±—ñ—á–Ω–∏–π (Natural/Clamped)</option>
                <option value="catmull_rom">Catmull-Rom </option>
                <option value="quadratic">–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∏–π (–Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è)</option>
                <option value="b_spline">B-spline (–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è)</option>
            </select>

            <div id="alphaControl" style="display: none;"> <label for="alphaSlider">–ù–∞–ø—Ä—É–∂–µ–Ω—ñ—Å—Ç—å (Alpha): <span id="alphaValue">0.5</span></label>
                <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.5" class="slider">
                <small><i>(0.5 = Catmull-Rom, 0 = –û—Å–ª–∞–±–ª–µ–Ω–∞, 1 = –ü–µ—Ä–µ—Ç—è–≥–Ω—É—Ç–∞)</i></small>
            </div>
			
			
            <div id="boundary-controls-container">
                <label for="boundaryCond">–ö—Ä–∞–π–æ–≤—ñ —É–º–æ–≤–∏:</label>
                <select id="boundaryCond">
                    </select>

                <div id="gradient-controls">
                    <div class="slider-container">
                        <label for="startSlope">–ü–æ—á–∞—Ç–∫–æ–≤–∏–π –Ω–∞—Ö–∏–ª S'(x‚ÇÄ): <span id="startSlopeValue">0.0</span></label>
                        <input type="range" id="startSlope" min="-10" max="10" step="0.1" value="0">
                    </div>
                    <div class="slider-container">
                        <label for="endSlope">–ö—ñ–Ω—Ü–µ–≤–∏–π –Ω–∞—Ö–∏–ª S'(x‚Çô‚Çã‚ÇÅ): <span id="endSlopeValue">0.0</span></label>
                        <input type="range" id="endSlope" min="-10" max="10" step="0.1" value="0">
                    </div>
                </div>
            </div>
            
            <button id="clearButton">–û—á–∏—Å—Ç–∏—Ç–∏ —Ç–æ—á–∫–∏</button>

            <h3>–¢–æ—á–∫–∏ (–º–∞–∫—Å. 8)</h3>
            <p style="font-size: 0.9em; color: #555;">–ö–ª—ñ–∫–Ω—ñ—Ç—å –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É –∞–±–æ –≤–≤–µ–¥—ñ—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –≤ —Ç–∞–±–ª–∏—Ü—é.</p>
            <table id="pointsTable">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>X</th>
                        <th>Y</th>
                    </tr>
                </thead>
                <tbody id="pointsTableBody">
                    </tbody>
            </table>
        </div>

        <div class="canvas-container">
            
            <div id="view-controls">
                <b>–ö–µ—Ä—É–≤–∞–Ω–Ω—è –≤–∏–¥–æ–º:</b>
                <label>X min: <input type="number" id="viewMinX" step="10"></label>
                <label>X max: <input type="number" id="viewMaxX" step="10"></label>
                <label>Y min: <input type="number" id="viewMinY" step="10"></label>
                <label>Y max: <input type="number" id="viewMaxY" step="10"></label>
                <button id="applyViewButton" style="background-color: #3498db;">–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏</button>
                <button id="resetViewButton" style="background-color: #95a5a6;">–°–∫–∏–Ω—É—Ç–∏</button>
            </div>
            
            <canvas id="splineCanvas" width="600" height="400"></canvas>
        </div>
    </div>

    <div id="equations-container">
        <h3>–†—ñ–≤–Ω—è–Ω–Ω—è / –û–ø–∏—Å</h3>
        <div id="equations-list">
            <p>–î–æ–¥–∞–π—Ç–µ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ 2 —Ç–æ—á–∫–∏, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —Ä—ñ–≤–Ω—è–Ω–Ω—è.</p>
        </div>
    </div>

    <details id="theory" open>
        <summary>üìò –¢–µ–æ—Ä–µ—Ç–∏—á–Ω—ñ –≤—ñ–¥–æ–º–æ—Å—Ç—ñ</summary>
        <div id="theory-content">
           
            <p><b>–°–ø–ª–∞–π–Ω</b> ‚Äî —Ü–µ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è, —è–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –≤ —á–∏—Å–µ–ª—å–Ω–∏—Ö –º–µ—Ç–æ–¥–∞—Ö –¥–ª—è —ñ–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—ó —Ç–∞ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è. –í–æ–Ω–∞ —è–≤–ª—è—î —Å–æ–±–æ—é "–∑—à–∏—Ç—É" –∑ –∫—ñ–ª—å–∫–æ—Ö –ø–æ–ª—ñ–Ω–æ–º—ñ–∞–ª—å–Ω–∏—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –∫—Ä–∏–≤—É. –ì–æ–ª–æ–≤–Ω–∞ –ø–µ—Ä–µ–≤–∞–≥–∞ —Å–ø–ª–∞–π–Ω—ñ–≤ ‚Äî –≤–æ–Ω–∏ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –æ—Ç—Ä–∏–º–∞—Ç–∏ –≥–ª–∞–¥–∫—É –∫—Ä–∏–≤—É, —â–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ –∑–∞–¥–∞–Ω–∏–π –Ω–∞–±—ñ—Ä —Ç–æ—á–æ–∫ (–≤—É–∑–ª—ñ–≤), –ø—Ä–∏ —Ü—å–æ–º—É —É–Ω–∏–∫–∞—é—á–∏ "–µ—Ñ–µ–∫—Ç—É –†—É–Ω–≥–µ" (—Å–∏–ª—å–Ω–∏—Ö –∫–æ–ª–∏–≤–∞–Ω—å), —è–∫–∏–π —á–∞—Å—Ç–æ –≤–∏–Ω–∏–∫–∞—î –ø—Ä–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—ñ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—ñ–Ω–æ–º–∞ –≤–∏—Å–æ–∫–æ–≥–æ —Å—Ç–µ–ø–µ–Ω—è.</p>
            
            <hr>
            
            <h2>–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∏–π —Å–ø–ª–∞–π–Ω (–Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è)</h2>
            <p>–î–ª—è $n$ —Ç–æ—á–æ–∫ $(x_0, y_0), \dots, (x_{n-1}, y_{n-1})$ –º–∏ –±—É–¥—É—î–º–æ $n-1$ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ $S_i(x)$ –Ω–∞ –≤—ñ–¥—Ä—ñ–∑–∫—É $[x_i, x_{i+1}]$:</p>
            $$S_i(x) = a_i (x-x_i)^2 + b_i (x-x_i) + c_i$$
            <p><b>–£–º–æ–≤–∏:</b> $S_i(x_i) = y_i$, $S_i(x_{i+1}) = y_{i+1}$ ($C^0$ –Ω–µ–ø–µ—Ä–µ—Ä–≤–Ω—ñ—Å—Ç—å) —Ç–∞ $S'_{i-1}(x_i) = S'_i(x_i)$ ($C^1$ –≥–ª–∞–¥–∫—ñ—Å—Ç—å). –¶–µ –∑–∞–ª–∏—à–∞—î 1 —Å—Ç—É–ø—ñ–Ω—å —Å–≤–æ–±–æ–¥–∏, —è–∫–∏–π –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –∫—Ä–∞–π–æ–≤–æ—é —É–º–æ–≤–æ—é (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, $S'_0(x_0) = 0$).</p>

            <hr>

            <h2>–ö—É–±—ñ—á–Ω–∏–π —Å–ø–ª–∞–π–Ω (–Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è, $C^2$)</h2>
            <p>–¶–µ –Ω–∞–π–ø–æ—à–∏—Ä–µ–Ω—ñ—à–∏–π "–∞–∫–∞–¥–µ–º—ñ—á–Ω–∏–π" —Ç–∏–ø ($C^2$ –≥–ª–∞–¥–∫—ñ—Å—Ç—å). –î–ª—è $n$ —Ç–æ—á–æ–∫ –º–∏ –±—É–¥—É—î–º–æ $n-1$ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ $S_i(x)$:</p>
            $$S_i(x) = a_i (x-x_i)^3 + b_i (x-x_i)^2 + c_i (x-x_i) + d_i$$
            <p><b>–£–º–æ–≤–∏:</b> $C^0$, $C^1$ —Ç–∞ $C^2$ –Ω–µ–ø–µ—Ä–µ—Ä–≤–Ω—ñ—Å—Ç—å —É –≤—É–∑–ª–∞—Ö. –¶–µ –∑–∞–ª–∏—à–∞—î 2 —Å—Ç—É–ø–µ–Ω—ñ —Å–≤–æ–±–æ–¥–∏, —è–∫—ñ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å—Å—è –∫—Ä–∞–π–æ–≤–∏–º–∏ —É–º–æ–≤–∞–º–∏ (Natural, Clamped).</p>
            <p><b>–û—Å–æ–±–ª–∏–≤—ñ—Å—Ç—å:</b> –†–æ–∑–≤'—è–∑—É—î—Ç—å—Å—è –≥–ª–æ–±–∞–ª—å–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ —Ä—ñ–≤–Ω—è–Ω—å. –ó–º—ñ–Ω–∞ –æ–¥–Ω—ñ—î—ó —Ç–æ—á–∫–∏ –≤–ø–ª–∏–≤–∞—î –Ω–∞ –≤—Å—é –∫—Ä–∏–≤—É. –ú—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—è $S''$ (—É "Natural") –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ "–∑–∞–π–≤–∏—Ö" –æ—Å—Ü–∏–ª—è—Ü—ñ–π –¥–∞–ª–µ–∫–æ –≤—ñ–¥ –≤—É–∑–ª—ñ–≤.</p>

            <hr>
            
            <h2>–°–ø–ª–∞–π–Ω –ö–∞—Ç–º—É–ª–ª–∞-–†–æ–º–∞ (–Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è, $C^1$)</h2>
            <p>–¶–µ —Ç–µ–∂ –∫—É–±—ñ—á–Ω–∏–π —Å–ø–ª–∞–π–Ω, –∞–ª–µ —ñ–Ω—à–æ–≥–æ —Ç–∏–ø—É. –í—ñ–Ω **–≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ –≤—Å—ñ —Ç–æ—á–∫–∏** (—ñ–Ω—Ç–µ—Ä–ø–æ–ª—é—î), –∞–ª–µ –º–∞—î –ª–∏—à–µ $C^1$ –≥–ª–∞–¥–∫—ñ—Å—Ç—å. –¶–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç –¥–ª—è –ø–ª–∞–≤–Ω–æ—ó –∞–Ω—ñ–º–∞—Ü—ñ—ó —Ç–∞ –≥—Ä–∞—Ñ—ñ–∫—ñ–≤, —è–∫ –≤ Excel.</p>
            <p><b>–û—Å–æ–±–ª–∏–≤—ñ—Å—Ç—å:</b> –¶–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω–∞ –∫—Ä–∏–≤–∞ $C(t)$. –°–µ–≥–º–µ–Ω—Ç $S_i(t)$ (–≤—ñ–¥ $P_i$ –¥–æ $P_{i+1}$, –¥–µ $t \in [0, 1]$) –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è —á–æ—Ç–∏—Ä–º–∞ —Ç–æ—á–∫–∞–º–∏: $P_{i-1}, P_i, P_{i+1}, P_{i+2}$.</p>
            <p>–î–æ—Ç–∏—á–Ω–∞ (–Ω–∞—Ö–∏–ª) —É –∫–æ–∂–Ω—ñ–π —Ç–æ—á—Ü—ñ $P_i$ –Ω–µ —Ä–æ–∑–≤'—è–∑—É—î—Ç—å—Å—è –≥–ª–æ–±–∞–ª—å–Ω–æ, –∞ –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞ —Ñ–æ—Ä–º—É–ª–æ—é, —â–æ –±–∞–∑—É—î—Ç—å—Å—è –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ—Ö —Ç–æ—á–∫–∞—Ö:</p>
            $$T_i = \alpha (P_{i+1} - P_{i-1})$$
            <p>(–¥–µ $\alpha$ - "–Ω–∞–ø—Ä—É–∂–µ–Ω—ñ—Å—Ç—å", –∑–∞–∑–≤–∏—á–∞–π 0.5). –¶–µ —Ä–æ–±–∏—Ç—å –π–æ–≥–æ –ø–æ–≤–µ–¥—ñ–Ω–∫—É –¥—É–∂–µ "–ª–æ–∫–∞–ª—å–Ω–æ—é" —Ç–∞ –≤—ñ–∑—É–∞–ª—å–Ω–æ –ø—Ä–∏—î–º–Ω–æ—é, —É–Ω–∏–∫–∞—é—á–∏ —à–∏—Ä–æ–∫–∏—Ö –æ—Å—Ü–∏–ª—è—Ü—ñ–π "Natural" —Å–ø–ª–∞–π–Ω–∞.</p>
            
            <hr>

            <h2>B-—Å–ø–ª–∞–π–Ω (–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è)</h2>
            <p>–ù–∞ –≤—ñ–¥–º—ñ–Ω—É –≤—ñ–¥ —ñ–Ω—Ç–µ—Ä–ø–æ–ª—é—é—á–∏—Ö —Å–ø–ª–∞–π–Ω—ñ–≤, <b>B-—Å–ø–ª–∞–π–Ω–∏</b> –∑–∞–∑–≤–∏—á–∞–π –Ω–µ –ø—Ä–æ—Ö–æ–¥—è—Ç—å —á–µ—Ä–µ–∑ –∑–∞–¥–∞–Ω—ñ —Ç–æ—á–∫–∏. –ù–∞—Ç–æ–º—ñ—Å—Ç—å —Ç–æ—á–∫–∏ –≤–∏—Å—Ç—É–ø–∞—é—Ç—å —è–∫ <b>"–∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏"</b>, —è–∫—ñ "–ø—Ä–∏—Ç—è–≥—É—é—Ç—å" –¥–æ —Å–µ–±–µ –∫—Ä–∏–≤—É.</p>
            <p>–ö—Ä–∏–≤–∞ B-—Å–ø–ª–∞–π–Ω–∞ –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è —è–∫ $C(t) = \sum_{i=0}^{n-1} P_i N_{i,p}(t)$.</p>
            <p><b>–ü–µ—Ä–µ–≤–∞–≥–∏:</b> –ù–∞–¥–∑–≤–∏—á–∞–π–Ω–∞ –≥–ª–∞–¥–∫—ñ—Å—Ç—å, —ñ–¥–µ–∞–ª—å–Ω–æ –¥–ª—è –ø–æ–∫–∞–∑—É —Ç—Ä–µ–Ω–¥—ñ–≤ –∑–∞—à—É–º–ª–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö, —ñ–≥–Ω–æ—Ä—É—î "–≤–∏–∫–∏–¥–∏".</p>

            <hr>

            <h2>–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑ —ñ–Ω—à–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏</h2>
            <table style="width:100%; border-collapse: collapse;">
                <thead style="background-color: #ecf0f1;">
                    <tr>
                        <th style="border: 1px solid #ddd; padding: 8px;">–ú–µ—Ç–æ–¥</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">–Ü–Ω—Ç–µ—Ä–ø–æ–ª—é—î? (–ü—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ —Ç–æ—á–∫–∏)</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">–ü–µ—Ä–µ–≤–∞–≥–∏</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">–ù–µ–¥–æ–ª—ñ–∫–∏</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>–ü–æ–ª—ñ–Ω–æ–º –õ–∞–≥—Ä–∞–Ω–∂–∞</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>–¢–∞–∫</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- –û–¥–Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è.</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- <b>–ï—Ñ–µ–∫—Ç –†—É–Ω–≥–µ:</b> —Å–∏–ª—å–Ω—ñ –∫–æ–ª–∏–≤–∞–Ω–Ω—è.</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>–ö—É–±—ñ—á–Ω–∏–π (Natural)</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>–¢–∞–∫</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- <b>–ì–ª–∞–¥–∫—ñ—Å—Ç—å $C^2$</b> (–Ω–µ–ø–µ—Ä–µ—Ä–≤–Ω–∞ –∫—Ä–∏–≤–∏–Ω–∞).<br>- –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ "—ñ–¥–µ–∞–ª—å–Ω–∏–π".</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- –ì–ª–æ–±–∞–ª—å–Ω–∏–π –≤–ø–ª–∏–≤ (–∑–º—ñ–Ω–∞ 1 —Ç–æ—á–∫–∏ = –∑–º—ñ–Ω–∞ –≤—Å—ñ—î—ó –∫—Ä–∏–≤–æ—ó).<br>- –ú–æ–∂–µ —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ "–∑–∞–π–≤—ñ" —Ö–≤–∏–ª—ñ.</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>Catmull-Rom</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>–¢–∞–∫</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- <b>–Ø–∫ –≤ Excel/Spreadsheets.</b><br>- –í—ñ–∑—É–∞–ª—å–Ω–æ –ø–ª–∞–≤–Ω–∏–π.<br>- –õ–æ–∫–∞–ª—å–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å (–∑–º—ñ–Ω–∞ 1 —Ç–æ—á–∫–∏ = –∑–º—ñ–Ω–∞ –ø–æ—Ä—É—á).</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- –õ–∏—à–µ $C^1$ –≥–ª–∞–¥–∫—ñ—Å—Ç—å (–∫—Ä–∏–≤–∏–Ω–∞ –º–æ–∂–µ "—Å—Ç—Ä–∏–±–∞—Ç–∏" —É –≤—É–∑–ª–∞—Ö).<br>- –ú–æ–∂–µ —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –ø–µ—Ç–ª—ñ.</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>B-—Å–ø–ª–∞–π–Ω</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>–ù—ñ</b> (–ê–ø—Ä–æ–∫—Å–∏–º—É—î)</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- <b>–ù–∞–π–≤–∏—â–∞ –≥–ª–∞–¥–∫—ñ—Å—Ç—å.</b><br>- –Ü–¥–µ–∞–ª—å–Ω–æ –¥–ª—è —Ç—Ä–µ–Ω–¥—ñ–≤/—à—É–º—É.<br>- –õ–æ–∫–∞–ª—å–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å.</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">- –ù–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ —Ç–æ—á–∫–∏ (—Ü–µ –π–æ–≥–æ –º–µ—Ç–∞).</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </details>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- –û—Ç—Ä–∏–º–∞–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ DOM ---
            const canvas = document.getElementById('splineCanvas');
            const ctx = canvas.getContext('2d');
            const splineTypeSelect = document.getElementById('splineType');
            const boundaryCondSelect = document.getElementById('boundaryCond');
            const pointsTableBody = document.getElementById('pointsTableBody');
            const clearButton = document.getElementById('clearButton');
            const equationsList = document.getElementById('equations-list');

            const boundaryControlsContainer = document.getElementById('boundary-controls-container'); 
            const gradientControls = document.getElementById('gradient-controls');
            const startSlope = document.getElementById('startSlope');
            const startSlopeValue = document.getElementById('startSlopeValue');
            const endSlope = document.getElementById('endSlope');
            const endSlopeValue = document.getElementById('endSlopeValue');

            // *** –ù–û–í–Ü –ï–õ–ï–ú–ï–ù–¢–ò –î–õ–Ø CATMULL-ROM ***
            const alphaControl = document.getElementById('alphaControl');
            const alphaSlider = document.getElementById('alphaSlider');
            const alphaValue = document.getElementById('alphaValue');

            let points = [];
            const MAX_POINTS = 8;
            const POINT_RADIUS = 5;
            const segmentColors = ['#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#1abc9c', '#34495e'];

            const DEFAULT_VIEW = { minX: 0, maxX: 600, minY: 0, maxY: 400 };
            let view = { ...DEFAULT_VIEW };

            const viewMinXInput = document.getElementById('viewMinX');
            const viewMaxXInput = document.getElementById('viewMaxX');
            const viewMinYInput = document.getElementById('viewMinY');
            const viewMaxYInput = document.getElementById('viewMaxY');
            const applyViewButton = document.getElementById('applyViewButton');
            const resetViewButton = document.getElementById('resetViewButton');
            
            // === –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–∞ –û–Ω–æ–≤–ª–µ–Ω–Ω—è UI ===

            function updateBoundaryOptions() {
                const type = splineTypeSelect.value;
                const currentBoundary = boundaryCondSelect.value;
                boundaryCondSelect.innerHTML = ''; 
                
                // *** –û–ù–û–í–õ–ï–ù–û: –•–æ–≤–∞—î–º–æ –¥–ª—è B-spline –¢–ê Catmull-Rom ***
                if (type === 'b_spline' || type === 'catmull_rom') {
                    boundaryControlsContainer.classList.add('hidden-control');
                } else {
                    boundaryControlsContainer.classList.remove('hidden-control');
                }
                
                // *** –û–ù–û–í–õ–ï–ù–û: –ü–æ–∫–∞–∑—É—î–º–æ/—Ö–æ–≤–∞—î–º–æ —Å–ª–∞–π–¥–µ—Ä Alpha ***
                if (type === 'catmull_rom') {
                    alphaControl.style.display = 'block';
                } else {
                    alphaControl.style.display = 'none';
                }

                // (—Ü—è –ª–æ–≥—ñ–∫–∞ –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è, –∞–ª–µ boundaryControlsContainer –≤–∂–µ –ø—Ä–∏—Ö–æ–≤–∞–Ω–∏–π, —è–∫—â–æ —Ç—Ä–µ–±–∞)
                if (type === 'cubic') {
                    boundaryCondSelect.innerHTML = `
                        <option value="natural">Natural (S'' = 0 –Ω–∞ –∫—ñ–Ω—Ü—è—Ö)</option>
                        <option value="clamped">Clamped (–ó–∞—Ç–∏—Å–Ω—É—Ç–∏–π)</option>
                    `;
                    if (currentBoundary === 'natural' || currentBoundary === 'clamped') {
                        boundaryCondSelect.value = currentBoundary;
                    }
                } else if (type === 'quadratic') {
                    boundaryCondSelect.innerHTML = `
                        <option value="start_zero">Simple (S' = 0 –Ω–∞ –ø–æ—á–∞—Ç–∫—É)</option>
                        <option value="end_zero">Simple (S' = 0 –≤ –∫—ñ–Ω—Ü—ñ)</option>
                    `;
                    if (currentBoundary === 'start_zero' || currentBoundary === 'end_zero') {
                        boundaryCondSelect.value = currentBoundary;
                    }
                }
                
                toggleGradientControls(); 
                mainDraw();
            }
            
            function toggleGradientControls() {
                const type = splineTypeSelect.value;
                const boundary = boundaryCondSelect.value;
                
                if (type === 'cubic' && boundary === 'clamped') {
                    gradientControls.style.display = 'block';
                } else {
                    gradientControls.style.display = 'none';
                }
            }
            
            // --- –§—É–Ω–∫—Ü—ñ—ó: –°–∏—Å—Ç–µ–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, C—ñ—Ç–∫–∞, –í–∏–¥ ---
            
            function worldToPixel(worldX, worldY) {
                const pixelX = (worldX - view.minX) / (view.maxX - view.minX) * canvas.width;
                const pixelY = (1 - (worldY - view.minY) / (view.maxY - view.minY)) * canvas.height;
                return { x: pixelX, y: pixelY };
            }

            function pixelToWorld(pixelX, pixelY) {
                const worldX = (pixelX / canvas.width) * (view.maxX - view.minX) + view.minX;
                const worldY = (1 - pixelY / canvas.height) * (view.maxY - view.minY) + view.minY;
                return { x: worldX, y: worldY };
            }

            function updateInputsFromView() {
                viewMinXInput.value = view.minX.toFixed(0);
                viewMaxXInput.value = view.maxX.toFixed(0);
                viewMinYInput.value = view.minY.toFixed(0);
                viewMaxYInput.value = view.maxY.toFixed(0);
            }

            function updateViewFromInputs() {
                const minX = parseFloat(viewMinXInput.value);
                const maxX = parseFloat(viewMaxXInput.value);
                const minY = parseFloat(viewMinYInput.value);
                const maxY = parseFloat(viewMaxYInput.value);

                if (isNaN(minX) || isNaN(maxX) || isNaN(minY) || isNaN(maxY)) {
                    alert("–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –≤–∏–¥—É.");
                    return;
                }
                if (maxX <= minX || maxY <= minY) {
                    alert("Max –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–∏–º –∑–∞ Min.");
                    return;
                }
                view = { minX, maxX, minY, maxY };
                mainDraw();
            }
            
            function drawGrid() {
                ctx.save(); 
                ctx.strokeStyle = '#eee'; 
                ctx.lineWidth = 1;
                ctx.font = "10px Arial";
                ctx.fillStyle = "#aaa";
                ctx.textAlign = "left";
                ctx.textBaseline = "top";

                const xRange = view.maxX - view.minX;
                const yRange = view.maxY - view.minY;
                
                const xPower = Math.pow(10, Math.floor(Math.log10(xRange)) - 1);
                const xStep = (xRange / xPower > 20) ? xPower * 5 : (xRange / xPower > 10 ? xPower * 2 : xPower);
                
                const yPower = Math.pow(10, Math.floor(Math.log10(yRange)) - 1);
                const yStep = (yRange / yPower > 20) ? yPower * 5 : (yRange / yPower > 10 ? yPower * 2 : yPower);

                const xStart = Math.ceil(view.minX / xStep) * xStep;
                const yStart = Math.ceil(view.minY / yStep) * yStep;

                for (let x = xStart; x <= view.maxX; x += xStep) {
                    const { x: pixelX } = worldToPixel(x, 0); 
                    ctx.beginPath();
                    ctx.moveTo(pixelX, 0);
                    ctx.lineTo(pixelX, canvas.height);
                    ctx.stroke();
                    ctx.fillText(x.toFixed(1), pixelX + 2, 2);
                }
                
                for (let y = yStart; y <= view.maxY; y += yStep) {
                    const { y: pixelY } = worldToPixel(0, y); 
                    ctx.beginPath();
                    ctx.moveTo(0, pixelY);
                    ctx.lineTo(canvas.width, pixelY);
                    ctx.stroke();
                    ctx.fillText(y.toFixed(1), 2, pixelY + 2);
                }
                ctx.restore(); 
            }
            
            // === –û–±—Ä–æ–±–Ω–∏–∫–∏ –ø–æ–¥—ñ–π ===

            splineTypeSelect.addEventListener('change', updateBoundaryOptions);
            boundaryCondSelect.addEventListener('change', () => {
                toggleGradientControls();
                mainDraw();
            });
            
            clearButton.addEventListener('click', () => {
                points = [];
                mainDraw();
            });

            canvas.addEventListener('click', (e) => {
                if (points.length >= MAX_POINTS) {
                    alert(`–î–æ—Å—è–≥–Ω—É—Ç–æ –ª—ñ–º—ñ—Ç—É –≤ ${MAX_POINTS} —Ç–æ—á–æ–∫.`);
                    return;
                }
                const rect = canvas.getBoundingClientRect();
                const pixelX = e.clientX - rect.left;
                const pixelY = e.clientY - rect.top;
                
                const { x: worldX, y: worldY } = pixelToWorld(pixelX, pixelY);
                
                points.push({ x: worldX, y: worldY });
                mainDraw();
            });
            
            startSlope.addEventListener('input', () => {
                startSlopeValue.textContent = parseFloat(startSlope.value).toFixed(1);
                mainDraw();
            });
            endSlope.addEventListener('input', () => {
                endSlopeValue.textContent = parseFloat(endSlope.value).toFixed(1);
                mainDraw();
            });

            // *** –ù–û–í–ò–ô –û–ë–†–û–ë–ù–ò–ö –î–õ–Ø –°–õ–ê–ô–î–ï–†–ê ALPHA ***
            alphaSlider.addEventListener('input', () => {
                alphaValue.textContent = parseFloat(alphaSlider.value).toFixed(2);
                mainDraw();
            });
            
            applyViewButton.addEventListener('click', updateViewFromInputs);
            resetViewButton.addEventListener('click', () => {
                view = { ...DEFAULT_VIEW };
                updateInputsFromView();
                mainDraw();
            });
            
            // === –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è —Ç–∞–±–ª–∏—Ü—ñ —Ç–∞ —Ç–æ—á–æ–∫ ===

            function updateTableFromPoints() {
                pointsTableBody.innerHTML = '';
                let sortedPoints = [...points];
                
                // *** –û–ù–û–í–õ–ï–ù–û: –°–æ—Ä—Ç—É—î–º–æ –¥–ª—è –≤—Å—ñ—Ö, –∫—Ä—ñ–º B-spline (–¥–ª—è Catmull-Rom –ø–æ—Ä—è–¥–æ–∫ –∫–ª—ñ–∫—ñ–≤ —Ç–µ–∂ –º–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è) ***
                const type = splineTypeSelect.value;
                if (type === 'cubic' || type === 'quadratic') {
                    sortedPoints.sort((a, b) => a.x - b.x);
                }
                // –î–ª—è B-spline —Ç–∞ Catmull-Rom —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–µ, –ø–æ—Ä—è–¥–æ–∫ –≤–≤–µ–¥–µ–Ω–Ω—è –≤–∞–∂–ª–∏–≤–∏–π
                
                sortedPoints.forEach((point, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td><input type="number" step="0.1" class="point-input" data-index="${index}" data-coord="x" value="${point.x.toFixed(2)}"></td>
                        <td><input type="number" step="0.1" class="point-input" data-index="${index}" data-coord="y" value="${point.y.toFixed(2)}"></td>
                    `;
                    pointsTableBody.appendChild(row);
                });

                document.querySelectorAll('.point-input').forEach(input => {
                    input.addEventListener('change', updatePointsFromTable);
                });
            }

            function updatePointsFromTable() {
                const newPoints = [];
                const rows = pointsTableBody.querySelectorAll('tr');
                rows.forEach((row, index) => {
                    const xInput = row.querySelector('input[data-coord="x"]');
                    const yInput = row.querySelector('input[data-coord="y"]');
                    const x = parseFloat(xInput.value);
                    const y = parseFloat(yInput.value);
                    if (!isNaN(x) && !isNaN(y)) {
                        newPoints.push({ x, y });
                    }
                });
                points = newPoints;
                
                mainDraw();
            }

            // === –ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è (–û–±—á–∏—Å–ª–µ–Ω–Ω—è —Ç–∞ –†–µ–Ω–¥–µ—Ä–∏–Ω–≥) ===

            function mainDraw() {
                const type = splineTypeSelect.value;
                
                // *** –û–ù–û–í–õ–ï–ù–û: –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è ***
                if (type === 'cubic' || type === 'quadratic') {
                    points.sort((a, b) => a.x - b.x);
                }
                
                updateTableFromPoints();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                drawPoints(); 

                if (points.length < 2) {
                    equationsList.innerHTML = '<p>–ü–æ—Ç—Ä—ñ–±–Ω–æ —â–æ–Ω–∞–π–º–µ–Ω—à–µ 2 —Ç–æ—á–∫–∏.</p>';
                    return;
                }

                try {
                    if (type === 'b_spline') {
                        const bSplineDegree = 3; 
                        if (points.length <= bSplineDegree) { 
                            equationsList.innerHTML = `<p>B-—Å–ø–ª–∞–π–Ω (–∫—É–±—ñ—á–Ω–∏–π) –ø–æ—Ç—Ä–µ–±—É—î —â–æ–Ω–∞–π–º–µ–Ω—à–µ ${bSplineDegree + 1} –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏.</p>`;
                            return;
                        }
                        const bSplineCurvePoints = calculateBSplinePoints(points, bSplineDegree, 100);
                        drawParametricSpline(bSplineCurvePoints, '#007bff');
                        displayEquationsBSpline(points, bSplineDegree);
                    
                    } else if (type === 'catmull_rom') {
                        // *** –û–ù–û–í–õ–ï–ù–û: –ë–ª–æ–∫ Catmull-Rom –∑—ñ –∑—á–∏—Ç—É–≤–∞–Ω–Ω—è–º Alpha ***
                        if (points.length < 2) { 
                            equationsList.innerHTML = '<p>–°–ø–ª–∞–π–Ω –ö–∞—Ç–º—É–ª–ª–∞-–†–æ–º–∞ –ø–æ—Ç—Ä–µ–±—É—î —â–æ–Ω–∞–π–º–µ–Ω—à–µ 2 —Ç–æ—á–∫–∏.</p>';
                            return;
                        }
                        // *** –ó–ß–ò–¢–£–Ñ–ú–û ALPHA –ó–Ü –°–õ–ê–ô–î–ï–†–ê ***
                        const alpha = parseFloat(alphaSlider.value); 
                        
                        // *** –ü–ï–†–ï–î–ê–Ñ–ú–û ALPHA –í –û–ë–ß–ò–°–õ–ï–ù–ù–Ø ***
                        const crCurvePoints = calculateCatmullRomSpline(points, 20, alpha); // 20 –∫—Ä–æ–∫—ñ–≤ –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç
                        drawParametricSpline(crCurvePoints, '#28a745'); // –ú–∞–ª—é—î–º–æ –∑–µ–ª–µ–Ω–∏–º
                        
                        // *** –ü–ï–†–ï–î–ê–Ñ–ú–û ALPHA –£ –í–Ü–î–û–ë–†–ê–ñ–ï–ù–ù–Ø –†–Ü–í–ù–Ø–ù–¨ ***
                        displayEquationsCatmullRom(points, alpha);

                    } else {
                        // (Cubic —Ç–∞ Quadratic)
                        let segments = [];
                        if (type === 'cubic') {
                            segments = calculateCubicSpline(points, boundaryCondSelect.value);
                        } else {
                            segments = calculateQuadraticSpline(points, boundaryCondSelect.value);
                        }
                        
                        if (segments.length > 0) {
                            drawSegmentedSpline(segments); 
                            displayEquations(segments); 
                        }
                    }

                } catch (error) {
                    equationsList.innerHTML = `<p style="color: red;">–ü–æ–º–∏–ª–∫–∞ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è: ${error.message}</p>`;
                    return;
                }
            }

            // === –§—É–Ω–∫—Ü—ñ—ó —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥—É ===

            function drawPoints() {
                const type = splineTypeSelect.value;
                
                // *** –û–ù–û–í–õ–ï–ù–û: –ö–æ–ª—ñ—Ä —Ç–æ—á–æ–∫ ***
                if (type === 'b_spline') {
                    ctx.fillStyle = '#aaa'; // –°—ñ—Ä—ñ "–∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏"
                    ctx.strokeStyle = '#aaa';
                    ctx.lineWidth = 1;
                    
                    // –ú–∞–ª—é—î–º–æ "–∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∏–π –ø–æ–ª—ñ–≥–æ–Ω"
                    let first = true;
                    ctx.beginPath();
                    for (const point of points) {
                        const { x: pixelX, y: pixelY } = worldToPixel(point.x, point.y);
                        if (first) {
                            ctx.moveTo(pixelX, pixelY);
                            first = false;
                        } else {
                            ctx.lineTo(pixelX, pixelY);
                        }
                    }
                    ctx.stroke();
                    
                } else {
                    ctx.fillStyle = '#000'; // –ß–æ—Ä–Ω—ñ "–≤—É–∑–ª–∏" (–¥–ª—è Cubic, Quadratic, Catmull-Rom)
                }
                
                for (const point of points) {
                    const { x: pixelX, y: pixelY } = worldToPixel(point.x, point.y);
                    
                    if (pixelX > -5 && pixelX < canvas.width + 5 && pixelY > -5 && pixelY < canvas.height + 5) {
                        ctx.beginPath();
                        ctx.arc(pixelX, pixelY, POINT_RADIUS, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }

            // *** (–ü–ï–†–ï–ô–ú–ï–ù–û–í–ê–ù–û) –ú–∞–ª—é—î y=f(x) —Å–ø–ª–∞–π–Ω–∏ ***
            function drawSegmentedSpline(segments) {
                ctx.lineWidth = 2;
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    const p1 = points[i];
                    const p2 = points[i+1];
                    const color = segmentColors[i % segmentColors.length];
                    ctx.strokeStyle = color;
                    
                    const { x: startPixelX, y: startPixelY } = worldToPixel(p1.x, p1.y);
                    ctx.beginPath();
                    ctx.moveTo(startPixelX, startPixelY);

                    const step = Math.max(1e-3, (p2.x - p1.x) / 100);
                    
                    for (let world_x = p1.x + step; world_x < p2.x; world_x += step) {
                        const world_y = segment.eval(world_x);
                        const { x: pixelX, y: pixelY } = worldToPixel(world_x, world_y);
                        ctx.lineTo(pixelX, pixelY);
                    }
                    
                    const { x: endPixelX, y: endPixelY } = worldToPixel(p2.x, p2.y);
                    ctx.lineTo(endPixelX, endPixelY);
                    ctx.stroke();
                }
            }
            
            // *** (–ü–ï–†–ï–ô–ú–ï–ù–û–í–ê–ù–û) –ú–∞–ª—é—î –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω—ñ (B-spline, Catmull-Rom) ***
            function drawParametricSpline(curvePoints, color) {
                ctx.lineWidth = 2;
                ctx.strokeStyle = color; 
                
                ctx.beginPath();
                let first = true;
                for(const point of curvePoints) {
                    const { x: pixelX, y: pixelY } = worldToPixel(point.x, point.y);
                    if (first) {
                        ctx.moveTo(pixelX, pixelY);
                        first = false;
                    } else {
                        ctx.lineTo(pixelX, pixelY);
                    }
                }
                ctx.stroke();
            }
            
            // --- –§—É–Ω–∫—Ü—ñ—ó –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Ä—ñ–≤–Ω—è–Ω—å ---
            
            function displayEquations(segments) {
                equationsList.innerHTML = '';
                segments.forEach((seg, i) => {
                    const color = segmentColors[i % segmentColors.length];
                    const p1 = points[i];
                    const p2 = points[i+1];

                    const eqDiv = document.createElement('div');
                    eqDiv.style.borderLeft = `4px solid ${color}`;
                    eqDiv.style.backgroundColor = `${color}1A`;
                    
                    const x_i_str = p1.x.toFixed(2);
                    let eqnStr = `<b>S<sub>${i}</sub>(x) = </b>`;

                    if (seg.type === 'cubic') {
                        const { a, b, c, d } = seg.coeffs;
                        const f = (val) => (val >= 0 ? ' + ' : ' - ') + Math.abs(val).toFixed(4);
                        
                        eqnStr += `${a.toFixed(4)}(x - ${x_i_str})¬≥`;
                        eqnStr += `${f(b)}(x - ${x_i_str})¬≤`;
                        eqnStr += `${f(c)}(x - ${x_i_str})`;
                        eqnStr += `${f(d)}`;
                    
                    } else if (seg.type === 'quadratic') {
                        const { a, b, c } = seg.coeffs;
                        const f = (val) => (val >= 0 ? ' + ' : ' - ') + Math.abs(val).toFixed(4);

                        eqnStr += `${a.toFixed(4)}(x - ${x_i_str})¬≤`;
                        eqnStr += `${f(b)}(x - ${x_i_str})`;
                        eqnStr += `${f(c)}`;
                    }
                    
                    eqDiv.innerHTML = `${eqnStr} &nbsp;&nbsp; <i>[–¥–ª—è x –≤—ñ–¥ ${x_i_str} –¥–æ ${p2.x.toFixed(2)}]</i>`;
                    equationsList.appendChild(eqDiv);
                });
            }
            
			// *** –§–£–ù–ö–¶–Ü–Ø: –û–ø–∏—Å –¥–ª—è B-Spline (–±–µ–∑ –∑–º—ñ–Ω) ***
            function displayEquationsBSpline(points) {
                equationsList.innerHTML = '';
                const n = points.length;
                
                const eqDiv = document.createElement('div');
                eqDiv.style.borderLeft = `4px solid #007bff`; // –°–∏–Ω—ñ–π
                eqDiv.style.backgroundColor = `#007bff1A`;
                eqDiv.style.fontFamily = 'Arial, sans-serif';

                eqDiv.innerHTML = `<b>B-–°–ø–ª–∞–π–Ω (–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è)</b>
                   <p class="mathjax-explanation">
                   –¶–µ <b>–∞–ø—Ä–æ–∫—Å–∏–º—É—é—á–∞</b> (–∑–≥–ª–∞–¥–∂—É—é—á–∞) –∫—Ä–∏–≤–∞. –í–æ–Ω–∞ –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏ (–æ–∫—Ä—ñ–º, –º–æ–∂–ª–∏–≤–æ, –∫—ñ–Ω—Ü–µ–≤–∏—Ö), –∞ –ª–∏—à–µ "–ø—Ä–∏–±–ª–∏–∑–Ω–æ" —Å–ª—ñ–¥—É—î –∑–∞ –Ω–∏–º–∏, —Ñ–æ—Ä–º—É—é—á–∏ –≥–ª–∞–¥–∫–∏–π —à–ª—è—Ö.
                   </p>
                   <p class="mathjax-explanation">
                   –ö–æ–∂–µ–Ω –∫—É–±—ñ—á–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç $\\mathbf{S}_i(t)$ (–¥–µ –ø–∞—Ä–∞–º–µ—Ç—Ä $t \\in [0, 1]$) –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ 4 –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏: $\\mathbf{P}_{i-1}, \\mathbf{P}_i, \\mathbf{P}_{i+1}, \\mathbf{P}_{i+2}$.
                   </p>
                   <p class="mathjax-explanation">
                   –¢—É—Ç $\\mathbf{P}_i = (x_i, y_i)$ ‚Äî —Ü–µ –≤–∞—à—ñ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏ (–≤–µ–∫—Ç–æ—Ä–∏). –†—ñ–≤–Ω—è–Ω–Ω—è —Å–µ–≥–º–µ–Ω—Ç–∞:
                   </p>
                   $$ \\mathbf{S}_i(t) = N_0(t)\\mathbf{P}_{i-1} + N_1(t)\\mathbf{P}_i + N_2(t)\\mathbf{P}_{i+1} + N_3(t)\\mathbf{P}_{i+2} $$
                   <p class="mathjax-explanation">
                   $N_0...N_3$ ‚Äî —Ü–µ "–±–∞–∑–∏—Å–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó" (–∞–±–æ "—Ñ—É–Ω–∫—Ü—ñ—ó –∑–º—ñ—à—É–≤–∞–Ω–Ω—è"). –î–ª—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ <i>–∫—É–±—ñ—á–Ω–æ–≥–æ —Ä—ñ–≤–Ω–æ–º—ñ—Ä–Ω–æ–≥–æ B-—Å–ø–ª–∞–π–Ω–∞</i> –≤–æ–Ω–∏ –≤–∏–≥–ª—è–¥–∞—é—Ç—å —Ç–∞–∫:
                   </p>
                   $$ N_0(t) = \\frac{1}{6}(1-t)^3 = \\frac{1}{6}(-t^3 + 3t^2 - 3t + 1) $$
                   $$ N_1(t) = \\frac{1}{6}(3t^3 - 6t^2 + 4) $$
                   $$ N_2(t) = \\frac{1}{6}(-3t^3 + 3t^2 + 3t + 1) $$
                   $$ N_3(t) = \\frac{1}{6}(t^3) $$
                   <p class="mathjax-explanation">
                   –Ø–∫—â–æ –∑–≥—Ä—É–ø—É–≤–∞—Ç–∏ –∑–∞ —Å—Ç–µ–ø–µ–Ω—è–º–∏ $t$, –º–∏ –æ—Ç—Ä–∏–º–∞—î–º–æ —Ç—É –∂ –ø–æ–ª—ñ–Ω–æ–º—ñ–∞–ª—å–Ω—É —Ñ–æ—Ä–º—É $\\mathbf{S}_i(t) = \\mathbf{c}_0 + \\mathbf{c}_1 t + \\mathbf{c}_2 t^2 + \\mathbf{c}_3 t^3$:
                   </p>
                   $$ \\mathbf{c}_0 = \\frac{1}{6} (\\mathbf{P}_{i-1} + 4\\mathbf{P}_i + \\mathbf{P}_{i+1}) $$
                   $$ \\mathbf{c}_1 = \\frac{1}{6} (-3\\mathbf{P}_{i-1} + 3\\mathbf{P}_{i+1}) $$
                   $$ \\mathbf{c}_2 = \\frac{1}{6} (3\\mathbf{P}_{i-1} - 6\\mathbf{P}_i + 3\\mathbf{P}_{i+1}) $$
                   $$ \\mathbf{c}_3 = \\frac{1}{6} (-\\mathbf{P}_{i-1} + 3\\mathbf{P}_i - 3\\mathbf{P}_{i+1} + \\mathbf{P}_{i+2}) $$`;
                   
                equationsList.appendChild(eqDiv);

                if (window.MathJax) { MathJax.typesetPromise([eqDiv]); }
            }
            
       // *** –û–ù–û–í–õ–ï–ù–ê –§–£–ù–ö–¶–Ü–Ø: –û–ø–∏—Å –¥–ª—è Catmull-Rom (–∑ Alpha) ***
            function displayEquationsCatmullRom(points, alpha) {
                 equationsList.innerHTML = '';
                 const n = points.length;
                 const alphaStr = alpha.toFixed(2);
                 
                 const eqDiv = document.createElement('div');
                 eqDiv.style.borderLeft = `4px solid #28a745`; // –ó–µ–ª–µ–Ω–∏–π
                 eqDiv.style.backgroundColor = `#28a7451A`;
                 eqDiv.style.fontFamily = 'Arial, sans-serif';
                 
                 eqDiv.innerHTML = `<b>–°–ø–ª–∞–π–Ω –ö–∞—Ç–º—É–ª–ª–∞-–†–æ–º–∞ (–Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è)</b>
                    <p class="mathjax-explanation">
                    –¶–µ <b>—ñ–Ω—Ç–µ—Ä–ø–æ–ª—é—é—á–∞</b> –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω–∞ –∫—Ä–∏–≤–∞. –í–æ–Ω–∞ —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è –∑ –∫—É–±—ñ—á–Ω–∏—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ $S_i(t)$, —â–æ "–∑—à–∏—Ç—ñ" –∑ $C^1$ –≥–ª–∞–¥–∫—ñ—Å—Ç—é (–Ω–∞—Ö–∏–ª–∏ –∑–±—ñ–≥–∞—é—Ç—å—Å—è —É –≤—É–∑–ª–∞—Ö).
                    </p>
                    <p class="mathjax-explanation">
                    –ö–æ–∂–µ–Ω —Å–µ–≥–º–µ–Ω—Ç $S_i(t)$ (—â–æ –π–¥–µ –≤—ñ–¥ $\\mathbf{P}_i$ –¥–æ $\\mathbf{P}_{i+1}$) –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ 4 —Ç–æ—á–∫–∏: $\\mathbf{P}_{i-1}, \\mathbf{P}_i, \\mathbf{P}_{i+1}, \\mathbf{P}_{i+2}$.
                    </p>
                    <p class="mathjax-explanation">
                    –¢—É—Ç $\\mathbf{P}_i = (x_i, y_i)$ ‚Äî —Ü–µ –≤–∞—à—ñ —Ç–æ—á–∫–∏ (–≤–µ–∫—Ç–æ—Ä–∏). –†—ñ–≤–Ω—è–Ω–Ω—è —Å–µ–≥–º–µ–Ω—Ç–∞, –¥–µ $t \\in [0, 1]$:
                    </p>
                    $$ \\mathbf{S}_i(t) = \\mathbf{c}_0 + \\mathbf{c}_1 t + \\mathbf{c}_2 t^2 + \\mathbf{c}_3 t^3 $$
                    <p class="mathjax-explanation">
                    –î–µ $\\alpha = ${alphaStr}$ (–≤–∞—à–∞ "–Ω–∞–ø—Ä—É–∂–µ–Ω—ñ—Å—Ç—å"). –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ (–≤–µ–∫—Ç–æ—Ä–∏ $\\mathbf{c}$) –∑–∞–ª–µ–∂–∞—Ç—å –≤—ñ–¥ 4-—Ö —Ç–æ—á–æ–∫:
                    </p>
                    $$ \\mathbf{c}_0 = \\mathbf{P}_i $$
                    $$ \\mathbf{c}_1 = \\alpha (\\mathbf{P}_{i+1} - \\mathbf{P}_{i-1}) $$
                    $$ \\mathbf{c}_2 = (2\\alpha)\\mathbf{P}_{i-1} + (-3 + \\alpha)\\mathbf{P}_i + (3 - 2\\alpha)\\mathbf{P}_{i+1} - \\alpha\\mathbf{P}_{i+2} $$
                    $$ \\mathbf{c}_3 = (-\\alpha)\\mathbf{P}_{i-1} + (2 - \\alpha)\\mathbf{P}_i + (-2 + \\alpha)\\mathbf{P}_{i+1} + \\alpha\\mathbf{P}_{i+2} $$
                    <p class="mathjax-explanation" style="font-size: 0.9em; color: #555;">
                    <i>(–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π Catmull-Rom $\\alpha=0.5$. $\\alpha=0$ - –æ—Å–ª–∞–±–ª–µ–Ω–∞ (Tension=0). $\\alpha=1$ - "–ø–µ—Ä–µ—Ç—è–≥–Ω—É—Ç–∞" (Tension=1).)</i>
                    </p>`;
                 equationsList.appendChild(eqDiv);
                 
                 if (window.MathJax) { MathJax.typesetPromise([eqDiv]); }
            }


            // === –ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞ —Å–ø–ª–∞–π–Ω—ñ–≤ ===
            
            // (solveTridiagonal, calculateCubicSpline, calculateQuadraticSpline –∑–∞–ª–∏—à–∞—é—Ç—å—Å—è –±–µ–∑ –∑–º—ñ–Ω)

            function solveTridiagonal(A, B, C, D) {
                const n = B.length;
                const C_prime = new Array(n).fill(0);
                const D_prime = new Array(n).fill(0);
                const X = new Array(n).fill(0);

                C_prime[0] = C[0] / B[0];
                D_prime[0] = D[0] / B[0];

                for (let i = 1; i < n; i++) {
                    const m = B[i] - A[i] * C_prime[i - 1];
                    C_prime[i] = C[i] / m;
                    D_prime[i] = (D[i] - A[i] * D_prime[i - 1]) / m;
                }

                X[n - 1] = D_prime[n - 1];
                for (let i = n - 2; i >= 0; i--) {
                    X[i] = D_prime[i] - C_prime[i] * X[i + 1];
                }
                return X;
            }

            function calculateCubicSpline(pts, boundaryCond) {
                const n = pts.length;
                if (n < 2) return [];

                const h = new Array(n - 1);
                const delta = new Array(n - 1);
                for (let i = 0; i < n - 1; i++) {
                    h[i] = pts[i + 1].x - pts[i].x;
                    if (h[i] <= 0) {
                        throw new Error("–¢–æ—á–∫–∏ –º–∞—é—Ç—å –±—É—Ç–∏ —É–Ω—ñ–∫–∞–ª—å–Ω–∏–º–∏ —Ç–∞ –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–∏–º–∏ –ø–æ X.");
                    }
                    delta[i] = (pts[i + 1].y - pts[i].y) / h[i];
                }

                const A = new Array(n).fill(0);
                const B = new Array(n).fill(0);
                const C = new Array(n).fill(0);
                const D = new Array(n).fill(0);

                for (let i = 1; i < n - 1; i++) {
                    A[i] = h[i - 1];
                    B[i] = 2 * (h[i - 1] + h[i]);
                    C[i] = h[i];
                    D[i] = 6 * (delta[i] - delta[i - 1]);
                }

                if (boundaryCond === 'natural') {
                    B[0] = 1; C[0] = 0; D[0] = 0;
                    A[n - 1] = 0; B[n - 1] = 1; D[n - 1] = 0;
                
                } else if (boundaryCond === 'clamped') {
                    const f_prime_0 = parseFloat(startSlope.value);
                    const f_prime_n_1 = parseFloat(endSlope.value);
                    
                    B[0] = 2 * h[0];
                    C[0] = h[0];
                    D[0] = 6 * (delta[0] - f_prime_0);
                    
                    A[n - 1] = h[n - 2];
                    B[n - 1] = 2 * h[n - 2];
                    D[n - 1] = 6 * (f_prime_n_1 - delta[n - 2]);
                }

                const M = solveTridiagonal(A, B, C, D);
                
                const segments = [];
                for (let i = 0; i < n - 1; i++) {
                    const d = pts[i].y;
                    const c = delta[i] - h[i] * (2 * M[i] + M[i + 1]) / 6;
                    const b = M[i] / 2;
                    const a = (M[i + 1] - M[i]) / (6 * h[i]);
                    
                    segments.push({
                        type: 'cubic',
                        coeffs: { a, b, c, d },
                        xi: pts[i].x,
                        eval: function(x) {
                            const t = x - this.xi;
                            return this.coeffs.a * t**3 + this.coeffs.b * t**2 + this.coeffs.c * t + this.coeffs.d;
                        }
                    });
                }
                return segments;
            }
            
            function calculateQuadraticSpline(pts, boundaryCond) {
                const n = pts.length;
                if (n < 2) return [];

                const h = new Array(n - 1);
                const delta = new Array(n - 1);
                for (let i = 0; i < n - 1; i++) {
                    h[i] = pts[i + 1].x - pts[i].x;
                    if (h[i] <= 0) {
                        throw new Error("–¢–æ—á–∫–∏ –º–∞—é—Ç—å –±—É—Ç–∏ —É–Ω—ñ–∫–∞–ª—å–Ω–∏–º–∏ —Ç–∞ –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–∏–º–∏ –ø–æ X.");
                    }
                    delta[i] = (pts[i + 1].y - pts[i].y) / h[i];
                }
                
                const z = new Array(n); // z[i] = S'(x_i)

                if (boundaryCond === 'start_zero') {
                    z[0] = 0;
                    for (let i = 0; i < n - 1; i++) {
                        z[i+1] = 2 * delta[i] - z[i];
                    }
                } else { // 'end_zero'
                    z[n - 1] = 0;
                    for (let i = n - 2; i >= 0; i--) {
                        z[i] = 2 * delta[i] - z[i + 1];
                    }
                }

                const segments = [];
                for (let i = 0; i < n - 1; i++) {
                    const c = pts[i].y;
                    const b = z[i];
                    const a = (z[i+1] - z[i]) / (2 * h[i]); 
                    
                    segments.push({
                        type: 'quadratic',
                        coeffs: { a, b, c },
                        xi: pts[i].x,
                        eval: function(x) {
                            const t = x - this.xi;
                            return this.coeffs.a * t**2 + this.coeffs.b * t + this.coeffs.c;
                        }
                    });
                }
                return segments;
            }

            // --- B-Spline M–∞—Ç–µ–º–∞—Ç–∏–∫–∞ (–±–µ–∑ –∑–º—ñ–Ω) ---
            
            function coxDeBoor(i, p, t, U, n, maxT) {
                if (p === 0) {
                    if (t === maxT && i === n - 1) {
                        return (U[i] <= t && t <= U[i + 1]) ? 1 : 0;
                    }
                    return (U[i] <= t && t < U[i + 1]) ? 1 : 0;
                }
                
                let term1 = 0;
                if (U[i + p] - U[i] > 1e-9) { 
                    term1 = ((t - U[i]) / (U[i + p] - U[i])) * coxDeBoor(i, p - 1, t, U, n, maxT);
                }
                
                let term2 = 0;
                if (U[i + p + 1] - U[i + 1] > 1e-9) { 
                    term2 = ((U[i + p + 1] - t) / (U[i + p + 1] - U[i + 1])) * coxDeBoor(i + 1, p - 1, t, U, n, maxT);
                }
                
                return term1 + term2;
            }

            function calculateBSplinePoints(P, p, numSteps) {
                const n = P.length; 
                if (n <= p) {
                    throw new Error("–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ—á–æ–∫ –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–æ—é –∑–∞ —Å—Ç–µ–ø—ñ–Ω—å —Å–ø–ª–∞–π–Ω–∞.");
                }
                
                const m = n + p + 1;
                const U = new Array(m);
                
                for (let i = 0; i <= p; i++) { U[i] = 0; }
                for (let i = 1; i < n - p; i++) { U[p + i] = i; }
                for (let i = 0; i <= p; i++) { U[n + i] = n - p; }
                
                const maxT = n - p; 
                const curvePoints = [];
                
                for (let step = 0; step <= numSteps; step++) {
                    let t = (step / numSteps) * maxT;
                    
                    if (t > maxT) t = maxT; 
                    if (step === numSteps) t = maxT; 
                    
                    let x = 0;
                    let y = 0;
                    
                    for (let i = 0; i < n; i++) {
                        const basis = coxDeBoor(i, p, t, U, n, maxT);
                        x += P[i].x * basis;
                        y += P[i].y * basis;
                    }
                    curvePoints.push({ x: x, y: y });
                }
                
                return curvePoints;
            }
            
            // --- *** –û–ù–û–í–õ–ï–ù–ê –ú–ê–¢–ï–ú–ê–¢–ò–ö–ê: Catmull-Rom –∑ Alpha *** ---
            
            // *** –§—É–Ω–∫—Ü—ñ—è —Ç–µ–ø–µ—Ä –ø—Ä–∏–π–º–∞—î 'alpha' ***
            function calculateCatmullRomSpline(pts, stepsPerSegment, alpha) {
                const n = pts.length;
                if (n < 2) return [];

                const curvePoints = [];
                // –î–æ–¥–∞—î–º–æ –ø–µ—Ä—à—É —Ç–æ—á–∫—É, –æ—Å–∫—ñ–ª—å–∫–∏ —Ü–∏–∫–ª –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ t=0
                curvePoints.push(pts[0]); 

                for (let i = 0; i < n - 1; i++) {
                    // –í–∏–∑–Ω–∞—á–∞—î–º–æ 4 –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ —Ç–æ—á–∫–∏ P_{i-1}, P_i, P_{i+1}, P_{i+2}
                    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ "phantom points" (–ø—Ä–æ—Å—Ç–æ –¥—É–±–ª—é—î–º–æ –∫—ñ–Ω—Ü–µ–≤—ñ) –¥–ª—è –∫—Ä–∞—ó–≤
                    const p0 = (i === 0) ? pts[0] : pts[i - 1];
                    const p1 = pts[i];
                    const p2 = pts[i + 1];
                    const p3 = (i === n - 2) ? pts[n - 1] : pts[i + 2];
                    
                    // –¶–∏–∫–ª –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ t –≤—ñ–¥ 0 –¥–æ 1 (–º–∏ –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ t=0, –±–æ –≤–∂–µ –¥–æ–¥–∞–ª–∏ P_i)
                    for (let j = 1; j <= stepsPerSegment; j++) {
                        const t = j / stepsPerSegment;
                        const t2 = t * t;
                        const t3 = t2 * t;

                        // *** –ó–∞–≥–∞–ª—å–Ω–∞ —Ñ–æ—Ä–º—É–ª–∞ Catmull-Rom –∑ 'alpha' ***
                        const c0x = p1.x;
                        const c1x = alpha * (-p0.x + p2.x);
                        const c2x = (2 * alpha) * p0.x + (-3 + alpha) * p1.x + (3 - 2 * alpha) * p2.x + (-alpha) * p3.x;
                        const c3x = (-alpha) * p0.x + (2 - alpha) * p1.x + (-2 + alpha) * p2.x + (alpha) * p3.x;
                        const x = c0x + c1x * t + c2x * t2 + c3x * t3;

                        const c0y = p1.y;
                        const c1y = alpha * (-p0.y + p2.y);
                        const c2y = (2 * alpha) * p0.y + (-3 + alpha) * p1.y + (3 - 2 * alpha) * p2.y + (-alpha) * p3.y;
                        const c3y = (-alpha) * p0.y + (2 - alpha) * p1.y + (-2 + alpha) * p2.y + (alpha) * p3.y;
                        const y = c0y + c1y * t + c2y * t2 + c3y * t3;
                        
                        curvePoints.push({ x, y });
                    }
                }
                return curvePoints;
            }


            // === –ü–µ—Ä—à–∏–π –∑–∞–ø—É—Å–∫ ===
            updateInputsFromView(); 
            updateBoundaryOptions(); 
        });
    </script>

</body>
</html>
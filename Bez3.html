<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Інтерактивні Криві Безьє</title>
    
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        :root {
            --primary: #8e44ad;
            --handle: #e74c3c;
            --anchor: #2c3e50;
            --line: #34495e;
            --aux: #2ecc71;
            --bg: #f8f9fa;
            --panel: #ffffff;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .main-wrapper {
            max-width: 1200px;
            width: 100%;
        }
        
        /* TABS */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }
        .tab-btn {
            padding: 12px 25px;
            border: none;
            background: none;
            font-size: 16px;
            cursor: pointer;
            color: #7f8c8d;
            font-weight: 600;
            transition: 0.2s;
        }
        .tab-btn:hover { color: var(--primary); }
        .tab-btn.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }
        
        /* CONTENT AREAS */
        .tab-content { display: none; gap: 20px; flex-wrap: wrap; }
        .tab-content.active { display: flex; }

        .canvas-container {
            flex: 2;
            min-width: 600px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            padding: 10px;
            position: relative;
        }
        canvas {
            border: 1px solid #eee;
            width: 100%;
            height: 500px;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: crosshair;
        }

        .controls-panel {
            flex: 1;
            min-width: 300px;
            background: var(--panel);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        /* UI ELEMENTS */
        h2, h3 { color: var(--anchor); margin-top: 0; }
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 14px;
        }
        button:hover { opacity: 0.9; }
        button.secondary { background: #95a5a6; }
        
        .coord-display {
            font-family: monospace;
            background: #f1f2f6;
            padding: 10px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.9em;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .formula-box {
            margin-top: 15px;
            padding: 10px;
            background: #eef7fb;
            border-left: 4px solid #3498db;
            font-family: 'Times New Roman', Times, serif;
            font-size: 1.1em;
            color: #2c3e50;
        }

        /* THEORY SPOILER */
        details {
            margin-top: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            width: 100%;
        }
        summary {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            background: #ecf0f1;
            border-radius: 8px;
            list-style: none; /* Hide default triangle */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        summary::after { content: "▼"; font-size: 0.8em; transition: 0.2s; }
        details[open] summary::after { transform: rotate(180deg); }
        .theory-content { padding: 20px; border-top: 1px solid #ddd; }

        .legend {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.85em;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
    </style>
</head>
<body>

<div class="main-wrapper">
    <h1>Криві Безьє</h1>

    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('single')">1. Принцип побудови</button>
        <button class="tab-btn" onclick="switchTab('spline')">2. Міні-редактор</button>
    </div>

    <div id="tab-single" class="tab-content active">
        <div class="canvas-container">
            <div class="legend">
                <span><span class="dot" style="background:var(--anchor)"></span>Вузол ($P_0, P_3$)</span>
                <span><span class="dot" style="background:var(--handle)"></span>Вус ($P_1, P_2$)</span>
                <span><span class="dot" style="background:var(--aux)"></span>Алгоритм (t)</span>
            </div>
            <canvas id="canvas1"></canvas>
            
            <div class="formula-box">
                <strong>Поточний поліном (B(t)):</strong><br>
                <span id="poly-equation" style="font-size:0.9em">...</span>
            </div>
        </div>

        <div class="controls-panel">
            <h3>Управління</h3>
            <label>Параметр t: <span id="t-val-display">0.50</span></label>
            <input type="range" id="t-slider" min="0" max="1" step="0.01" value="0.5" style="width:100%">
            
            <div style="margin-top:15px;">
                <label><input type="checkbox" id="check-construction" checked> Алгоритм де Кастельжо</label>
            </div>
            
            <h4>Координати точок:</h4>
            <div id="coords-panel" class="coord-display">
                P0: (0, 0)<br>P1: (0, 0)<br>P2: (0, 0)<br>P3: (0, 0)
            </div>

            <div style="margin-top:20px;">
                <button onclick="SingleCurve.reset()">Скинути</button>
            </div>
        </div>
    </div>

    <div id="tab-spline" class="tab-content">
        <div class="canvas-container">
             <div class="legend">
                <span><span class="dot" style="background:var(--anchor)"></span>Вузол (тягне вуса)</span>
                <span><span class="dot" style="background:var(--handle)"></span>Вус (незалежний)</span>
            </div>
            <canvas id="canvas2"></canvas>
        </div>
        <div class="controls-panel">
            <h3>Векторний Редактор</h3>
            <p style="font-size:0.9em; color:#666;">
                Криві Безьє були запроваджені в 1962 році П'єром Безьє з автомобілебудівної компанії «Рено». Спробуйте перетворити CyberTruck у Феррарі
            </p>
            <button onclick="SplineEditor.loadPreset('wave')">Хвиля</button>
            <button onclick="SplineEditor.loadPreset('heart')">Серце</button>
          <button onclick="SplineEditor.loadPreset('car')">Автомобіль </button>  <hr>
            <button class="secondary" onclick="SplineEditor.clear()">Очистити полотно</button>
            
            <div class="coord-display" id="spline-debug">
                Кількість сегментів: 2
            </div>
        </div>
    </div>

    <details>
        <summary>Як це працює? (Теорія та Математика)</summary>
        <div class="theory-content">
            <h3>Кубічна крива Без'є</h3>
            <p>Крива будується за допомогою чотирьох точок: початку $P_0$, кінця $P_3$ та двох контрольних точок $P_1$ і $P_2$, які визначають форму (вигин).</p>
            
            <h4>1. Аналітична формула (Поліноми Бернштейна)</h4>
            <p>Координата будь-якої точки на кривій для параметру $t \in [0, 1]$ обчислюється як зважена сума координат контрольних точок:</p>
            $$ B(t) = (1-t)^3 P_0 + 3(1-t)^2 t P_1 + 3(1-t) t^2 P_2 + t^3 P_3 $$
            <p>Коефіцієнти перед точками (наприклад, $(1-t)^3$) визначають "вагу" або вплив кожної точки при певному значенні $t$.</p>

            <h4>2. Геометричний зміст "Вуса"</h4>
            <p>Вектор $\vec{P_0 P_1}$ (перший вус) є дотичним до кривої на початку. Його довжина визначає "силу", з якою крива вилітає з точки старту. Похідна (швидкість):</p>
            $$ B'(0) = 3(P_1 - P_0) $$
            
            <h4>3. Алгоритм де Кастельжо (Лінійна інтерполяція)</h4>
            <p>Це спосіб побудувати точку геометрично, без складних формул, використовуючи лише пропорції:</p>
            <ol>
                <li>Знайди точку на відрізку $P_0 P_1$, що ділить його у відношенні $t : (1-t)$.</li>
                <li>Повтори це для $P_1 P_2$ та $P_2 P_3$. Отримаєш 3 нові точки.</li>
                <li>З'єднай їх відрізками і знову знайди точки пропорції $t$. Отримаєш 2 точки.</li>
                <li>З'єднай їх. Знайди фінальну точку. Це і є $B(t)$.</li>
            </ol>
        </div>
    </details>
</div>

<script>
// === COMMON UTILS ===
const Utils = {
    getMousePos: (canvas, evt) => {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    },
    dist: (p1, p2) => Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2),
    lerp: (p1, p2, t) => ({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t }),
    
    // Draw a standardized anchor/handle point
    drawPoint: (ctx, p, color, type = 'circle', label = '') => {
        ctx.beginPath();
        if (type === 'rect') {
            ctx.rect(p.x - 4, p.y - 4, 8, 8);
        } else {
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        }
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        ctx.stroke();

        if (label) {
            ctx.fillStyle = color;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(label, p.x + 8, p.y - 8);
        }
    }
};

// === TAB 1: SINGLE CURVE SIMULATOR ===
const SingleCurve = {
    canvas: document.getElementById('canvas1'),
    ctx: document.getElementById('canvas1').getContext('2d'),
    points: [], // P0, P1, P2, P3
    dragIdx: null,
    t: 0.5,

    init: function() {
        this.resize();
        this.reset();
        
        // Events
        this.canvas.addEventListener('mousedown', this.onDown.bind(this));
        window.addEventListener('mousemove', this.onMove.bind(this)); // Window for smoother drag out of bounds
        window.addEventListener('mouseup', this.onUp.bind(this));
        
        document.getElementById('t-slider').addEventListener('input', (e) => {
            this.t = parseFloat(e.target.value);
            document.getElementById('t-val-display').innerText = this.t.toFixed(2);
            this.draw();
        });
        document.getElementById('check-construction').addEventListener('change', () => this.draw());
    },

    resize: function() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = 500;
        if(this.points.length > 0) this.draw();
    },

    reset: function() {
        const w = this.canvas.width;
        const h = this.canvas.height;
        this.points = [
            { x: w * 0.1, y: h * 0.8, label: 'P0' }, // Anchor
            { x: w * 0.1, y: h * 0.2, label: 'P1' }, // Handle
            { x: w * 0.9, y: h * 0.2, label: 'P2' }, // Handle
            { x: w * 0.9, y: h * 0.8, label: 'P3' }  // Anchor
        ];
        this.draw();
    },

    onDown: function(e) {
        const pos = Utils.getMousePos(this.canvas, e);
        for(let i=0; i<this.points.length; i++) {
            if(Utils.dist(pos, this.points[i]) < 25) {//15
                this.dragIdx = i;
                return;
            }
        }
    },

    onMove: function(e) {
        if(this.dragIdx === null) return;
        const pos = Utils.getMousePos(this.canvas, e);
        
        // Update point
        this.points[this.dragIdx].x = pos.x;
        this.points[this.dragIdx].y = pos.y;
        this.draw();
    },

    onUp: function() {
        this.dragIdx = null;
    },

    updateUI: function() {
        // Update Coords Panel
        const p = this.points;
        const coordsText = p.map((pt, i) => `P${i}: (${Math.round(pt.x)}, ${Math.round(pt.y)})`).join('\n');
        document.getElementById('coords-panel').innerText = coordsText;

        // Update Equation
        const eqEl = document.getElementById('poly-equation');
        const t = "t"; 
        // Generates string like: (1-t)^3 * [10, 20] + ...
        eqEl.innerHTML = `
            <span style="color:gray">[x,y] = (1-t)³</span> · [${Math.round(p[0].x)}, ${Math.round(p[0].y)}] + 
            <span style="color:gray">3(1-t)²t</span> · [${Math.round(p[1].x)}, ${Math.round(p[1].y)}] + 
            <span style="color:gray">3(1-t)t²</span> · [${Math.round(p[2].x)}, ${Math.round(p[2].y)}] + 
            <span style="color:gray">t³</span> · [${Math.round(p[3].x)}, ${Math.round(p[3].y)}]
        `;
    },

    draw: function() {
        const ctx = this.ctx;
        const p = this.points;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. Draw Handles Lines
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p[0].x, p[0].y); ctx.lineTo(p[1].x, p[1].y);
        ctx.moveTo(p[3].x, p[3].y); ctx.lineTo(p[2].x, p[2].y);
        ctx.stroke();
        ctx.setLineDash([]);

        // 2. Draw Curve
        ctx.beginPath();
        ctx.moveTo(p[0].x, p[0].y);
        ctx.bezierCurveTo(p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y);
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 4;
        ctx.stroke();

        // 3. De Casteljau Visualization
        if(document.getElementById('check-construction').checked) {
            this.drawConstruction(this.t);
        }

        // 4. Draw Points
        Utils.drawPoint(ctx, p[0], '#2c3e50', 'rect', 'P0');
        Utils.drawPoint(ctx, p[3], '#2c3e50', 'rect', 'P3');
        Utils.drawPoint(ctx, p[1], '#e74c3c', 'circle', 'P1');
        Utils.drawPoint(ctx, p[2], '#e74c3c', 'circle', 'P2');

        this.updateUI();
    },

    drawConstruction: function(t) {
        const p = this.points;
        const ctx = this.ctx;

        const q0 = Utils.lerp(p[0], p[1], t);
        const q1 = Utils.lerp(p[1], p[2], t);
        const q2 = Utils.lerp(p[2], p[3], t);

        const r0 = Utils.lerp(q0, q1, t);
        const r1 = Utils.lerp(q1, q2, t);

        const b = Utils.lerp(r0, r1, t);

        // Lines
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#2ecc71';
        ctx.beginPath();
        ctx.moveTo(q0.x, q0.y); ctx.lineTo(q1.x, q1.y); ctx.lineTo(q2.x, q2.y);
        ctx.stroke();

        ctx.strokeStyle = '#3498db';
        ctx.beginPath();
        ctx.moveTo(r0.x, r0.y); ctx.lineTo(r1.x, r1.y);
        ctx.stroke();

        // Points
        [q0, q1, q2].forEach(pt => Utils.drawPoint(ctx, pt, '#2ecc71', 'circle', ''));
        [r0, r1].forEach(pt => Utils.drawPoint(ctx, pt, '#3498db', 'circle', ''));
        Utils.drawPoint(ctx, b, '#f1c40f', 'circle', 'B(t)');
    }
};

// === TAB 2: SPLINE EDITOR ===
const SplineEditor = {
    canvas: document.getElementById('canvas2'),
    ctx: document.getElementById('canvas2').getContext('2d'),
    nodes: [],
    dragIdx: null,
    showCarWheels: false, // Новий прапорець для коліс

    init: function() {
        this.resize();
        this.loadPreset('car'); // Завантажимо машину за замовчуванням
        
        this.canvas.addEventListener('mousedown', this.onDown.bind(this));
        window.addEventListener('mousemove', this.onMove.bind(this));
        window.addEventListener('mouseup', this.onUp.bind(this));
    },

    resize: function() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = 500;
        this.draw();
    },

    loadPreset: function(type) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        this.showCarWheels = false; // Скидаємо прапорець
        
        if (type === 'wave') {
            this.nodes = [
                {x: cx-200, y: cy}, {x: cx-100, y: cy-150}, {x: cx, y: cy+150}, 
                {x: cx+100, y: cy}, {x: cx+200, y: cy-150}, {x: cx+250, y: cy+100}, {x: cx+300, y: cy}
            ];
        } else if (type === 'heart') {
             this.nodes = [
                {x: cx, y: cy-50}, {x: cx-50, y: cy-150}, {x: cx-200, y: cy-50}, 
                {x: cx, y: cy+150}, {x: cx+200, y: cy-50}, {x: cx+50, y: cy-150}, {x: cx, y: cy-50}
            ];
        } else if (type === 'car') {
            // === ПЕРЕТВОРЕННЯ ВАШОГО SVG У ТОЧКИ РЕДАКТОРА ===
            this.showCarWheels = true;
            
            // Координати адаптовані з SVG (path d="m 310,73...")
            // Ми замінюємо прямі лінії (l) на сплайни, де важелі співпадають з вузлами
            this.nodes = [
                // 1. Дах (Початок) -> Капот
                {x: 310, y: 73},   // P0 Anchor (Дах)
                {x: 527, y: 113},  // Handle Out (bezier)
                {x: 597, y: 124},  // Handle In
                {x: 743, y: 152},  // P3 Anchor (Ніс)

                // 2. Капот -> Бампер
                {x: 752, y: 270},  // Handle Out (approx)
                {x: 752, y: 220},  // Handle In
                {x: 680, y: 267},  // Anchor (Перед колісною аркою)

                // 3. Арка переднього колеса (виріз)
                {x: 680, y: 200},  // Handle Out (вгору)
                {x: 535, y: 200},  // Handle In
                {x: 535, y: 267},  // Anchor (За аркою)

                // 4. Днище (Пряма лінія -> робимо важелі на тій же Y)
                {x: 535, y: 267},  // Handle Out (співпадає з точкою -> гострий кут/пряма)
                {x: 176, y: 267},  // Handle In
                {x: 176, y: 267},  // Anchor (Перед задньою аркою)

                // 5. Арка заднього колеса
                {x: 176, y: 200},  // Handle Out
                {x: 70, y: 200},   // Handle In
                {x: 40, y: 262},   // Anchor (Задній бампер низ)

                // 6. Багажник -> Дах (Замикаємо)
                {x: 40, y: 150},   // Handle Out
                {x: 30, y: 200},   // Handle In
                {x: 310, y: 73}    // Anchor (Повернення на дах)
            ];
            
            // Центруємо машину на екрані (SVG координати трохи зсунуті)
            const offsetX = (this.canvas.width - 800) / 2 - 10; 
            const offsetY = (this.canvas.height - 300) / 2;
            this.nodes.forEach(p => { p.x += offsetX; p.y += offsetY; });
        }
        
        this.draw();
    },

    // ... (onDown, onMove, onUp, clear залишаються без змін) ...
    clear: function() {
        this.nodes = [];
        this.showCarWheels = false;
        this.draw();
    },
    
    onDown: function(e) { /* ... ваш старий код ... */ 
        const pos = Utils.getMousePos(this.canvas, e);
        for(let i=0; i<this.nodes.length; i++) {
            if(Utils.dist(pos, this.nodes[i]) < 30) { 
                this.dragIdx = i;
                this.dragOffset = { x: this.nodes[i].x - pos.x, y: this.nodes[i].y - pos.y };
                return;
            }
        }
    },
    onMove: function(e) { /* ... ваш старий код ... */ 
         if(this.dragIdx === null) return;
        const pos = Utils.getMousePos(this.canvas, e);
        const dx = (pos.x + this.dragOffset.x) - this.nodes[this.dragIdx].x;
        const dy = (pos.y + this.dragOffset.y) - this.nodes[this.dragIdx].y;
        this.nodes[this.dragIdx].x += dx;
        this.nodes[this.dragIdx].y += dy;
        if (this.dragIdx % 3 === 0) {
            if (this.nodes[this.dragIdx - 1]) { this.nodes[this.dragIdx - 1].x += dx; this.nodes[this.dragIdx - 1].y += dy; }
            if (this.nodes[this.dragIdx + 1]) { this.nodes[this.dragIdx + 1].x += dx; this.nodes[this.dragIdx + 1].y += dy; }
        }
        this.draw();
    },
    onUp: function() { this.dragIdx = null; },

    draw: function() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. МАЛЮЄМО КОЛЕСА
        if (this.showCarWheels && this.nodes.length > 0) {
            
            // ТУТ ТЕЖ СТАВИМО -10, щоб зсув співпав з кузовом
            const offsetX = (this.canvas.width - 800) / 2 - 10; 
            const offsetY = (this.canvas.height - 300) / 2;

            ctx.fillStyle = '#ffffff'; 
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;

            // Колесо 1 (cx="110.8")
            ctx.beginPath();
            ctx.ellipse(110.8 + offsetX, 248.2 + offsetY, 36.5, 35.4, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Колесо 2 (cx="609.6")
            ctx.beginPath();
            ctx.ellipse(609.6 + offsetX, 248.5 + offsetY, 36.5, 35.4, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Диски (для краси)
            ctx.fillStyle = '#ccc';
            ctx.beginPath(); ctx.arc(110.8 + offsetX, 248.2 + offsetY, 15, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(609.6 + offsetX, 248.5 + offsetY, 15, 0, 2*Math.PI); ctx.fill();
        }

        // 2. МАЛЮЄМО СПЛАЙН (КУЗОВ)
        if (this.nodes.length < 4) return;

        ctx.strokeStyle = '#8e44ad';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let i = 0; i < this.nodes.length - 1; i += 3) {
            const p0 = this.nodes[i];
            const p1 = this.nodes[i+1];
            const p2 = this.nodes[i+2];
            const p3 = this.nodes[i+3];
            
            if(!p3) break; 
            if (i === 0) ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        }
        ctx.stroke();

        // 3. МАЛЮЄМО ВУЗЛИ ТА ВУСА
        ctx.lineWidth = 1;
        for (let i = 0; i < this.nodes.length; i++) {
            const pt = this.nodes[i];
            const isAnchor = (i % 3 === 0);
            
            if (!isAnchor) {
                ctx.strokeStyle = '#ccc';
                ctx.beginPath();
                const anchorIdx = (i % 3 === 1) ? i - 1 : i + 1;
                if(this.nodes[anchorIdx]) {
                    ctx.moveTo(pt.x, pt.y);
                    ctx.lineTo(this.nodes[anchorIdx].x, this.nodes[anchorIdx].y);
                    ctx.stroke();
                }
            }
            
            Utils.drawPoint(
                ctx, pt, 
                isAnchor ? '#2c3e50' : '#e74c3c', 
                isAnchor ? 'rect' : 'circle'
            );
        }

        document.getElementById('spline-debug').innerText = `Сегментів: ${Math.floor((this.nodes.length - 1) / 3)}`;
    }
};

// === TAB SWITCHING ===
function switchTab(id) {
    // 1. Перемикання класів (візуальна частина)
    document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
    
    document.getElementById('tab-' + id).classList.add('active');
    
    const btns = document.getElementsByClassName('tab-btn');
    if(id === 'single') btns[0].classList.add('active');
    else btns[1].classList.add('active');

    // 2. Виправлення глюку з розмірами
    if(id === 'single') {
        SingleCurve.resize();
    } else {
        SplineEditor.resize();
        
        SplineEditor.loadPreset('heart'); 
    }
}

// Initial Start
SingleCurve.init();
SplineEditor.init();
window.addEventListener('resize', () => {
    SingleCurve.resize();
    SplineEditor.resize();
});

</script>

</body>
</html>
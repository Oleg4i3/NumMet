<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Learning</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
   
<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



    <style>
        :root { --bg: #f8fafc; --panel: #ffffff; --text: #334155; --accent: #4f46e5; --border: #e2e8f0; --success: #22c55e; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 10px; display: flex; flex-direction: column; align-items: center; touch-action: none; }
        
        h1 { margin: 5px 0; font-size: 1.4em; text-align: center; }
        
        /* 3-Column Layout */
        .main-grid { display: grid; grid-template-columns: 300px 320px 1fr; gap: 15px; width: 100%; max-width: 1400px; align-items: start; }
        @media (max-width: 1100px) { .main-grid { grid-template-columns: 1fr 1fr; } }
        @media (max-width: 700px) { .main-grid { grid-template-columns: 1fr; } }

        .panel { background: var(--panel); padding: 15px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); border: 1px solid var(--border); }
        .panel h3 { margin-top: 0; font-size: 1.1em; border-bottom: 2px solid var(--border); padding-bottom: 8px; margin-bottom: 10px; }

        /* COLUMN 1: Input & Preprocessing */
        .canvas-wrap { position: relative; width: 224px; height: 224px; border: 2px solid #cbd5e1; background: white; margin: 0 auto 10px auto; border-radius: 8px; cursor: crosshair; }
        .small-view { display: flex; gap: 10px; justify-content: center; align-items: center; background: #f1f5f9; padding: 10px; border-radius: 8px; margin-bottom: 10px; }
        .pixel-view { width: 84px; height: 84px; image-rendering: pixelated; border: 1px solid #94a3b8; background: white; position: relative;}
        
        /* Buttons */
        .btn-group { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 5px; }
        button { flex: 1; padding: 8px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: 0.2s; background: #e2e8f0; color: var(--text); }
        button:hover { background: #cbd5e1; }
        button.primary { background: var(--accent); color: white; }
        button.success { background: var(--success); color: white; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* COLUMN 2: CNN Internals */
        .filters-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .filter-row { display: flex; align-items: center; gap: 5px; background: #f8fafc; padding: 4px; border-radius: 4px; border: 1px solid #e2e8f0; }
        .kernel-box { width: 30px; height: 30px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; border: 1px solid #ccc; }
        .k-cell { background: #ddd; }
        .arrow { font-size: 1.2em; color: #cbd5e1; }
        .fmap-canvas { width: 30px; height: 30px; image-rendering: pixelated; border: 1px solid #94a3b8; background: black; }
        
        /* Scanner Animation */
        .scan-box { position: absolute; width: 9px; height: 9px; border: 1px solid red; pointer-events: none; display: none; box-shadow: 0 0 5px red; transition: all 0.05s; }
        .scan-active { border-color: #22c55e; box-shadow: 0 0 8px #22c55e; background: rgba(0, 255, 0, 0.9); }

        /* COLUMN 3: Deep Learning & Latent */
        .dl-structure { display: flex; flex-direction: column; gap: 5px; font-size: 0.8em; margin-bottom: 10px; }
        .layer-block { background: #e0e7ff; padding: 6px; border-radius: 4px; text-align: center; border: 1px solid #c7d2fe; }
        .latent-plot { width: 100%; height: 250px; background: white; border: 1px solid #e2e8f0; }
        
        select { width: 100%; padding: 6px; margin-bottom: 10px; border-radius: 6px; border: 1px solid #cbd5e1; }

    </style>
</head>
<body>

    <h1>–ú–∞—à–∏–Ω–Ω–∏–π –∑—ñ—Ä: –∑–≥–æ—Ä—Ç–∫–æ–≤—ñ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ</h1>
    <details style="background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.05);">
    <summary style="cursor: pointer; font-weight: bold; color: #4f46e5; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
        <span></span> –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –¥–æ–≤—ñ–¥–∫–∞  
    </summary>
    
    <div style="padding-top: 20px; font-family: 'Segoe UI', sans-serif;">
        
        <div style="overflow-x: auto; padding-bottom: 10px;">
            <svg width="750" height="280" viewBox="0 0 750 280" style="min-width: 750px;">
                <defs>
                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L0,6 L9,3 z" fill="#94a3b8" />
                    </marker>
                    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                        <feDropShadow dx="2" dy="2" stdDeviation="2" flood-color="#00000020"/>
                    </filter>
                </defs>

                <g transform="translate(20, 80)">
                    <rect x="0" y="0" width="60" height="60" fill="white" stroke="#334155" stroke-width="2" filter="url(#shadow)"/>
                    <g fill="#cbd5e1"> <rect x="5" y="5" width="10" height="10"/><rect x="18" y="5" width="10" height="10"/>
                        <rect x="5" y="18" width="10" height="10"/><rect x="18" y="18" width="10" height="10"/>
                    </g>
                    <text x="30" y="85" text-anchor="middle" font-size="12" font-weight="bold" fill="#334155">Input</text>
                    <text x="30" y="100" text-anchor="middle" font-size="10" fill="#64748b">28x28 px</text>
                </g>

                <line x1="90" y1="110" x2="130" y2="110" stroke="#94a3b8" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="110" y="100" text-anchor="middle" font-size="10" fill="#4f46e5">–ó–≥–æ—Ä—Ç–∫–∞</text>

                <g transform="translate(140, 60)">
                    <rect x="0" y="0" width="50" height="50" fill="#dbeafe" stroke="#2563eb" stroke-width="1"/>
                    <rect x="5" y="5" width="50" height="50" fill="#dbeafe" stroke="#2563eb" stroke-width="1"/>
                    <rect x="10" y="10" width="50" height="50" fill="#eff6ff" stroke="#2563eb" stroke-width="2"/>
                    
                    <text x="35" y="85" text-anchor="middle" font-size="12" font-weight="bold" fill="#334155">Feature Maps</text>
                    <text x="35" y="100" text-anchor="middle" font-size="10" fill="#64748b">8 –∫–∞—Ä—Ç –æ–∑–Ω–∞–∫</text>
                </g>

                <line x1="210" y1="110" x2="250" y2="110" stroke="#94a3b8" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="230" y="100" text-anchor="middle" font-size="10" fill="#4f46e5">Pooling </text>
				 <text x="230" y="125" text-anchor="middle" font-size="10" fill="#4f46e5">+ Flatten</text>

                <g transform="translate(260, 40)">
                    <circle cx="10" cy="10" r="3" fill="#94a3b8"/>
                    <circle cx="10" cy="25" r="3" fill="#94a3b8"/>
                    <circle cx="10" cy="40" r="3" fill="#94a3b8"/>
                    <text x="10" y="65" text-anchor="middle" font-size="14" fill="#94a3b8">‚ãÆ</text>
                    <circle cx="10" cy="90" r="3" fill="#94a3b8"/>
                    <text x="10" y="120" text-anchor="middle" font-size="10" fill="#64748b">1352 –≤—Ö–æ–¥—ñ–≤</text>
                </g>

                <g stroke="#e2e8f0" stroke-width="1">
                    <line x1="280" y1="50" x2="400" y2="80" />
                    <line x1="280" y1="50" x2="400" y2="140" />
                    <line x1="280" y1="100" x2="400" y2="80" />
                    <line x1="280" y1="100" x2="400" y2="140" />
                </g>

                <g transform="translate(400, 60)">
                    <circle cx="0" cy="20" r="18" fill="#fef3c7" stroke="#d97706" stroke-width="2"/>
                    <text x="0" y="24" text-anchor="middle" font-size="12" font-weight="bold" fill="#92400e">X</text>
                    
                    <circle cx="0" cy="80" r="18" fill="#fef3c7" stroke="#d97706" stroke-width="2"/>
                    <text x="0" y="84" text-anchor="middle" font-size="12" font-weight="bold" fill="#92400e">Y</text>
                    
                    <text x="0" y="125" text-anchor="middle" font-size="12" font-weight="bold" fill="#334155">Latent</text>
                    <text x="0" y="140" text-anchor="middle" font-size="10" fill="#64748b">–ü—Ä–∏—Ö–æ–≤–∞–Ω–∏–π —à–∞—Ä 2 –Ω–µ–π—Ä–æ–Ω–∞</text>
                </g>

                <g stroke="#cbd5e1" stroke-width="2">
                    <line x1="420" y1="80" x2="550" y2="40" />
                    <line x1="420" y1="80" x2="550" y2="110" />
                    <line x1="420" y1="80" x2="550" y2="180" />
                    
                    <line x1="420" y1="140" x2="550" y2="40" />
                    <line x1="420" y1="140" x2="550" y2="110" />
                    <line x1="420" y1="140" x2="550" y2="180" />
                </g>

                <g transform="translate(550, 40)">
                    <circle cx="0" cy="0" r="22" fill="#dcfce7" stroke="#16a34a" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" font-size="16">üê†</text>
                    <text x="35" y="5" font-size="12" fill="#166534" font-weight="bold">–†–∏–±–∞ </text>

                    <circle cx="0" cy="70" r="22" fill="#fee2e2" stroke="#dc2626" stroke-width="2"/>
                    <text x="0" y="75" text-anchor="middle" font-size="16">‚ùÑ</text>
                    <text x="35" y="75" font-size="12" fill="#991b1b" font-weight="bold">–°–Ω—ñ–∂–∏–Ω–∫–∞ </text>

                    <circle cx="0" cy="140" r="22" fill="#dbeafe" stroke="#2563eb" stroke-width="2"/>
                    <text x="0" y="145" text-anchor="middle" font-size="16">üê±</text>
                    <text x="35" y="145" font-size="12" fill="#1e40af" font-weight="bold">–ö—ñ—Ç</text>
                </g>
            </svg>
        </div>

        <hr style="border: 0; border-top: 1px solid #eee; margin: 10px 0;">

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 0.9em; line-height: 1.5;">
            <div>
                <h4 style="color: #4f46e5; margin-bottom: 5px;">1. –ó—ñ—Ä (Convolution)</h4>
                <p style="margin:0; color: #475569;">
                    –°–ø–æ—á–∞—Ç–∫—É –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è <strong>28x28</strong> —Å–∫–∞–Ω—É—î—Ç—å—Å—è <strong>8 —Ñ—ñ–ª—å—Ç—Ä–∞–º–∏</strong> (–ª—ñ–Ω—ñ—ó, –∫—É—Ç–∏, —Ç–æ—á–∫–∏). 
                    –¶–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î –∫–∞—Ä—Ç–∏–Ω–∫—É –Ω–∞ –Ω–∞–±—ñ—Ä "–∫–∞—Ä—Ç –æ–∑–Ω–∞–∫" ‚Äî –¥–µ —Å–≤—ñ—Ç–∏—Ç—å—Å—è "—Ö–≤—ñ—Å—Ç", –∞ –¥–µ "–æ–∫–æ".
                </p>
            </div>
            <div>
                <h4 style="color: #d97706; margin-bottom: 5px;">2. –°—Ç–∏—Å–Ω–µ–Ω–Ω—è (Latent)</h4>
                <p style="margin:0; color: #475569;">
                    –í–µ–ª–∏—á–µ–∑–Ω–∏–π –ø–æ—Ç—ñ–∫ –¥–∞–Ω–∏—Ö –ø—Ä–æ –≤—Å—ñ –∑–Ω–∞–π–¥–µ–Ω—ñ –ª—ñ–Ω—ñ—ó —Å—Ç–∏—Å–∫–∞—î—Ç—å—Å—è –≤—Å—å–æ–≥–æ –¥–æ <strong>2 –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (X, Y)</strong>. 
                    –¶–µ –∑–º—É—à—É—î –º–µ—Ä–µ–∂—É –≤—ñ–¥–∫–∏–Ω—É—Ç–∏ –∑–∞–π–≤–µ (—à—É–º) —ñ –∑–∞–ª–∏—à–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ "—Å—É—Ç—å" (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: –Ω–∞—Å–∫—ñ–ª—å–∫–∏ –æ–±'—î–∫—Ç –∫—Ä—É–≥–ª–∏–π —ñ —á–∏ —î –≤—É—Ö–∞).
                </p>
            </div>
            <div style="grid-column: span 2;">
                <h4 style="color: #16a34a; margin-bottom: 5px;">3. –†—ñ—à–µ–Ω–Ω—è (Classification)</h4>
                <p style="margin:0; color: #475569;">
                    –î–≤–∞ –Ω–µ–π—Ä–æ–Ω–∏ –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É –∑'—î–¥–Ω–∞–Ω—ñ –∑ 3 –≤–∏—Ö—ñ–¥–Ω–∏–º–∏ –∫–ª–∞—Å–∞–º–∏. 
                    –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫—â–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø–æ—Ç—Ä–∞–ø–ª—è—é—Ç—å —É –∑–æ–Ω—É (X=0.8, Y=-0.5), –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è –Ω–µ–π—Ä–æ–Ω "–ö—ñ—Ç".
                </p>
            </div>
        </div>
    </div>
	
	
		<div style="padding-top: 20px; font-family: 'Segoe UI', sans-serif; color: #334155; line-height: 1.7;">

        <h3 style="color: #4f46e5; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px;"> –ó–≥–æ—Ä—Ç–∫–∞ (Convolution)</h3>
        <p>
            –¶–µ —Å–µ—Ä—Ü–µ –Ω–∞—à–æ—ó —Å–∏—Å—Ç–µ–º–∏. –ó–≥–æ—Ä—Ç–∫–∞ ‚Äî —Ü–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è, —è–∫–∞ "–ø—Ä–æ—Ç—è–≥—É—î" –º–∞–ª–µ–Ω—å–∫–∏–π —Ñ—ñ–ª—å—Ç—Ä —á–µ—Ä–µ–∑ –≤–µ–ª–∏–∫–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, —â–æ–± –∑–Ω–∞–π—Ç–∏ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è.
        </p>
        <div style="background:#f8fafc; padding:10px; border-radius:6px; border-left:4px solid #4f46e5; margin: 10px 0;">
            $$ Y_{i,j} = \sum_{m=0}^{k-1} \sum_{n=0}^{k-1} X_{i+m, j+n} \cdot K_{m,n} + b $$
        </div>
        <ul style="list-style: none; padding-left: 10px; font-size: 0.95em;">
            <li>üîπ <strong>$Y_{i,j}$</strong> ‚Äî –µ–ª–µ–º–µ–Ω—Ç –≤–∏—Ö—ñ–¥–Ω–æ—ó –∫–∞—Ä—Ç–∏ –æ–∑–Ω–∞–∫ (Feature Map). </li>
            <li>üîπ <strong>$X$</strong> ‚Äî –≤—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è (–ú–∞—Ç—Ä–∏—Ü—è $28 \times 28$).</li>
            <li>üîπ <strong>$K$</strong> ‚Äî —è–¥—Ä–æ –∑–≥–æ—Ä—Ç–∫–∏ (–ú–∞—Ç—Ä–∏—Ü—è $3 \times 3$, —è–∫—É –º–∏ –∑–∞–¥–∞—î–º–æ: –ª—ñ–Ω—ñ—ó, –∫—É—Ç–∏).</li>
            <li>üîπ <strong>$b$</strong> ‚Äî –∑—Å—É–≤ (bias). –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞, —è–∫–∞ –¥–æ–¥–∞—î—Ç—å—Å—è –¥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É.</li>
        </ul>
        <p>
            <strong>–Ø–∫ –∑–º—ñ–Ω—é—î—Ç—å—Å—è —Ä–æ–∑–º—ñ—Ä?</strong><br>
            –Ø–∫—â–æ –≤—Ö—ñ–¥ $W \times H$ (28x28), –∞ —è–¥—Ä–æ $k \times k$ (3x3):
            $$ Size_{out} = W - k + 1 $$
            $$ 28 - 3 + 1 = 26 $$
            –¢–æ–º—É –ø—ñ—Å–ª—è –∑–≥–æ—Ä—Ç–∫–∏ –º–∏ –æ—Ç—Ä–∏–º—É—î–º–æ –º–∞—Ç—Ä–∏—Ü—é $26 \times 26$. –ö—Ä–∞–π–Ω—ñ –ø—ñ–∫—Å–µ–ª—ñ "–∑'—ó–¥–∞—é—Ç—å—Å—è", –±–æ —è–¥—Ä–æ –Ω–µ –º–æ–∂–µ –≤–∏–π—Ç–∏ –∑–∞ –º–µ–∂—ñ –∫–∞—Ä—Ç–∏–Ω–∫–∏ (–±–µ–∑ padding).
        </p>

     

        <h3 style="color: #4f46e5; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-top: 30px;">–ü–æ–≤–Ω–æ–∑–≤'—è–∑–Ω–∏–π —à–∞—Ä (Dense)</h3>
        <p>
            –¢—É—Ç –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è "–û–∑–Ω–∞–∫" (–ª—ñ–Ω—ñ–π, –∫—É—Ç—ñ–≤) —É "–ö–ª–∞—Å–∏" (–ö—ñ—Ç, –†–∏–±–∞).
        </p>
        <div style="background:#f8fafc; padding:10px; border-radius:6px; border-left:4px solid #4f46e5; margin: 10px 0;">
            $$ \vec{z} = \sigma (W \cdot \vec{x} + \vec{b}) $$
        </div>
        <ul style="list-style: none; padding-left: 10px; font-size: 0.95em;">
            <li>üîπ <strong>$\vec{x}$</strong> ‚Äî –≤—Ö—ñ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (—Å—Ç–æ–≤–ø—á–∏–∫). –£ –Ω–∞—à–æ–º—É –≤–∏–ø–∞–¥–∫—É —Ü–µ <strong>1352</strong> —á–∏—Å–ª–∞ –ø—ñ—Å–ª—è –≤–∏–ø—Ä—è–º–ª–µ–Ω–Ω—è -  –º–∏ —Ä–æ–∑–≥–æ—Ç–∞—î–º–æ –º–∞—Ç—Ä–∏—Ü—é (–∫–∞—Ä—Ç—É –æ–∑–Ω–∞–∫) –≤ –æ–¥–∏–Ω –¥–æ–≤–≥–∏–π —Å—Ç–æ–≤–±—á–∏–∫ (—Ç–∞–∫ –∑–≤–∞–Ω–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ Flatten).  $13 \times 13 \times 8 = 1352$ —Ç–æ–º—É —â–æ –∫–æ–∂–Ω–∞ –∑ –≤–æ—Å—å–º–∏ –∫–∞—Ä—Ç –æ–∑–Ω–∞–∫  $26 \times 26$ —Å—Ç–∏—Å–∫–∞—î—Ç—å—Å—è - —á–æ—Ç–∏—Ä–∏ –ø—ñ–∫—Å–µ–ª—è –≤ –æ–¥–∏–Ω - —ñ —Å—Ç–∞—î —Ä–æ–∑–º—ñ—Ä–æ–º $13 \times 13$. –¢–∞–∫–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è pooling. 8 - —Ü–µ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ñ—ñ–ª—å—Ç—Ä—ñ–≤ (—è–¥–µ—Ä –∑–≥–æ—Ä—Ç–∫–∏ - –≤–µ—Ä—Ç–∏–∫–∞–ª–Ω—ñ, –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ñ, –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó, —Ç–æ—á–∫–∏, –∫—É—Ç–∏). </li>
            <li>üîπ <strong>$W$</strong> ‚Äî –º–∞—Ç—Ä–∏—Ü—è –≤–∞–≥. –†–æ–∑–º—ñ—Ä $2 \times 1352$. –°–∞–º–µ —Ü—ñ —á–∏—Å–ª–∞ –º–∏ "–Ω–∞–≤—á–∞—î–º–æ".</li>
            <li>üîπ <strong>$\vec{b}$</strong> ‚Äî –≤–µ–∫—Ç–æ—Ä –∑—Å—É–≤—É (Bias). –†–æ–∑–º—ñ—Ä $2$.</li>
            <li>üîπ <strong>$\vec{z}$</strong> ‚Äî –≤–∏—Ö—ñ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –≤ –ª–∞—Ç–µ–Ω—Ç–Ω–æ–º—É –ø—Ä–æ—Å—Ç–æ—Ä—ñ).</li>
			<li>üîπ <strong>$\sigma (.) $</strong> ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó.</li>
        </ul>
        <p>
            <strong>–ù–∞–≤—ñ—â–æ –ø–æ—Ç—Ä—ñ–±–µ–Ω Bias ($b$)?</strong><br>
            –†—ñ–≤–Ω—è–Ω–Ω—è –ª—ñ–Ω—ñ—ó $y = ax + b$. –ë–µ–∑ $b$ –ª—ñ–Ω—ñ—è –∑–∞–≤–∂–¥–∏ –ø—Ä–æ—Ö–æ–¥–∏—Ç–∏–º–µ —á–µ—Ä–µ–∑ $(0,0)$. <br>
            –í –Ω–µ–π—Ä–æ–Ω–∞—Ö $b$ –º–æ–∂–Ω–∞ —Ä–æ–∑—É–º—ñ—Ç–∏ —è–∫ <strong>–ø–æ—Ä—ñ–≥ —á—É—Ç–ª–∏–≤–æ—Å—Ç—ñ</strong>. –í—ñ–Ω –¥–æ–∑–≤–æ–ª—è—î –Ω–µ–π—Ä–æ–Ω—É "–º–æ–≤—á–∞—Ç–∏", –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ –≤—Ö—ñ–¥–Ω–∏–π —Å–∏–≥–Ω–∞–ª –Ω–µ –Ω—É–ª—å–æ–≤–∏–π, –∞–±–æ –Ω–∞–≤–ø–∞–∫–∏, –±—É—Ç–∏ –∞–∫—Ç–∏–≤–Ω–∏–º –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º. <strong>Bias —Ç–µ–∂ –Ω–∞–≤—á–∞—î—Ç—å—Å—è</strong> —á–µ—Ä–µ–∑ –≥—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫.
        </p>

   <h3 style="color: #4f46e5; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-top: 30px;">–§—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó</h3>
        <p>
            –ü—Ä–∏—Ä–æ–¥–Ω–∏–π –Ω–µ–π—Ä–æ–Ω –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è (–∑–±—É–¥–∂—É—î—Ç—å—Å—è) —Ç—ñ–ª—å–∫–∏ –∑–∞ —É–º–æ–≤–∏, —è–∫—â–æ —á–∞—Å—Ç–æ—Ç–∞ –Ω–µ—Ä–≤–æ–≤–∏—Ö —ñ–º–ø—É–ª—å—Å—ñ–≤ –ø–µ—Ä–µ–≤–∏—â–∏—Ç—å –ø–µ–≤–Ω–∏–π –ø–æ—Ä—ñ–≥. –í —à—Ç—Ü—á–Ω–∏—Ö –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞—Ö –∞–∫—Ç–∏–≤–∞—Ü—ñ—è –≤–∏—Ä—ñ—à—É—î, —á–∏ "—Å–ø—Ä–∞—Ü—é—î" –Ω–µ–π—Ä–æ–Ω –¥–∞–ª—ñ. –ó–∞–∑–≤–∏—á–∞–π —Ü–µ –¥–µ—è–∫–∞ –Ω–µ–ª—ñ–Ω—ñ—è–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è.
            $$ \sigma = f(z) $$
        </p>
        <table style="width:100%; border-collapse: collapse; font-size: 0.9em;">
            <tr style="border-bottom: 1px solid #cbd5e1;">
                <td style="padding: 8px; font-weight:bold;">ReLU</td>
                <td style="padding: 8px;">$$f(z) = \max(0, z)$$</td>
                <td style="padding: 8px;"> –í—ñ–¥–∫–∏–¥–∞—î –≤—Å—ñ –≤—ñ–¥'—î–º–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è (—à—É–º) —ñ –ø—Ä–æ–ø—É—Å–∫–∞—î –ø–æ–∑–∏—Ç–∏–≤–Ω—ñ –±–µ–∑ –∑–º—ñ–Ω. –†–æ–±–∏—Ç—å –º–µ—Ä–µ–∂—É –Ω–µ–ª—ñ–Ω—ñ–π–Ω–æ—é.</td>
            </tr>
            <tr style="border-bottom: 1px solid #cbd5e1;">
                <td style="padding: 8px; font-weight:bold;">Sigmoid</td>
                <td style="padding: 8px;">$$f(z) = \frac{1}{1 + e^{-z}}$$</td>
                <td style="padding: 8px;">–°—Ç–∏—Å–∫–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç —É –¥—ñ–∞–ø–∞–∑–æ–Ω $(0, 1)$. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–ª–∞—Å—è —Ä–∞–Ω—ñ—à–µ, –∑–∞—Ä–∞–∑ —Ä—ñ–¥—à–µ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–ª–µ–º—É –∑–Ω–∏–∫–∞—é—á–æ–≥–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞.</td>
            </tr>
            <tr>
                <td style="padding: 8px; font-weight:bold;">Linear</td>
                <td style="padding: 8px;">$$f(z) = z$$</td>
                <td style="padding: 8px;"><strong>–ë–µ–∑ –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó.</strong> –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞—î —Å–∏–≥–Ω–∞–ª –¥–∞–ª—ñ. –Ø–∫—â–æ –≤—Å—è –º–µ—Ä–µ–∂–∞ –ª—ñ–Ω—ñ–π–Ω–∞, —Ç–æ —Å–∫—ñ–ª—å–∫–∏ –± —à–∞—Ä—ñ–≤ –Ω–µ –±—É–ª–æ, –≤–æ–Ω–∞ –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∞ –æ–¥–Ω—ñ–π –º–∞—Ç—Ä–∏—Ü—ñ. –ù–µ –º–æ–∂–µ –≤–∏—Ä—ñ—à—É–≤–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ –∑–∞–¥–∞—á—ñ (XOR) —á–∏ –∑–Ω–∞—Ö–æ–¥–∏—Ç–∏ –∫–ª–∞—Å—Ç–µ—Ä–∏ —Å–∫–ª–∞–¥–Ω–æ—ó —Ñ–æ—Ä–º–∏.</td>
            </tr>
        </table>

         <h3 style="color: #4f46e5; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px;">–ù–∞–≤—á–∞–Ω–Ω—è</h3>
    <p>
        <b>–ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫</b>. –£—è–≤—ñ—Ç—å, —â–æ –≤–∏ —Å—Ç–æ—ó—Ç–µ –Ω–∞ –≥–æ—Ä—ñ –≤ —Ç—É–º–∞–Ω—ñ (—Ñ—É–Ω–∫—Ü—ñ—è –ø–æ–º–∏–ª–∫–∏) —ñ —Ö–æ—á–µ—Ç–µ —Å–ø—É—Å—Ç–∏—Ç–∏—Å—è –≤ –¥–æ–ª–∏–Ω—É. 
        –í–∏ –Ω–∞–º–∞—Ü—É—î—Ç–µ –Ω–æ–≥–æ—é –Ω–∞–ø—Ä—è–º–æ–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –Ω–∞—Ö–∏–ª—É —ñ —Ä–æ–±–∏—Ç–µ –∫—Ä–æ–∫ –≤–Ω–∏–∑.
    </p>

    <h4>–§—É–Ω–∫—Ü—ñ—è –≤—Ç—Ä–∞—Ç (Loss Function)</h4>
    <p>
        –û—Ü—ñ–Ω—é—î–º–æ, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ —Å–∏–ª—å–Ω–æ –ø–æ–º–∏–ª–∏–ª–∞—Å—è –º–µ—Ä–µ–∂–∞, –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ñ—É–Ω–∫—Ü—ñ—ó –≤—Ç—Ä–∞—Ç $L$. 
        –ú–µ—Ç–∞ ‚Äî –∑–Ω–∞–π—Ç–∏ —Ç–∞–∫—ñ –≤–∞–≥–∏ $W$, —â–æ–± $L \to 0$.
        –§–æ—Ä–º—É–ª–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∞–≥–∏:
        $$ W_{new} = W_{old} - \eta \cdot \frac{\partial L}{\partial W} $$
    </p>
    <ul>
        <li>$\eta$ (learning rate) ‚Äî "–¥–æ–≤–∂–∏–Ω–∞ –∫—Ä–æ–∫—É", –∞–±–æ —à–≤–∏–¥–∫—ñ—Å—Ç—å –Ω–∞–≤—á–∞–Ω–Ω—è.</li>
        <li>$\frac{\partial L}{\partial W}$ (–≥—Ä–∞–¥—ñ—î–Ω—Ç) ‚Äî –ø–æ–∫–∞–∑—É—î, —è–∫ –∑–º—ñ–Ω–∞ –≤–∞–≥–∏ –≤–ø–ª–∏–Ω–µ –Ω–∞ –ø–æ–º–∏–ª–∫—É.</li>
    </ul>

    <h4>–ó–≤–æ—Ä–æ—Ç–Ω–µ –ø–æ—à–∏—Ä–µ–Ω–Ω—è (Backpropagation)</h4>
    <p>
        –î–ª—è —Ç–æ–≥–æ, —â–æ–± –∑–Ω–∞–π—Ç–∏ –≥—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è –≥–ª–∏–±–∏–Ω–Ω–∏—Ö —à–∞—Ä—ñ–≤, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å <b>–õ–∞–Ω—Ü—é–≥–æ–≤–µ –ø—Ä–∞–≤–∏–ª–æ (Chain Rule)</b>. 
        –ü–æ–º–∏–ª–∫–∞ –ø–æ—à–∏—Ä—é—î—Ç—å—Å—è –≤—ñ–¥ –≤–∏—Ö–æ–¥—É –¥–æ –≤—Ö–æ–¥—É:
    </p>
    $$ \frac{\partial L}{\partial w} = \underbrace{\frac{\partial L}{\partial y}}_{\text{–ø–æ–º–∏–ª–∫–∞ –≤–∏—Ö–æ–¥—É}} \cdot \underbrace{\frac{\partial y}{\partial z}}_{\text{–ø–æ—Ö—ñ–¥–Ω–∞ –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó}} \cdot \underbrace{\frac{\partial z}{\partial w}}_{\text{–≤—Ö—ñ–¥ –Ω–µ–π—Ä–æ–Ω–∞}} $$
    <p>
        –¶–µ –¥–æ–∑–≤–æ–ª—è—î –Ω–∞–º —Ç–æ—á–Ω–æ –∑–Ω–∞—Ç–∏, —è–∫–∏–π –Ω–µ–π—Ä–æ–Ω "–≤–∏–Ω–µ–Ω" —É –ø–æ–º–∏–ª—Ü—ñ —Ç–∞ –ø—ñ–¥–∫—Ä—É—Ç–∏—Ç–∏ –π–æ–≥–æ –≤–∞–≥–∏.
    </p>
       
    </div>
	
	
	
	 <h3 style="color: #4f46e5; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px;">–®–∞—Ä —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è (Output Layer)</h3>
    <p>
        –ù–∞—Ä–µ—à—Ç—ñ –æ—Å—Ç–∞–Ω–Ω—ñ–π —à–∞—Ä –º–µ—Ä–µ–∂—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î "—Å–∏—Ä—ñ" —Å–∏–≥–Ω–∞–ª–∏ –Ω–µ–π—Ä–æ–Ω—ñ–≤ (–ª–æ–≥—ñ—Ç–∏ $z$) —É –∑—Ä–æ–∑—É–º—ñ–ª—ñ –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ. 
        –î–ª—è —Ü—å–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å –ø–∞—Ä—É <b>Softmax</b> + <b>Cross-Entropy</b>.
    </p>

    <h4>–ê–∫—Ç–∏–≤–∞—Ü—ñ—è Softmax</h4>
    <p>
        –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î –±—É–¥—å-—è–∫—ñ —á–∏—Å–ª–∞ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, $[-2.5, 0.1, 5.0]$) —É –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ, —â–æ –≤ —Å—É–º—ñ –¥–∞—é—Ç—å 1 (100%).
        –§–æ—Ä–º—É–ª–∞ –¥–ª—è $i$-–≥–æ –∫–ª–∞—Å—É:
    </p>
    $$ p_i = \frac{e^{z_i}}{\sum_{j=1}^{K} e^{z_j}} $$
    <ul>
        <li>$z_i$ ‚Äî –≤–∏—Ö—ñ–¥ –Ω–µ–π—Ä–æ–Ω–∞ –ø–µ—Ä–µ–¥ –∞–∫—Ç–∏–≤–∞—Ü—ñ—î—é (logit).</li>
        <li>$e^{z_i}$ ‚Äî –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞, —Ä—ñ–∑–∫–æ –ø—ñ–¥—Å–∏–ª—é—î –≤–µ–ª–∏–∫—ñ –∑–Ω–∞—á–µ–Ω–Ω—è (—Ä–æ–±–∏—Ç—å –≤–∏–±—ñ—Ä –º–µ—Ä–µ–∂—ñ –≤–ø–µ–≤–Ω–µ–Ω—ñ—à–∏–º).</li>
        <li>$\sum$ ‚Äî —Å—É–º–∞ –≤—Å—ñ—Ö –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç (–Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è).</li>
    </ul>

    <h4>–í—Ç—Ä–∞—Ç–∏: Categorical Cross-Entropy</h4>
    <p>
        –ú–∏ —Ö–æ—á–µ–º–æ, —â–æ–± –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –∫–ª–∞—Å—É –±—É–ª–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ—é (–±–ª–∏–∑—å–∫–æ—é –¥–æ 1). 
        –§—É–Ω–∫—Ü—ñ—è –≤—Ç—Ä–∞—Ç —à—Ç—Ä–∞—Ñ—É—î –º–µ—Ä–µ–∂—É –ª–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω–æ:
    </p>
    $$ L = - \sum_{i=1}^{K} y_i \cdot \log(p_i) $$
    <ul>
        <li>$y_i$ ‚Äî —ñ—Å—Ç–∏–Ω–Ω–∞ –º—ñ—Ç–∫–∞ (1 –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –∫–ª–∞—Å—É, 0 –¥–ª—è —ñ–Ω—à–∏—Ö).</li>
        <li>$p_i$ ‚Äî –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–∞ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å.</li>
        <li>$\log(p_i)$ ‚Äî —è–∫—â–æ $p_i \approx 0$ (–º–µ—Ä–µ–∂–∞ –ø–æ–º–∏–ª–∏–ª–∞—Å—è), —à—Ç—Ä–∞—Ñ $L$ —Å—Ç–∞—î –≤–µ–ª–∏—á–µ–∑–Ω–∏–º.</li>
    </ul>

    <div style="background: #e0f2fe; padding: 10px; border-radius: 5px; margin-top: 10px;">
        <b>–í–∞–∂–ª–∏–≤–µ —Å–ø—Ä–æ—â–µ–Ω–Ω—è:</b>
        –Ø–∫—â–æ –≤–∑—è—Ç–∏ –ø–æ—Ö—ñ–¥–Ω—É –≤—ñ–¥ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó Softmax —Ç–∞ Cross-Entropy, –º–∏ –æ—Ç—Ä–∏–º–∞—î–º–æ –µ–ª–µ–≥–∞–Ω—Ç–Ω—É —Ñ–æ—Ä–º—É–ª—É –¥–ª—è –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞, —è–∫—É –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –≤ –∫–æ–¥—ñ:
        $$ \frac{\partial L}{\partial z_i} = p_i - y_i $$
        –¢–æ–±—Ç–æ –ø–æ–º–∏–ª–∫–∞ ‚Äî —Ü–µ –ø—Ä–æ—Å—Ç–æ —Ä—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ <i>–ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è–º</i> —Ç–∞ <i>—Ñ–∞–∫—Ç–æ–º</i>.
    </div>
</details>
  

    <div class="main-grid">
        
        <div class="panel">
            <h3>1. –í—Ö—ñ–¥ —Ç–∞ –û–±—Ä–æ–±–∫–∞</h3>
			<p style="font-size: 0.8em; color: #64748b; margin-bottom: 10px;">
               –ù–∞–º–∞–ª—é–π—Ç–µ –∫—ñ–ª—å–∫–∞ –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤ –∫–æ—Ç–∞, —Å–Ω—ñ–∂–∏–Ω–∫–∏ —ñ —Ä–∏–±'—è—á–æ–≥–æ –∫—ñ—Å—Ç—è–∫–∞. –ù–∞—Ç–∏—Å–Ω—ñ—Å—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—É –∫–Ω–æ–ø–∫—É, —â–æ–± –º–µ—Ä–µ–∂–∞ –∑–º–æ–≥–ª–∞ –Ω–∞–≤—á–∏—Ç–∏—Å—è.
            </p>
            <div class="canvas-wrap">
			
                <canvas id="bigCanvas" width="224" height="224"></canvas>
            </div>
            
            <div class="btn-group">
                <button onclick="clearSystem()">‚ùå –û—á–∏—Å—Ç–∏—Ç–∏</button>
               <button class="primary" onclick="predictAndViz()">‚ö° </button>
            </div>

          

            <hr style="margin: 15px 0; border-color: #e2e8f0;">
            
            <div style="text-align: center; font-size: 0.9em; margin-bottom: 5px;"><strong>–ù–∞–≤—á–∞–Ω–Ω—è (Training):</strong></div>
			 
            <div class="btn-group">
                <button onclick="addSample(0)">üê± –ö—ñ—Ç</button>
                <button onclick="addSample(1)">üê† –†–∏–±–∞</button>
                <button onclick="addSample(2)">‚ùÖ —Å–Ω—ñ–∂–∏–Ω–∫–∞</button>
            </div>
            <div class="btn-group">
                <button class="primary" style="background: #6366f1;" onclick="startAutoCollect()">ü§ñ –ê–≤—Ç–æ-–∑–±—ñ—Ä (30—à—Ç)</button>
                <button class="success" id="btnTrain" disabled onclick="trainStep()">–ù–∞–≤—á–∏—Ç–∏/–î–æ–Ω–∞–≤—á–∏—Ç–∏</button>
            </div>
            <div id="trainStats" style="font-size: 0.8em; text-align: center; height: 1.2em;">–î–∞–Ω–∏—Ö: 0</div>
        </div>

        <div class="panel">
            <h3>2. –ó–≥–æ—Ä—Ç–∫–∞ (Convolution)</h3>
            <p style="font-size: 0.8em; color: #64748b; margin-bottom: 10px;">
                –ú–µ—Ä–µ–∂–∞ —Å–∫–∞–Ω—É—î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è 8 —Ñ—ñ–ª—å—Ç—Ä–∞–º–∏. –ù–∞–º–∞–ª—é–π—Ç–µ –∫—ñ–ª—å–∫–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏—Ö –ª—ñ–Ω—ñ–π —ñ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "–°–∫–∞–Ω", —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –ø—Ä–æ—Ü–µ—Å –∑–≥–æ—Ä—Ç–∫–∏ - –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ—ó —Å—Ö–æ–∂–µ—Å—Ç—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—É –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ —è–¥—Ä–æ–º (—Ñ—ñ–ª—å—Ç—Ä–æ–º).
            </p>
            
            <button class="primary" style="width: 100%; margin-bottom: 10px;" onclick="runVisualScan()">üîç –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –í—ñ–∑—É–∞–ª—å–Ω–∏–π –°–∫–∞–Ω–µ—Ä</button>
				
				  <div style="background: #f8fafc; padding: 10px; border-radius: 8px; margin-top: 10px;">
                <div style="font-size: 0.8em; margin-bottom: 5px; font-weight: bold; text-align: center;">–©–æ –±–∞—á–∏—Ç—å "–æ–∫–æ" –º–µ—Ä–µ–∂—ñ (28x28):</div>
                <div class="small-view">
                    <div class="pixel-view" id="inputContainer">
                        <canvas id="smallCanvas" width="28" height="28" style="width: 100%; height: 100%;"></canvas>
                        <div id="scanner" class="scan-box"></div>
                    </div>
                    <div style="font-size: 2em;">...</div>
                </div>
                <div style="font-size: 0.75em; color: #64748b; text-align: center;">Smart Crop + Downsampling</div>
            </div>
				
				
            <div class="filters-grid" id="filtersList">
                </div>
            
            <div style="margin-top: 10px; text-align: center; font-size: 0.8em; color: #64748b;">
                ‚¨áÔ∏è Max Pooling (–ó–º–µ–Ω—à–µ–Ω–Ω—è –≤ 2 —Ä–∞–∑–∏) ‚¨áÔ∏è
            </div>
		
			
        </div>

        <div class="panel">
            <h3>3. Deep Structure & Latent</h3>
            
          

            <label style="font-size: 0.9em; font-weight: bold;">–§—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó (–¥–ª—è 2 –Ω–µ–π—Ä–æ–Ω—ñ–≤):</label>
            <select id="actFunc" onchange="updateActivation()">
                <option value="linear">Linear (–ë–µ–∑ –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó)</option>
				<option value="tanh">Tanh (–ì—ñ–ø–µ—Ä–±–æ–ª—ñ—á–Ω–∏–π —Ç–∞–Ω–≥–µ–Ω—Å)</option>
                <option value="relu">ReLU (–í–∏–ø—Ä—è–º–ª—è—á)</option>
                <option value="sigmoid">Sigmoid (0..1)</option>
               
            </select>

            <div id="latentPlot" class="latent-plot"></div>
            
            <div style="margin-top: 15px;">
                <div style="display:flex; justify-content: space-between; font-size: 0.85em;"><span>üê± –ö—ñ—Ç</span><span id="p0">0%</span></div>
                <div style="height:8px; background:#eee; border-radius:4px; margin-bottom:5px;"><div id="b0" style="height:100%; width:0%; background:#f59e0b; border-radius:4px; transition: width 0.3s;"></div></div>
                
                <div style="display:flex; justify-content: space-between; font-size: 0.85em;"><span>üê† –†–∏–±–∞</span><span id="p1">0%</span></div>
                <div style="height:8px; background:#eee; border-radius:4px; margin-bottom:5px;"><div id="b1" style="height:100%; width:0%;  background:#ef4444; border-radius:4px; transition: width 0.3s;"></div></div>
                
                <div style="display:flex; justify-content: space-between; font-size: 0.85em;"><span>‚ùÖ —Å–Ω—ñ–∂–∏–Ω–∫–∞</span><span id="p2">0%</span></div>
                <div style="height:8px; background:#eee; border-radius:4px; margin-bottom:5px;"><div id="b2" style="height:100%; width:0%;background:#3b82f6; border-radius:4px; transition: width 0.3s;"></div></div>
            </div>
            <div id="finalRes" style="text-align: center; font-weight: bold; font-size: 1.2em; margin-top: 10px;">?</div>
			
			
				
					<div style="background: #f1f5f9; padding: 10px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #cbd5e1;">
    <div style="font-size: 0.9em; font-weight: bold; margin-bottom: 5px; text-align: center;">
        üëÅÔ∏è –©–æ "—à—É–∫–∞—é—Ç—å" –Ω–µ–π—Ä–æ–Ω–∏ Bottleneck? <br>
        <span style="font-size: 0.8em; color: #64748b; font-weight: normal;">(–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –≤–∞–≥: –ß–µ—Ä–≤–æ–Ω–µ = –¥–æ–¥–∞—Ç–Ω—è, –°–∏–Ω—î = –≤—ñ–¥'—î–º–Ω–∞)</span>
    </div>
    
    <div style="display: flex; justify-content: space-around; align-items: center;">
        <div style="text-align: center;">
            <div style="font-size: 0.8em; margin-bottom: 2px;">–ù–µ–π—Ä–æ–Ω X</div>
            <canvas id="latentW1" width="56" height="56" style="border: 2px solid #94a3b8; image-rendering: pixelated; width: 80px; height: 80px; background: #000;"></canvas>
        </div>

        <div style="text-align: center;">
            <div style="font-size: 0.8em; margin-bottom: 2px;">–ù–µ–π—Ä–æ–Ω Y</div>
            <canvas id="latentW2" width="56" height="56" style="border: 2px solid #94a3b8; image-rendering: pixelated; width: 80px; height: 80px; background: #000;"></canvas>
        </div>
    </div>
</div>
			
			
        </div>
    </div>

<script>
/* =========================================
   1. CORE CONFIG & KERNELS
   ========================================= */
/*const KERNELS = {
    'Horiz': [[-1,-1,-1],[2,2,2],[-1,-1,-1]],
    'Vert': [[-1,2,-1],[-1,2,-1],[-1,2,-1]],
    'Diag \\': [[2,-1,-1],[-1,2,-1],[-1,-1,2]],
    'Diag /': [[-1,-1,2],[-1,2,-1],[2,-1,-1]],
    'Dot': [[-1,-1,-1],[-1,8,-1],[-1,-1,-1]],
    'Arc Up': [[-1,-1,-1],[2,-1,2],[-1,2,-1]],
    'Arc down': [[-1,2,-1],[2,-1,2],[-1,-1,-1]],
    'Edge': [[8,-1,8],[-1,-1,-1],[8,-1,8]]
};*/

const KERNELS = {
    // 1. –õ–Ü–ù–Ü–á (–ë–∞–∑–∞ –¥–ª—è –†–∏–±–∏ —Ç–∞ –°–æ–Ω—Ü—è)
    'Horiz':  [[-1,-1,-1], [ 2, 2, 2], [-1,-1,-1]],
    'Vert':   [[-1, 2,-1], [-1, 2,-1], [-1, 2,-1]],
    'Diag 1': [[ 2,-1,-1], [-1, 2,-1], [-1,-1, 2]], // –õ—ñ–Ω—ñ—è \
    'Diag 2': [[-1,-1, 2], [-1, 2,-1], [ 2,-1,-1]], // –õ—ñ–Ω—ñ—è /

    // 2. –ö–£–¢–ò (–ë–∞–∑–∞ –¥–ª—è –ö–æ—Ç–∞ - –±–æ –∫–æ–ª–æ —Ü–µ –Ω–∞–±—ñ—Ä –∫—É—Ç—ñ–≤)
    // –ó–∞–º—ñ—Å—Ç—å —Å–ª–∞–±–∫–∏—Ö "–î—É–≥" –∫—Ä–∞—â–µ –≤–∑—è—Ç–∏ —á—ñ—Ç–∫—ñ –∫—É—Ç–∏
    'Corner TL': [[ 2, 2,-1], [ 2,-1,-1], [-1,-1,-1]], // –í–µ—Ä—Ö-–õ—ñ–≤–æ (–ì)
    'Corner BR': [[-1,-1,-1], [-1,-1, 2], [-1, 2, 2]], // –ù–∏–∑-–ü—Ä–∞–≤–æ (_|)

    // 3. –¢–û–ß–ö–ê (–û—á—ñ –∫–æ—Ç–∞, —Ü–µ–Ω—Ç—Ä –°–æ–Ω—Ü—è)
    'Dot':    [[-1,-1,-1], [-1, 8,-1], [-1,-1,-1]],

    // 4. –ö–û–ù–¢–£–† (Omni-directional edge) - —Ä–µ–∞–≥—É—î –Ω–∞ –±—É–¥—å-—è–∫—É —Ä—ñ–∑–∫—É –∑–º—ñ–Ω—É –∫–æ–ª—å–æ—Ä—É
    //'Outline': [[-1,-1,-1], [-1, 8,-1], [-1,-1,-1]] 
    // –ê–±–æ –∫—Ä–∞—â–µ Laplacian (–≤–∏–¥—ñ–ª—è—î –∫–æ–Ω—Ç—É—Ä–∏):
     'Laplace': [[ 0,-1, 0], [-1, 4,-1], [ 0,-1, 0]] 
};
const K_NAMES = Object.keys(KERNELS);
const K_VALS = Object.values(KERNELS);

const state = {
    isDrawing: false,
    samples: [],
    net: null,
    actName: 'linear',
    scanning: false
};

/* =========================================
   2. CANVAS INPUT HANDLING
   ========================================= */
const bigCv = document.getElementById('bigCanvas');
const bigCtx = bigCv.getContext('2d', {willReadFrequently: true});
const smallCv = document.getElementById('smallCanvas');
const smallCtx = smallCv.getContext('2d', {willReadFrequently: true});

// Init Canvas
bigCtx.fillStyle = "white"; bigCtx.fillRect(0,0,224,224);
bigCtx.lineWidth = 15; bigCtx.lineCap = 'round'; bigCtx.lineJoin = 'round'; bigCtx.strokeStyle = 'black';

// Events
function getXY(e) {
    const r = bigCv.getBoundingClientRect();
    const t = e.touches ? e.touches[0] : e;
    return [t.clientX - r.left, t.clientY - r.top];
}
bigCv.addEventListener('mousedown', e=>{ state.isDrawing=true; bigCtx.beginPath(); bigCtx.moveTo(...getXY(e)); });
bigCv.addEventListener('mousemove', e=>{ if(state.isDrawing){ bigCtx.lineTo(...getXY(e)); bigCtx.stroke(); } });
window.addEventListener('mouseup', ()=>{ if(state.isDrawing){ state.isDrawing=false; predictAndViz(); } });

bigCv.addEventListener('touchstart', e=>{ e.preventDefault(); state.isDrawing=true; bigCtx.beginPath(); bigCtx.moveTo(...getXY(e)); }, {passive:false});
bigCv.addEventListener('touchmove', e=>{ e.preventDefault(); if(state.isDrawing){ bigCtx.lineTo(...getXY(e)); bigCtx.stroke(); } }, {passive:false});
window.addEventListener('touchend', ()=>{ state.isDrawing=false; predictAndViz(); });

function clearSystem() {
    bigCtx.fillRect(0,0,224,224);
    smallCtx.fillStyle="white"; smallCtx.fillRect(0,0,28,28);
    document.querySelectorAll('.fmap-canvas').forEach(c => c.getContext('2d').clearRect(0,0,28,28));
    updatePlot(null);
    document.getElementById('finalRes').innerText = "?";
    [0,1,2].forEach(i => { document.getElementById(`b${i}`).style.width='0%'; document.getElementById(`p${i}`).innerText='0%'; });
}

/* =========================================
   3. PREPROCESSING (SMART CROP)
   ========================================= */
function getProcessedImage() {
    const img = bigCtx.getImageData(0,0,224,224);
    const d = img.data;
    let minX=224, minY=224, maxX=0, maxY=0, found=false;
    
    // 1. –®—É–∫–∞—î–º–æ –º–µ–∂—ñ –º–∞–ª—é–Ω–∫–∞ (Bounding Box)
    for(let y=0; y<224; y++) {
        for(let x=0; x<224; x++) {
            // –®—É–∫–∞—î–º–æ –Ω–µ –±—ñ–ª—ñ –ø—ñ–∫—Å–µ–ª—ñ
            if(d[(y*224+x)*4] < 250) { 
                if(x<minX) minX=x; if(x>maxX) maxX=x;
                if(y<minY) minY=y; if(y>maxY) maxY=y;
                found=true;
            }
        }
    }
    
    if(!found) return null; // –ü—É—Å—Ç–æ

    // 2. –í–∏—Ä–∞—Ö–æ–≤—É—î–º–æ —Ä–æ–∑–º—ñ—Ä–∏ –¥–ª—è –∫—Ä–æ–ø—É
    const w = maxX - minX; const h = maxY - minY;
    // –î–æ–¥–∞—î–º–æ —Ç—Ä–æ—Ö–∏ –±—ñ–ª—å—à–µ "–ø–æ–≤—ñ—Ç—Ä—è" (1.4 –∑–∞–º—ñ—Å—Ç—å 1.3), —â–æ–± –∫—Ä–∞—ó –Ω–µ –æ–±—Ä—ñ–∑–∞–ª–∏—Å—å –ø—Ä–∏ —Ä–æ–∑–º–∏—Ç—Ç—ñ
    const size = Math.max(w, h) * 1.3; 
    
    // –û—á–∏—â–∞—î–º–æ –º–∞–ª–µ–Ω—å–∫–∏–π –∫–∞–Ω–≤–∞—Å
    smallCtx.fillStyle = "white"; 
    smallCtx.fillRect(0,0,28,28);
    
    // --- –û–°–¨ –¶–ï–ô –§–Ü–õ–¨–¢–† ---
    // –í–º–∏–∫–∞—î–º–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É —è–∫—ñ—Å—Ç—å –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –±—Ä–∞—É–∑–µ—Ä–∞
    smallCtx.imageSmoothingEnabled = true;
    smallCtx.imageSmoothingQuality = 'high';
    
    // –î–æ–¥–∞—î–º–æ –ª–µ–≥–∫–µ —Ä–æ–∑–º–∏—Ç—Ç—è –ü–ï–†–ï–î –º–∞–ª—é–≤–∞–Ω–Ω—è–º.
    // 0.8px –Ω–∞ –º–∞—Å—à—Ç–∞–±—ñ 28x28 ‚Äî —Ü–µ –¥–æ—Å–∏—Ç—å —Å—É—Ç—Ç—î–≤–æ, –≤–æ–Ω–æ "–ø–æ—Ç–æ–≤—â–∏—Ç—å" –ª—ñ–Ω—ñ—ó.
    smallCtx.filter = 'blur(0.1px) grayscale(100%)'; 
    
    // –ú–∞–ª—é—î–º–æ (–∑–º–µ–Ω—à—É—î–º–æ)
    const scale = 20/size; // –ú–∞—Å—à—Ç–∞–±—É—î–º–æ, —â–æ–± –º–∞–ª—é–Ω–æ–∫ –∑–∞–π–º–∞–≤ ~20 –ø—ñ–∫—Å–µ–ª—ñ–≤
    smallCtx.drawImage(
        bigCv, 
        minX, minY, w, h, 
        14-(w*scale)/2, 14-(h*scale)/2, w*scale, h*scale
    );
    
    // –í–∏–º–∏–∫–∞—î–º–æ —Ñ—ñ–ª—å—Ç—Ä, —â–æ–± –Ω–µ –ø—Å—É–≤–∞—Ç–∏ –º–∞–π–±—É—Ç–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó
    smallCtx.filter = 'none';

    // 3. –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ –≤ –º–∞—Ç—Ä–∏—Ü—é (0..1)
    const sd = smallCtx.getImageData(0,0,28,28).data;
    let mat = [];
    for(let y=0; y<28; y++) {
        let row = [];
        for(let x=0; x<28; x++) {
            // –Ü–Ω–≤–µ—Ä—Ç—É—î–º–æ: 1.0 - —á–æ—Ä–Ω–µ, 0.0 - –±—ñ–ª–µ
            // –î–æ–¥–∞—Ç–∫–æ–≤–æ –º–æ–∂–Ω–∞ –ø—ñ–¥—Å–∏–ª–∏—Ç–∏ –∫–æ–Ω—Ç—Ä–∞—Å—Ç, —è–∫—â–æ —Ä–æ–∑–º–∏—Ç—Ç—è –∑—Ä–æ–±–∏–ª–æ –ª—ñ–Ω—ñ—ó –∑–∞–Ω–∞–¥—Ç–æ –±–ª—ñ–¥–∏–º–∏
            let val = 1.0 - sd[(y*28+x)*4]/255;
            
            // (–û–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ) –ù–µ–≤–µ–ª–∏–∫–∏–π –ø–æ—Ä—ñ–≥, —â–æ–± –ø—Ä–∏–±—Ä–∞—Ç–∏ "–±—Ä—É–¥"
            if(val < 0.05) val = 0; 
            
            row.push(val);
        }
        mat.push(row);
    }
    return mat;
}
/* =========================================
   4. CNN & DEEP NET LOGIC
   ========================================= */
   function drawLatentWeights() {
    if (!state.net || !state.net.w1) return;

    const drawNeuron = (weightsArray, canvasId) => {
        const cvs = document.getElementById(canvasId);
        const ctx = cvs.getContext('2d');
        
        // –†–æ–∑–º—ñ—Ä –ø—ñ—Å–ª—è –ø—É–ª—ñ–Ω–≥—É
        const dim = 13; 
        const area = dim * dim; // 169 –ø—ñ–∫—Å–µ–ª—ñ–≤ –Ω–∞ –æ–¥–Ω–æ–º—É —à–∞—Ä—ñ
        
        // –°—Ç–≤–æ—Ä–∏–º–æ –º–∞—Å–∏–≤ –¥–ª—è –Ω–∞–∫–æ–ø–∏—á–µ–Ω–Ω—è —è—Å–∫—Ä–∞–≤–æ—Å—Ç—ñ (Heatmap)
        let heatmap = new Array(area).fill(0);
        
        // weightsArray –º–∞—î –¥–æ–≤–∂–∏–Ω—É 1352 (8 * 169)
        // –°—Ç—Ä—É–∫—Ç—É—Ä–∞: [Map0 (0..168), Map1 (169..337), ...]
        
        for (let i = 0; i < weightsArray.length; i++) {
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ, –¥–µ —Ü–µ–π –≤–∞–≥–∞ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –Ω–∞ –∫–∞—Ä—Ç–∏–Ω—Ü—ñ 13x13
            // –û–ø–µ—Ä–∞—Ç–æ—Ä % (–º–æ–¥—É–ª—å) –Ω–∞–∫–ª–∞–¥–∞—î –≤—Å—ñ —à–∞—Ä–∏ –æ–¥–∏–Ω –Ω–∞ –æ–¥–Ω–æ–≥–æ
            const spatialIndex = i % area; 
            
            // –î–æ–¥–∞—î–º–æ –≤–∞–≥—É. 
            // –ü–æ–∑–∏—Ç–∏–≤–Ω–∞ –≤–∞–≥–∞ = –Ω–µ–π—Ä–æ–Ω —Ö–æ—á–µ –±–∞—á–∏—Ç–∏ —Ç—É—Ç –∞–∫—Ç–∏–≤–∞—Ü—ñ—é.
            // –ù–µ–≥–∞—Ç–∏–≤–Ω–∞ = –Ω–µ–π—Ä–æ–Ω —Ö–æ—á–µ, —â–æ–± —Ç—É—Ç –±—É–ª–æ –ø—É—Å—Ç–æ.
            heatmap[spatialIndex] += weightsArray[i];
        }

        // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è
        let maxVal = 0;
        heatmap.forEach(v => { if(Math.abs(v) > maxVal) maxVal = Math.abs(v); });
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –∫–∞—Ä—Ç–∏–Ω–∫—É
        const img = ctx.createImageData(dim, dim);
        
        for (let i = 0; i < area; i++) {
            const val = heatmap[i];
            // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –≤—ñ–¥ -1 –¥–æ 1
            const norm = maxVal > 0 ? val / maxVal : 0; 
            
            let r = 0, g = 0, b = 0;
            
            // –ß–µ—Ä–≤–æ–Ω–∏–π = –ó–±—É–¥–∂–µ–Ω–Ω—è (+), –°–∏–Ω—ñ–π = –ì–∞–ª—å–º—É–≤–∞–Ω–Ω—è (-)
            if (norm > 0) {
                r = Math.floor(norm * 255);
            } else {
                b = Math.floor(Math.abs(norm) * 255);
            }
            
            // –ó–∞–ø–æ–≤–Ω—é—î–º–æ –ø—ñ–∫—Å–µ–ª—ñ
            const idx = i * 4;
            img.data[idx] = r;
            img.data[idx+1] = g;
            img.data[idx+2] = b;
            img.data[idx+3] = 255;
        }

        // –ú–∞–ª—é—î–º–æ: —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞ –º–∞–ª–µ–Ω—å–∫–∏–π canvas —É –ø–∞–º'—è—Ç—ñ
        const tmp = document.createElement('canvas');
        tmp.width = dim; tmp.height = dim;
        tmp.getContext('2d').putImageData(img, 0, 0);

        // –ü–æ—Ç—ñ–º —Ä–æ–∑—Ç—è–≥—É—î–º–æ –Ω–∞ –≤–µ–ª–∏–∫–∏–π –µ–∫—Ä–∞–Ω–Ω–∏–π canvas
        ctx.clearRect(0,0,cvs.width, cvs.height);
        ctx.imageSmoothingEnabled = false; // –©–æ–± –±—É–ª–∏ —á—ñ—Ç–∫—ñ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–∏
        ctx.drawImage(tmp, 0, 0, cvs.width, cvs.height);
    };

    drawNeuron(state.net.w1[0], 'latentW1');
    drawNeuron(state.net.w1[1], 'latentW2');
}
   

   
   //////////
/* =========================================
   UPDATED ACTIVATION FUNCTIONS (With Derivatives)
   y = f(x). d(y) is derivative regarding output y
   ========================================= */
const ACTS = {
    'tanh': { 
        f: x => Math.tanh(x), 
        d: y => 1 - y * y 
    },
    'relu': { 
        f: x => x > 0 ? x : 0, 
        d: y => y > 0 ? 1 : 0 
    },
    'sigmoid': { 
        f: x => 1 / (1 + Math.exp(-x)), 
        d: y => y * (1 - y) 
    },
    'linear': { 
        f: x => x, 
        d: y => 1 
    }
};

class DeepNet {
    constructor() {
        // --- –ú–ê–¢–ï–ú–ê–¢–ò–ö–ê –†–û–ó–ú–Ü–†–Ü–í ---
        // 1. Input Image: 28x28
        // 2. Conv2D (kernel 3x3, no padding): 26x26
        // 3. MaxPool (2x2): 13x13
        this.dim = 13; 
        
        // –í—Å—å–æ–≥–æ –≤—Ö–æ–¥—ñ–≤ —É Dense —à–∞—Ä: 13 * 13 –ø—ñ–∫—Å–µ–ª—ñ–≤ * 8 —Ñ—ñ–ª—å—Ç—Ä—ñ–≤
        this.inputSize = this.dim * this.dim * 8; // = 1352
        
        this.hiddenSize = 2; // Bottleneck (Latent X, Y)
        this.outputSize = 3; // Classes (Cat, Fish, Snow)
        
        this.learningRate = 0.01; // –®–≤–∏–¥–∫—ñ—Å—Ç—å –Ω–∞–≤—á–∞–Ω–Ω—è –¥–ª—è SGD
        
        this.resetWeights();
    }
    
    resetWeights() {
        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è He (–¥–ª—è ReLU/Linear) –∞–±–æ Xavier (–¥–ª—è Sigmoid/Tanh)
        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–ø—Ä–æ—â–µ–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç Xavier
        const scale1 = Math.sqrt(2 / this.inputSize);
        const scale2 = Math.sqrt(2 / this.hiddenSize);
        
        const rand = (s) => (Math.random() - 0.5) * 2 * s;
        
        this.w1 = Array(this.hiddenSize).fill(0).map(() => Array(this.inputSize).fill(0).map(() => rand(scale1)));
        this.b1 = Array(this.hiddenSize).fill(0); 
        
        this.w2 = Array(this.outputSize).fill(0).map(() => Array(this.hiddenSize).fill(0).map(() => rand(scale2)));
        this.b2 = Array(this.outputSize).fill(0);
    }

    // –ü—Ä—è–º–µ –ø–æ—à–∏—Ä–µ–Ω–Ω—è (Forward Pass)
    forward(inputMat) {
        // 1. CNN Layers (Fixed)
        this.maps = [];
        for(let k=0; k<8; k++) this.maps.push(convolve(inputMat, K_VALS[k]));
        
        this.pooled = this.maps.map(m => maxPool(m));
        
        // Flatten: —Ä–æ–∑–≥–æ—Ä—Ç–∞—î–º–æ –∫–∞—Ä—Ç–∏ –æ–∑–Ω–∞–∫ —É –¥–æ–≤–≥–∏–π –≤–µ–∫—Ç–æ—Ä
        const flat = this.pooled.flat(2); 

        // 2. Hidden Layer (Latent)
        const act = ACTS[state.actName];
        // z1 = W1 * x + b1
        // h = act(z1)
        const z1 = []; 
        const h = [];
        
        for(let i=0; i<this.hiddenSize; i++) {
            let s = this.b1[i];
            for(let j=0; j<flat.length; j++) s += flat[j] * this.w1[i][j];
            z1.push(s);
            h.push(act.f(s));
        }

        // 3. Output Layer (Logits -> Softmax)
        // z2 = W2 * h + b2
        const z2 = [];
        for(let i=0; i<this.outputSize; i++) {
            let s = this.b2[i];
            for(let j=0; j<this.hiddenSize; j++) s += h[j] * this.w2[i][j];
            z2.push(s);
        }

        // Softmax
        const maxLogit = Math.max(...z2);
        const exps = z2.map(v => Math.exp(v - maxLogit));
        const sum = exps.reduce((a,b)=>a+b,0);
        const p = exps.map(v=>v/sum);
        
        // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç + –∫–µ—à –¥–ª—è backprop
        return { p, h, flatInput: flat };
    }
    
    // –û–¥–∏–Ω –∫—Ä–æ–∫ –Ω–∞–≤—á–∞–Ω–Ω—è (SGD + Backpropagation)
    trainStep(samples) {
        if(samples.length === 0) return;
        
        const actFunc = ACTS[state.actName];

        // –ü–µ—Ä–µ–º—ñ—à—É—î–º–æ –¥–∞–Ω—ñ (Shuffle) –¥–ª—è –∫—Ä–∞—â–æ–≥–æ SGD
        const shuffled = [...samples].sort(() => Math.random() - 0.5);

        shuffled.forEach(sample => {
            // 1. Forward pass –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑—Ä–∞–∑–∫–∞
            const { p, h, flatInput } = this.forward(sample.inputMat);
            const y_true = sample.label;

            // --- BACKPROPAGATION START ---

            // A. –ì—Ä–∞–¥—ñ—î–Ω—Ç –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ —à–∞—Ä—É (Output Gradient)
            // dL/dz2 = p - y (–¥–ª—è Softmax + CrossEntropy)
            const dz2 = [...p];
            dz2[y_true] -= 1; // –í—ñ–¥–Ω—ñ–º–∞—î–º–æ 1 –≤—ñ–¥ —ñ—Å—Ç–∏–Ω–Ω–æ–≥–æ –∫–ª–∞—Å—É

            // B. –ì—Ä–∞–¥—ñ—î–Ω—Ç–∏ –¥–ª—è W2 —Ç–∞ b2
            // dL/dW2 = dz2 * h^T
            const dW2 = [];
            const db2 = [...dz2]; // dL/db2 = dz2

            for(let i=0; i<this.outputSize; i++) {
                dW2[i] = [];
                for(let j=0; j<this.hiddenSize; j++) {
                    dW2[i][j] = dz2[i] * h[j];
                }
            }

            // C. –ü–æ—à–∏—Ä–µ–Ω–Ω—è –ø–æ–º–∏–ª–∫–∏ –Ω–∞ –ø—Ä–∏—Ö–æ–≤–∞–Ω–∏–π —à–∞—Ä (Backprop to Hidden)
            // dL/dh = W2^T * dz2
            const dh = new Array(this.hiddenSize).fill(0);
            for(let j=0; j<this.hiddenSize; j++) {
                for(let i=0; i<this.outputSize; i++) {
                    dh[j] += this.w2[i][j] * dz2[i];
                }
            }

            // D. –ì—Ä–∞–¥—ñ—î–Ω—Ç —á–µ—Ä–µ–∑ —Ñ—É–Ω–∫—Ü—ñ—é –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó
            // dL/dz1 = dL/dh * activation_derivative(h)
            const dz1 = dh.map((val, idx) => val * actFunc.d(h[idx]));

            // E. –ì—Ä–∞–¥—ñ—î–Ω—Ç–∏ –¥–ª—è W1 —Ç–∞ b1
            // dL/dW1 = dz1 * x^T
            const db1 = [...dz1]; // dL/db1 = dz1
            
            // –û–Ω–æ–≤–ª—é—î–º–æ –≤–∞–≥–∏ W1 "–Ω–∞ –ª—å–æ—Ç—É" (SGD update rule)
            // W = W - learning_rate * grad
            // –¢—É—Ç –º–∏ –æ–¥—Ä–∞–∑—É –æ–Ω–æ–≤–ª—é—î–º–æ, –Ω–µ –∑–±–µ—Ä—ñ–≥–∞—é—á–∏ dW1 —É –≤–µ–ª–∏—á–µ–∑–Ω—É –º–∞—Ç—Ä–∏—Ü—é –¥–ª—è –µ–∫–æ–Ω–æ–º—ñ—ó –ø–∞–º'—è—Ç—ñ
            for(let i=0; i<this.hiddenSize; i++) {
                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è bias
                this.b1[i] -= this.learningRate * db1[i];
                
                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è weights
                const gradScale = this.learningRate * dz1[i];
                for(let j=0; j<this.inputSize; j++) {
                    // flatInput[j] –º–æ–∂–µ –±—É—Ç–∏ 0, —Ç–æ–¥—ñ –≤–∞–≥–∞ –Ω–µ –∑–º—ñ–Ω–∏—Ç—å—Å—è (sparsity)
                    if(flatInput[j] !== 0) {
                        this.w1[i][j] -= gradScale * flatInput[j];
                    }
                }
            }

            // –û–Ω–æ–≤–ª–µ–Ω–Ω—è W2 —Ç–∞ b2
            for(let i=0; i<this.outputSize; i++) {
                this.b2[i] -= this.learningRate * db2[i];
                for(let j=0; j<this.hiddenSize; j++) {
                    this.w2[i][j] -= this.learningRate * dW2[i][j];
                }
            }
        });
    }
}

// Math Helpers
function convolve(mat, k) {
    let out = [];
    for(let y=0; y<26; y++) {
        let row=[];
        for(let x=0; x<26; x++) {
            let sum=0;
            for(let ky=0; ky<3; ky++) for(let kx=0; kx<3; kx++)
                sum += mat[y+ky][x+kx] * k[ky][kx];
            row.push(sum > 0 ? sum : 0); // ReLU inside conv
        }
        out.push(row);
    }
    return out;
}
function maxPool(mat) {
    let out=[];
    for(let y=0; y<26; y+=2) {
        let row=[];
        for(let x=0; x<26; x+=2) {
            let m=0;
            if(mat[y][x]>m) m=mat[y][x];
            if(mat[y][x+1]>m) m=mat[y][x+1];
            if(mat[y+1][x]>m) m=mat[y+1][x];
            if(mat[y+1][x+1]>m) m=mat[y+1][x+1];
            row.push(m);
        }
        out.push(row);
    }
    return out;
}

state.net = new DeepNet();

/* =========================================
   5. VISUALIZATION & SCANNER
   ========================================= */

// Init Filters Grid
const fGrid = document.getElementById('filtersList');
K_NAMES.forEach((name, i) => {
    let html = `
    <div class="filter-row" id="frow_${i}">
        <div class="kernel-box" id="kbox_${i}">
            ${K_VALS[i].flat().map(v=>`<div class="k-cell" style="background:${v>0?'#333':(v<0?'#fff':'#ccc')}; color:${v>0?'#fff':'#000'}"></div>`).join('')}
        </div>
        <div class="arrow">‚Üí</div>
        <canvas class="fmap-canvas" id="fmap_${i}" width="28" height="28"></canvas>
    </div>`;
    fGrid.innerHTML += html;
});

// Draw feature map
function drawMap(mat, cvsId) {
    const ctx = document.getElementById(cvsId).getContext('2d');
    const img = ctx.createImageData(28, 28); // Draw 26x26 on 28x28 canvas
    for(let i=0; i<img.data.length; i++) img.data[i]=0; // clear
    
    for(let y=0; y<26; y++) {
        for(let x=0; x<26; x++) {
            const val = Math.min(255, mat[y][x]*100);
            const idx = ((y+1)*28 + (x+1))*4; // Offset by 1 for visuals
            img.data[idx] = val; // R
            img.data[idx+1] = val; // G
            img.data[idx+2] = val; // B
            img.data[idx+3] = 255;
        }
    }
    ctx.putImageData(img, 0, 0);
}

// VISUAL SCANNER ANIMATION
async function runVisualScan() {
    if(state.scanning) return;
    const mat = getProcessedImage();
    if(!mat) { alert("–ù–∞–º–∞–ª—é–π—Ç–µ —â–æ—Å—å —Å–ø–æ—á–∞—Ç–∫—É!"); return; }
    state.scanning = true;

    const scanner = document.getElementById('scanner');
    scanner.style.display = 'block';

    // Pick a filter to visualize (e.g., Vertical lines)
    // We will scan with Filter #1 (Vert) as example
    const filterIdx = 1; 
    const k = K_VALS[filterIdx];
    
    // Highlight UI row
    document.getElementById(`frow_${filterIdx}`).style.background = "#dbeafe";

    // Scan Loop (Steps of 3 for speed)
    for(let y=0; y<26; y+=2) {
        for(let x=0; x<26; x+=2) {
            // Move Box (3px per pixel on 28x28 canvas which is scaled to 84x84 css)
            // CSS pixels = 84px width. 28 internal pixels. 1px = 3css px.
            scanner.style.top = (y*3) + 'px';
            scanner.style.left = (x*3) + 'px';
            
            // Check match
            let sum=0;
            for(let ky=0; ky<3; ky++) for(let kx=0; kx<3; kx++) 
                sum += mat[y+ky][x+kx] * k[ky][kx];
            
            if(sum > 1.0) {
                scanner.classList.add('scan-active'); // Flash Green
                // Draw point on the feature map instantaneously
                const fmCtx = document.getElementById(`fmap_${filterIdx}`).getContext('2d');
                fmCtx.fillStyle = `rgba(255,255,255,${Math.min(1, sum*0.5)})`;
                fmCtx.fillRect(x+1, y+1, 2, 2);
            } else {
                scanner.classList.remove('scan-active');
            }
            
            await new Promise(r => setTimeout(r, 60)); // Speed
        }
    }
    
    scanner.style.display = 'none';
    document.getElementById(`frow_${filterIdx}`).style.background = "#f8fafc";
    state.scanning = false;
    predictAndViz(); // Show full results
}


/* =========================================
   6. LATENT SPACE PLOT (PLOTLY)
   ========================================= */
function updatePlot(currH) {
    let data = [];
    
    // 1. Background (Training Data)
    const colors = ['#f59e0b', '#ef4444', '#3b82f6']; // Cat, Fish, snow
    const names = ['Cat', 'Fish', 'Snow'];
    
    for(let c=0; c<3; c++) {
        const ptrs = state.samples.filter(s=>s.label===c).map(s => {
            // Re-run forward to get current latent coords (weights might have changed)
            return state.net.forward(s.inputMat).h;
        });
        
        if(ptrs.length>0) {
            data.push({
                x: ptrs.map(p=>p[0]), y: ptrs.map(p=>p[1]),
                mode: 'markers', type: 'scatter', name: names[c],
                marker: { color: colors[c], size: 8 }
            });
        }
    }
    
    // 2. Current Point (Cross)
    if(currH) {
        data.push({
            x: [currH[0]], y: [currH[1]],
            mode: 'markers', type: 'scatter', name: 'YOU',
            marker: { color: 'black', symbol: 'cross', size: 15, line:{width:3} }
        });
    }

    // Dynamic Range
    let layout = {
        margin: {t:10, l:30, r:10, b:30},
        xaxis: {title: 'Neuron 1'}, yaxis: {title: 'Neuron 2'},
        showlegend: false, hovermode: false
    };

    Plotly.react('latentPlot', data, layout);
}

function updateActivation() {
    state.actName = document.getElementById('actFunc').value;
    predictAndViz();
}

/* =========================================
   7. MAIN LOOP & TRAINING
   ========================================= */

function predictAndViz() {
    const mat = getProcessedImage();
    if(!mat) return;
    
    const res = state.net.forward(mat);
    
    // Update Feature Maps UI
    state.net.maps.forEach((m, i) => drawMap(m, `fmap_${i}`));
    
    // Update Latent Plot
    updatePlot(res.h);
    
    // Update Output Bars
    const lbls = ["üê± –ö—ñ—Ç", "üê† –†–∏–±–∞", "‚ùÖ —Å–Ω—ñ–∂–∏–Ω–∫–∞"];
    let maxI=0;
    res.p.forEach((v,i) => {
        document.getElementById(`b${i}`).style.width = (v*100)+'%';
        document.getElementById(`p${i}`).innerText = Math.round(v*100)+'%';
        if(v > res.p[maxI]) maxI=i;
    });
    
    document.getElementById('finalRes').innerText = res.p[maxI]>0.55 ? "–∑–¥–∞—î—Ç—å—Å—è, —Ü–µ " + lbls[maxI] : "–ù–µ –∑–Ω–∞—é...";
}

// Data Collection
function addSample(label) {
    const mat = getProcessedImage();
    if(!mat) { alert("–ù–∞–º–∞–ª—é–π—Ç–µ —â–æ—Å—å!"); return; }
    state.samples.push({ inputMat: mat, label: label });
    document.getElementById('trainStats').innerText = `–î–∞–Ω–∏—Ö: ${state.samples.length}`;
    document.getElementById('btnTrain').disabled = false;
    clearSystem();
}


// –ê–≤—Ç–æ-–∑–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑ –ø–æ–∫—Ä–∞—â–µ–Ω–æ—é —Ä–∞–Ω–¥–æ–º—ñ–∑–∞—Ü—ñ—î—é
async function startAutoCollect() {
    const btn = document.querySelector('button[onclick="startAutoCollect()"]');
    if(btn) btn.disabled = true;
    
    // –§—É–Ω–∫—Ü—ñ—è –≤–∏–ø–∞–¥–∫–æ–≤–æ–≥–æ —á–∏—Å–ª–∞ –≤ –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ +/- val
    const jit = (val) => (Math.random() - 0.5) * val; 

    const draw = (type) => {
        // –û—á–∏—â–µ–Ω–Ω—è
        bigCtx.fillStyle = 'white'; 
        bigCtx.fillRect(0, 0, 224, 224);
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç—ñ–≤
        bigCtx.save();

        // 1. –í–∏–ø–∞–¥–∫–æ–≤–∞ —Ç–æ–≤—â–∏–Ω–∞ –ª—ñ–Ω—ñ–π
        bigCtx.lineWidth = 10 + Math.random() * 6; 
        bigCtx.lineCap = 'round';
        bigCtx.lineJoin = 'round';
        bigCtx.strokeStyle = 'black';

        // 2. –í–∏–ø–∞–¥–∫–æ–≤–∏–π —Ü–µ–Ω—Ç—Ä —ñ –ø–æ–≤–æ—Ä–æ—Ç –≤—Å—å–æ–≥–æ –º–∞–ª—é–Ω–∫–∞
        const cx = 112 + jit(50); // –ó—Å—É–≤ —Ü–µ–Ω—Ç—Ä—É +/- 25px
        const cy = 112 + jit(50);
        const rot = jit(0.3); // –ü–æ–≤–æ—Ä–æ—Ç +/- 15 –≥—Ä–∞–¥—É—Å—ñ–≤ (—É —Ä–∞–¥—ñ–∞–Ω–∞—Ö)

        bigCtx.translate(cx, cy);
        bigCtx.rotate(rot);
        bigCtx.translate(-cx, -cy);

        bigCtx.beginPath();

        // --- –ú–ê–õ–Æ–í–ê–ù–ù–Ø –ö–û–¢–ê üê± ---
        if (type === 0) { 
            const r = 75 + jit(3); // –†–∞–¥—ñ—É—Å –≥–æ–ª–æ–≤–∏

            // –ì–æ–ª–æ–≤–∞ (–∫–æ–ª–æ –∑ –ø–æ—Ö–∏–±–∫–æ—é)
            bigCtx.beginPath();
            bigCtx.ellipse(cx, cy, r, r + jit(5), jit(1), 0, Math.PI * 2);
            bigCtx.stroke();

            // –í—É—Ö–∞ (—à–∏—Ä–æ–∫—ñ —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫–∏)
            const earH = 10 + Math.random() * 10;
            const earW = 50 + Math.random() * 15;
            
            // –õ—ñ–≤–µ
            bigCtx.beginPath();
            bigCtx.moveTo(cx - r*0.8, cy - r*0.4);
            bigCtx.lineTo(cx - r*0.6 - jit(10), cy - r - earH);
            bigCtx.lineTo(cx - r*0.2, cy - r*0.85);
            bigCtx.stroke();

            // –ü—Ä–∞–≤–µ
            bigCtx.beginPath();
            bigCtx.moveTo(cx + r*0.8, cy - r*0.4);
            bigCtx.lineTo(cx + r*0.6 + jit(10), cy - r - earH);
            bigCtx.lineTo(cx + r*0.2, cy - r*0.85);
            bigCtx.stroke();

            // –û—á—ñ (–¢–æ—á–∫–∏)
            const eyeOff = 25 + Math.random() * 10;
            bigCtx.lineWidth = 18; // –ñ–∏—Ä–Ω—ñ —Ç–æ—á–∫–∏
            bigCtx.beginPath();
            bigCtx.moveTo(cx - eyeOff, cy - 15 + jit(5)); 
            bigCtx.lineTo(cx - eyeOff, cy - 15 + jit(5));
            bigCtx.stroke();
            
            bigCtx.beginPath();
            bigCtx.moveTo(cx + eyeOff, cy - 15 + jit(5)); 
            bigCtx.lineTo(cx + eyeOff, cy - 15 + jit(5));
            bigCtx.stroke();
            bigCtx.lineWidth = 10 + Math.random() * 6; // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ç–æ–≤—â–∏–Ω—É

            // –ù—ñ—Å —ñ —Ä–æ—Ç (–ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç–∞ –¢)
            bigCtx.beginPath();
            const noseY = cy + 15 + jit(5);
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ –ø–∞–ª–∏—á–∫–∞
            bigCtx.moveTo(cx, noseY); 
            bigCtx.lineTo(cx, noseY + 25);
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –≤–Ω–∏–∑—É
            bigCtx.moveTo(cx - 15, noseY + 25); 
            bigCtx.lineTo(cx + 15, noseY + 25);
            bigCtx.stroke();
        } 
        
        // --- –ú–ê–õ–Æ–í–ê–ù–ù–Ø –†–ò–ë–ò üê† ---
        else if (type === 1) { 
            // –†–∏–±–∞ –∑–∞–≤–∂–¥–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ, –∞–ª–µ —Ç—Ä–æ—Ö–∏ –ø—ñ–¥ –∫—É—Ç–æ–º
            const len = 150 + jit(10);
            const headW = 50 + Math.random() * 30;
            const startX = cx - len/2;
            
            // –ì–æ–ª–æ–≤–∞ (–¢—Ä–∏–∫—É—Ç–Ω–∏–∫, –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ —Å—Ç–æ—Ä–æ–Ω–∞ –∑–ª—ñ–≤–∞)
            bigCtx.beginPath();
            bigCtx.moveTo(startX, cy - headW/2);          // –í–µ—Ä—Ö–Ω—ñ–π –∫—É—Ç
            bigCtx.lineTo(startX, cy + headW/2);          // –ù–∏–∂–Ω—ñ–π –∫—É—Ç
            bigCtx.lineTo(startX - headW, cy);            // –ù—ñ—Å (—Ü–µ–Ω—Ç—Ä)
            bigCtx.closePath();
            bigCtx.stroke();

            // –•—Ä–µ–±–µ—Ç (–≤—ñ–¥ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ—ó —Å—Ç–æ—Ä–æ–Ω–∏ –≤–ø—Ä–∞–≤–æ)
            bigCtx.beginPath();
            bigCtx.moveTo(startX, cy);
            bigCtx.lineTo(startX + len, cy + jit(10));
            bigCtx.stroke();

            // –†–µ–±—Ä–∞ (–í–∏–ø–∞–¥–∫–æ–≤–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å 3..6)
            const numRibs = 4 + Math.floor(Math.random() * 4);
            for(let i=0; i<numRibs; i++) {
                const rx = startX + 20 + (i * (len-40)/numRibs) + jit(5);
                const hRib = 28 + Math.random() * 15;
                
                bigCtx.beginPath();
                bigCtx.moveTo(rx, cy - hRib + jit(5));
                bigCtx.lineTo(rx, cy + hRib + jit(5));
                bigCtx.stroke();
            }

            // –•–≤—ñ—Å—Ç (–ü–æ–≤–µ—Ä–Ω—É—Ç–∞ V, —Ç–æ–±—Ç–æ < )
            const tailX = startX + len;
            const tailSz = 25 + Math.random() * 15;
            bigCtx.beginPath();
            bigCtx.moveTo(tailX + tailSz, cy - tailSz + jit(5));
            bigCtx.lineTo(tailX, cy);
            bigCtx.lineTo(tailX + tailSz, cy + tailSz + jit(5));
            bigCtx.stroke();
        } 
        
        // --- –ú–ê–õ–Æ–í–ê–ù–ù–Ø —Å–Ω—ñ–∂–∏–Ω–∫–∏ ‚ùÖ ---
        else { 
            const r = 1 + Math.random() * 3;
            
            // –ö–æ–ª–æ
            bigCtx.beginPath();
            bigCtx.arc(cx, cy, r, 0, Math.PI * 2);
            bigCtx.stroke();

            // –ü—Ä–æ–º–µ–Ω—ñ (5..10 —à—Ç—É–∫, –Ω–µ –∑–∞—Ö–æ–¥—è—Ç—å –≤—Å–µ—Ä–µ–¥–∏–Ω—É)
            const rays = 5 + Math.floor(Math.random() * 6);
            const gap = 10 + Math.random() * 10; // –í—ñ–¥—Å—Ç—É–ø –≤—ñ–¥ –∫–æ–ª–∞
            
            for(let i=0; i<rays; i++) {
                // –ö—É—Ç –∑ –Ω–µ—Ä—ñ–≤–Ω–æ–º—ñ—Ä–Ω–∏–º –∫—Ä–æ–∫–æ–º
                const angle = (i / rays) * Math.PI * 2 + jit(0.2);
                const rayLen = 40 + Math.random() * 10;
                
                // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø–æ—á–∞—Ç–∫—É (—ñ–∑ –∑–∞–∑–æ—Ä–æ–º)
                const x1 = cx + Math.cos(angle) * (r + gap);
                const y1 = cy + Math.sin(angle) * (r + gap);
                
                // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∫—ñ–Ω—Ü—è
                const x2 = cx + Math.cos(angle) * (r + gap + rayLen);
                const y2 = cy + Math.sin(angle) * (r + gap + rayLen);

                bigCtx.beginPath();
                bigCtx.moveTo(x1, y1);
                bigCtx.lineTo(x2, y2);
                bigCtx.stroke();
            }
        }

        // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç (—â–æ–± –Ω–∞—Å—Ç—É–ø–Ω–∏–π –º–∞–ª—é–Ω–æ–∫ –Ω–µ —É—Å–ø–∞–¥–∫—É–≤–∞–≤ –ø–æ–≤–æ—Ä–æ—Ç)
        bigCtx.restore();
    };

    // –û—Å–Ω–æ–≤–Ω–∏–π —Ü–∏–∫–ª –∑–±–æ—Ä—É
    for(let i=0; i<30; i++) {
        let lbl = i % 3;  
        draw(lbl);
        
        // –ü–∞—É–∑–∞ –¥–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó UI
        await new Promise(r => setTimeout(r, 60));
        
        // –î–æ–¥–∞—î–º–æ –≤ –±–∞–∑—É
        addSample(lbl);
    }
    
    if(btn) btn.disabled = false;
}

/*
// Auto Collect
async function startAutoCollect() {
    const draw = (type) => {
        bigCtx.fillStyle='white'; bigCtx.fillRect(0,0,224,224);
        bigCtx.lineWidth=12; bigCtx.strokeStyle='black';
        const cx=112 + (Math.random()-0.5)*40, cy=112 + (Math.random()-0.5)*40; 
        const r = () => (Math.random()-0.5)*30;
        
        bigCtx.beginPath();
        if(type===0) { // Cat
            bigCtx.arc(cx, cy, 60, 0, 6.28); bigCtx.stroke(); 
            bigCtx.moveTo(cx-40,cy-40); bigCtx.lineTo(cx-60,cy-90); bigCtx.lineTo(cx-10,cy-50); bigCtx.stroke();
            bigCtx.moveTo(cx+40,cy-40); bigCtx.lineTo(cx+60,cy-90); bigCtx.lineTo(cx+10,cy-50); bigCtx.stroke();
        } else if(type===1) { // Fish
            bigCtx.moveTo(cx-60,cy); bigCtx.lineTo(cx+60,cy); bigCtx.stroke();
            for(let i=-1; i<=1; i++) { bigCtx.moveTo(cx+i*30,cy-25); bigCtx.lineTo(cx+i*30,cy+25); bigCtx.stroke(); }
            bigCtx.moveTo(cx+60,cy); bigCtx.lineTo(cx+90,cy-20); bigCtx.lineTo(cx+90,cy+20); bigCtx.lineTo(cx+60,cy); bigCtx.stroke();
        } else { // Sun
            bigCtx.arc(cx+r(), cy+r(), 40, 0, 6.28); bigCtx.stroke();
            for(let i=0; i<6; i++) { let a=i; bigCtx.moveTo(cx,cy); bigCtx.lineTo(cx+Math.cos(a)*80, cy+Math.sin(a)*80); bigCtx.stroke(); }
        }
    };

    for(let i=0; i<30; i++) {
        draw(i%3);
        await new Promise(r=>setTimeout(r, 20));
        addSample(i%3);
    }
}
*/

// Training Loop (Async for UI responsiveness)
async function trainStep() {
    const btn = document.getElementById('btnTrain');
    btn.disabled = true; 
    btn.innerText = "–ù–∞–≤—á–∞–Ω–Ω—è...";
    
    // –°–∫–∏–¥–∞—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –µ–ø–æ—Ö –∞–±–æ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≥–∞–Ω—è—î–º–æ –ø–µ–≤–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ä–∞–∑—ñ–≤
    // –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Å–ø—É—Å–∫ —Å—Ö–æ–¥–∏—Ç—å—Å—è —à–≤–∏–¥—à–µ, —Ç–æ–º—É 100-200 –µ–ø–æ—Ö –∑–∞–∑–≤–∏—á–∞–π –¥–æ—Å—Ç–∞—Ç–Ω—å–æ
    const EPOCHS = 100;

    for(let i=0; i<EPOCHS; i++) {
        state.net.trainStep(state.samples);
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é –∫–æ–∂–Ω—ñ 10 –µ–ø–æ—Ö, —â–æ–± –Ω–µ –≥–∞–ª—å–º—É–≤–∞—Ç–∏ –±—Ä–∞—É–∑–µ—Ä
        if(i % 10 === 0) {
            updatePlot(); // Latent space movement
            drawLatentWeights(); // Visualize what neurons learned
            // –î–∞—î–º–æ –±—Ä–∞—É–∑–µ—Ä—É —á–∞—Å –≤—ñ–¥–º–∞–ª—é–≤–∞—Ç–∏ –∫–∞–¥—Ä
            await new Promise(r => setTimeout(r, 10));
        }
    }
    
    // –§—ñ–Ω–∞–ª—å–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
    updatePlot();
    drawLatentWeights();
    
    btn.disabled = false; 
    btn.innerText = "–î–æ–Ω–∞–≤—á–∏—Ç–∏";
      alert("–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ú–æ–∂–µ—Ç–µ —Ç–µ—Å—Ç—É–≤–∞—Ç–∏. –ù–∞–º–∞–ª—é–π—Ç–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞ —Å–ø—Ä–æ–±—É—î –≤–∏–∑–Ω–∞—á–∏—Ç–∏, —â–æ —Ü–µ");
 
	// alert –¥—Ä–∞—Ç—É—î? –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É –Ω–∞–≤—á–∞–Ω–Ω—ñ, –∫—Ä–∞—â–µ console.log
	
    console.log("Training complete");
}
/*
// Training Loop (Async for UI responsiveness)
async function trainStep() {
    const btn = document.getElementById('btnTrain');
    btn.disabled=true; btn.innerText="–ù–∞–≤—á–∞–Ω–Ω—è...";
    
    for(let i=0; i<400; i++) {//240?
        state.net.trainStep(state.samples);
        if(i%5===0) {
            updatePlot(); // Visualize clustering process
			drawLatentWeights();
            await new Promise(r=>setTimeout(r, 30));
        }
    }
    
    btn.disabled=false; btn.innerText="–î–æ–Ω–∞–≤—á–∏—Ç–∏";
    alert("–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ú–æ–∂–µ—Ç–µ —Ç–µ—Å—Ç—É–≤–∞—Ç–∏. –ù–∞–º–∞–ª—é–π—Ç–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞ —Å–ø—Ä–æ–±—É—î –≤–∏–∑–Ω–∞—á–∏—Ç–∏, —â–æ —Ü–µ");
    updatePlot();
}*/
drawLatentWeights();
</script>
</body>
</html>
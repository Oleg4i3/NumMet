<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Autoencoder</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --primary: #4f46e5; --accent: #ec4899; --bg: #f8fafc; --panel: #ffffff; --text: #1e293b; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { max-width: 900px; width: 100%; display: grid; gap: 15px; }
        
        .panel { background: var(--panel); padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); border: 1px solid #e2e8f0; }
        h2 { margin-top: 0; font-size: 1.2rem; border-bottom: 2px solid #f1f5f9; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        
        .controls-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px; }
        .control-item { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 0.9em; font-weight: 600; color: #64748b; }
        select, input[type=number] { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }
        
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 600; transition: 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:disabled { background: #cbd5e1; cursor: not-allowed; transform: none; }
        button.record { background: #ef4444; }
        button.play-orig { background: #64748b; }
        button.play-vocoder { background: #0ea5e9; }
        button.play-noise { background: #f59e0b; }
        button.play-ai { background: #10b981; box-shadow: 0 0 15px rgba(16, 185, 129, 0.4); }

        .slider-container { display: flex; align-items: center; gap: 10px; }
        input[type=range] { flex-grow: 1; accent-color: var(--primary); }
        
        canvas { width: 100%; height: 100%; }
        .viz-box { height: 150px; background: #0f172a; border-radius: 8px; position: relative; overflow: hidden; margin-top: 10px;}
        
        .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.8em; background: #e2e8f0; color: #475569; }
        .active-badge { background: #dcfce7; color: #166534; }
		
		
		#specIn, #specOut {
        height: 100px !important; 
        width: 100%;
        background: #0f172a;      
        border-radius: 4px;
    }
    </style>
</head>
<body>

<div class="container">
    <h3>–ê–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä<span style="color:var(--accent)"> - –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞ –¥–ª—è –¥–µ–Ω–æ–π–∑—ñ–Ω–≥—É –≥–æ–ª–æ—Å–∞</span></h3>

    <div class="panel">
        <h2>1. –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ù–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ —Ç–∞ –î–∞–Ω–∏—Ö</h2>
        <div class="controls-grid">
            <div class="control-item">
                <label>LPC Order (Input Size)</label>
                <select id="lpcOrder">
                    <option value="10" selected>10 (–°—Ç–∞–Ω–¥–∞—Ä—Ç)</option>
                    <option value="16">16 (–í–∏—Å–æ–∫–∞ —Ç–æ—á–Ω—ñ—Å—Ç—å)</option>
                    <option value="8">8 (–ù–∏–∑—å–∫–∞ —Ç–æ—á–Ω—ñ—Å—Ç—å)</option>
                </select>
            </div>
            <div class="control-item">
                <label>Latent Dimension (Bottleneck)</label>
                <input type="number" id="latentDim" value="2" min="1" max="8">
                <small style="color:#64748b">–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö</small>
            </div>
            <div class="control-item">
                <label>Activation Function</label>
                <select id="activationFunc">
                    <option value="tanh" selected>Tanh (Recommended)</option>
                    <option value="sigmoid">Sigmoid</option>
                    <option value="relu">ReLU (Experimental)</option>
                </select>
            </div>
            <div class="control-item" style="justify-content: flex-end;">
                <button onclick="resetAll()">üîÑ –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ / –°–∫–∏–Ω—É—Ç–∏</button>
            </div>
        </div>
    </div>

    <div class="panel">
        <h2>2. –ó–∞–ø–∏—Å –≥–æ–ª–æ—Å—É <span id="recStatus" class="status-badge">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è</span></h2>
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <button onclick="startRecording()" class="record">üé§ –ó–∞–ø–∏—Å–∞—Ç–∏ —Ñ—Ä–∞–∑—É</button>
            <button onclick="playBuffer(rawBuffer)" id="btnPlayRaw" class="play-orig" disabled>üîà –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
        </div>
        <div style="height: 60px; background: #f1f5f9; border-radius: 6px;">
            <canvas id="waveCanvas"></canvas>
        </div>
    </div>

    <div class="panel" id="trainPanel" style="opacity:0.6; pointer-events:none;">
        <h2>3. –ù–∞–≤—á–∞–Ω–Ω—è (Autoencoder) <span id="trainStatus" class="status-badge">–ù–µ –Ω–∞–≤—á–µ–Ω–æ</span></h2>
        <div class="viz-box">
            <canvas id="nnCanvas"></canvas>
            <div style="position:absolute; top:10px; right:10px; color:#4ade80; font-family:monospace;">Loss: <span id="lossDisp">-</span></div>
        </div>
        <div style="margin-top:10px;">
            <button onclick="startTraining()" id="btnTrain">üß† –¢—Ä–µ–Ω—É–≤–∞—Ç–∏ –º–µ—Ä–µ–∂—É</button>
        </div>
    </div>

    <div class="panel" id="inferPanel" style="opacity:0.6; pointer-events:none;">
        <h2>4. –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Ç–∞ –°–∏–Ω—Ç–µ–∑</h2>
        
        <div class="controls-grid">
            <div class="control-item">
                <label>–†—ñ–≤–µ–Ω—å –≤—Ö—ñ–¥–Ω–æ–≥–æ —à—É–º—É: <span id="noiseVal">40%</span></label>
                <div class="slider-container">
                    <span>0%</span>
                    <input type="range" id="noiseSlider" min="0" max="100" value="40" oninput="document.getElementById('noiseVal').innerText=this.value+'%'">
                    <span>100%</span>
                </div>
            </div>
            <div class="control-item">
                <label>–†–æ–±–æ—Ç–∏–∑–æ–≤–∞–Ω—ñ—Å—Ç—å (Pulse vs Noise): <span id="synthVal">80%</span></label>
                <div class="slider-container">
                    <span>–®–µ–ø—ñ—Ç</span>
                    <input type="range" id="synthSlider" min="0" max="100" value="80" oninput="document.getElementById('synthVal').innerText=this.value+'%'">
                    <span>–†–æ–±–æ—Ç</span>
                </div>
            </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top:15px;">
            <button onclick="playMode('original')" class="play-orig">1. –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
            <button onclick="playMode('vocoder')" class="play-vocoder">2. –í–æ–∫–æ–¥–µ—Ä (–ë–µ–∑ –∑–º—ñ–Ω)</button>
            <button onclick="playMode('noisy')" class="play-noise">3. –ó —à—É–º–æ–º (–í—Ö—ñ–¥ –≤ AI)</button>
            <button onclick="playMode('ai')" class="play-ai">4. ‚ú® –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ AI</button>
        </div>
        
        <div style="display:flex; justify-content:space-between; margin-top:10px;">
            <div style="width:48%; text-align:center;">
                <small>–í–µ–∫—Ç–æ—Ä –æ–∑–Ω–∞–∫ (LPC) –í—Ö—ñ–¥</small>
                <canvas id="specIn" height="80" style="background:#e2e8f0; border-radius:4px;"></canvas>
            </div>
            <div style="width:48%; text-align:center;">
                <small>–í–µ–∫—Ç–æ—Ä –æ–∑–Ω–∞–∫ (LPC) –í–∏—Ö—ñ–¥</small>
                <canvas id="specOut" height="80" style="background:#e2e8f0; border-radius:4px;"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 1. –ì–õ–û–ë–ê–õ–¨–ù–Ü –ó–ú–Ü–ù–ù–Ü ---
    let audioCtx;
    let rawBuffer = null;
    let sampleRate = 0;
    
    // Dataset
    let frames = []; 
    const FRAME_SIZE = 512; 
    
    // Neural Net
    let nn = null;
    let isTrained = false;
    let isTraining = false;
    
    // --- 2. –ú–ê–¢–ï–ú–ê–¢–ò–ß–ù–ï –Ø–î–†–û (LPC) ---
    
    function autocorrelate(x, maxLag) {
        let res = new Float32Array(maxLag + 1);
        for(let k=0; k<=maxLag; k++) {
            let s = 0;
            for(let n=0; n<x.length-k; n++) s += x[n]*x[n+k];
            res[k] = s;
        }
        return res;
    }

    // –ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –∞–Ω–∞–ª—ñ–∑—É.
    // –ü–æ–≤–µ—Ä—Ç–∞—î —ñ 'a' (–¥–ª—è —Ñ—ñ–ª—å—Ç—Ä–∞), —ñ 'k' (–¥–ª—è –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ)
    function levinsonDurbin(r, order) {
        let a = new Float32Array(order + 1);
        let k_arr = new Float32Array(order);
        
        a[0] = 1.0;
        let e = r[0];
        
        // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ —Ç–∏—à—ñ/–ø–æ–º–∏–ª–æ–∫
        if (e < 1e-10) e = 1e-10;

        for (let i = 1; i <= order; i++) {
            let acc = 0;
            for (let j = 1; j < i; j++) acc += a[j] * r[i - j];
            
            // –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∞ –≤—ñ–¥–±–∏—Ç—Ç—è (reflection coeff)
            let k = -(r[i] + acc) / e;
            
            // Hard Clamp (–ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ NN!)
            if (k > 0.99) k = 0.99;
            if (k < -0.99) k = -0.99;
            
            k_arr[i-1] = k; // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥–ª—è dataset

            let a_new = new Float32Array(i + 1);
            a_new[0] = 1.0;
            a_new[i] = k;
            
            for (let j = 1; j < i; j++) {
                a_new[j] = a[j] + k * a[i - j];
            }
            
            a = a_new;
            e *= (1 - k * k);
        }
        
        // –ü–∞–¥—ñ–Ω–≥ –º–∞—Å–∏–≤—É a –¥–æ –ø–æ–≤–Ω–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É, —è–∫—â–æ —Ç—Ä–µ–±–∞ (—Ç—É—Ç –¥–∏–Ω–∞–º—ñ—á–Ω–æ)
        // –î–ª—è filterIIR –Ω–∞–º –ø–æ—Ç—Ä—ñ–±–µ–Ω –ø–æ–≤–Ω–∏–π –º–∞—Å–∏–≤ a
        return { a: a, k: k_arr, error: e };
    }

    // –ó–≤–æ—Ä–æ—Ç–Ω–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è k -> a (–¥–ª—è —Å–∏–Ω—Ç–µ–∑—É –ø—ñ—Å–ª—è NN)
    function kToA(k_coeffs) {
        let order = k_coeffs.length;
        let a = new Float32Array(order + 1);
        a[0] = 1.0;
        
        for(let i=1; i<=order; i++) {
            let k = k_coeffs[i-1];
            let a_new = new Float32Array(i + 1);
            a_new[0] = 1.0;
            a_new[i] = k;
            for(let j=1; j<i; j++) {
                a_new[j] = a[j] + k * a[i-j];
            }
            a = a_new;
        }
        return a;
    }

    function filterIIR(x, a, mem) {
        let y = new Float32Array(x.length);
        let ord = a.length - 1;
        if(!mem) mem = new Float32Array(ord).fill(0);

        for(let n=0; n<x.length; n++) {
            let s = x[n];
            for(let k=1; k<=ord; k++) {
                let val = (n >= k) ? y[n-k] : mem[ord-k];
                s -= a[k] * val;
            }
            // –õ—ñ–º—ñ—Ç–µ—Ä, —â–æ–± –Ω–µ –ø–æ—Ä–≤–∞–ª–æ –¥–∏–Ω–∞–º—ñ–∫–∏
            if(s > 4.0) s = 4.0; 
            if(s < -4.0) s = -4.0;
            y[n] = s;
        }
        for(let i=0; i<ord; i++) mem[i] = y[y.length-1-i];
        return y;
    }

    function detectPitch(buffer, sr) {
        let r = autocorrelate(buffer, 150);
        let maxVal = -Infinity;
        let lag = 0;
        for(let k=20; k<r.length-1; k++) {
            if(r[k] > maxVal && r[k] > r[k-1] && r[k] > r[k+1]) {
                maxVal = r[k];
                lag = k;
            }
        }
        if(maxVal > r[0] * 0.25) return sr / lag;
        return 0; 
    }

    // --- 3. –ù–ï–ô–†–û–ú–ï–†–ï–ñ–ê (–í–∏–ø—Ä–∞–≤–ª–µ–Ω–∞) ---
    class Autoencoder {
        constructor(inputSize, hiddenSize) {
            this.inputSize = inputSize;
            this.hiddenSize = hiddenSize;
            
            // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Xavier (–≤–∞–∂–ª–∏–≤–∞ –¥–ª—è –∑–±—ñ–∂–Ω–æ—Å—Ç—ñ)
            let lim1 = Math.sqrt(6 / (inputSize + hiddenSize));
            this.W1 = new Float32Array(hiddenSize * inputSize).map(()=>(Math.random()*2-1)*lim1);
            this.b1 = new Float32Array(hiddenSize).fill(0);
            
            let lim2 = Math.sqrt(6 / (hiddenSize + inputSize));
            this.W2 = new Float32Array(inputSize * hiddenSize).map(()=>(Math.random()*2-1)*lim2);
            this.b2 = new Float32Array(inputSize).fill(0);
            
            this.lr = 0.005; // –ú–µ–Ω—à–∏–π learning rate –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ
        }

        // –ê–∫—Ç–∏–≤–∞—Ü—ñ—è tanh (—ñ–¥–µ–∞–ª—å–Ω–æ –¥–ª—è k [-1, 1])
        tanh(x) { return Math.tanh(x); }
        dtanh(y) { return 1 - y*y; }

        forward(input) {
            this.h = new Float32Array(this.hiddenSize);
            // Layer 1
            for(let i=0; i<this.hiddenSize; i++) {
                let s = this.b1[i];
                for(let j=0; j<this.inputSize; j++) s += input[j] * this.W1[i*this.inputSize + j];
                this.h[i] = this.tanh(s);
            }
            
            this.out = new Float32Array(this.inputSize);
            // Layer 2
            for(let i=0; i<this.inputSize; i++) {
                let s = this.b2[i];
                for(let j=0; j<this.hiddenSize; j++) s += this.h[j] * this.W2[i*this.hiddenSize + j];
                this.out[i] = this.tanh(s); // –í–∏—Ö—ñ–¥ —Ç–µ–∂ tanh, –±–æ k [-1, 1]
            }
            return this.out;
        }

        train(input, target) {
            let out = this.forward(input);
            
            // Output Gradients
            let out_grad = new Float32Array(this.inputSize);
            let loss = 0;
            for(let i=0; i<this.inputSize; i++) {
                let err = target[i] - out[i];
                loss += err * err;
                out_grad[i] = err * this.dtanh(out[i]); // –ì—Ä–∞–¥—ñ—î–Ω—Ç MSE * –ø–æ—Ö—ñ–¥–Ω–∞ tanh
            }

            // Hidden Gradients
            let h_grad = new Float32Array(this.hiddenSize);
            for(let i=0; i<this.hiddenSize; i++) {
                let err = 0;
                for(let j=0; j<this.inputSize; j++) err += out_grad[j] * this.W2[j*this.hiddenSize + i];
                h_grad[i] = err * this.dtanh(this.h[i]);
            }

            // Update Weights (SGD)
            for(let i=0; i<this.inputSize; i++) {
                this.b2[i] += this.lr * out_grad[i];
                for(let j=0; j<this.hiddenSize; j++) {
                    this.W2[i*this.hiddenSize + j] += this.lr * out_grad[i] * this.h[j];
                }
            }
            for(let i=0; i<this.hiddenSize; i++) {
                this.b1[i] += this.lr * h_grad[i];
                for(let j=0; j<this.inputSize; j++) {
                    this.W1[i*this.inputSize + j] += this.lr * h_grad[i] * input[j];
                }
            }
            
            return loss;
        }
    }

    // --- 4. –õ–û–ì–Ü–ö–ê –Ü–ù–¢–ï–†–§–ï–ô–°–£ ---

    async function startRecording() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioCtx.sampleRate;
        
        let status = document.getElementById('recStatus');
        status.innerText = "–ó–∞–ø–∏—Å..."; status.className = "status-badge active-badge";
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            let chunks = [];
            
            mediaRecorder.ondataavailable = e => chunks.push(e.data);
            mediaRecorder.onstop = async () => {
                const blob = new Blob(chunks);
                const buf = await blob.arrayBuffer();
                const decoded = await audioCtx.decodeAudioData(buf);
                rawBuffer = decoded.getChannelData(0);
                
                status.innerText = "–ì–æ—Ç–æ–≤–æ"; status.className = "status-badge";
                document.getElementById('btnPlayRaw').disabled = false;
                
                analyzeAudio(); 
                document.getElementById('trainPanel').style.opacity = 1;
                document.getElementById('trainPanel').style.pointerEvents = 'all';
                drawWave(rawBuffer);
            };
            
            mediaRecorder.start();
            setTimeout(() => mediaRecorder.stop(), 2000); 
        } catch(e) { alert("Mic Error: " + e); }
    }

    function analyzeAudio() {
        if(!rawBuffer) return;
        const order = parseInt(document.getElementById('lpcOrder').value);
        frames = [];
        let hopSize = Math.floor(FRAME_SIZE / 2);
        
        for (let i = 0; i < rawBuffer.length - FRAME_SIZE; i += hopSize) {
            let chunk = rawBuffer.slice(i, i + FRAME_SIZE);
            
            // Hamming Window
            let winChunk = new Float32Array(FRAME_SIZE);
            let energy = 0;
            for(let j=0; j<FRAME_SIZE; j++) {
                let v = chunk[j] * (0.54 - 0.46 * Math.cos(2*Math.PI*j/(FRAME_SIZE-1)));
                winChunk[j] = v;
                energy += v*v;
            }
            
            // LPC Analysis
            let r = autocorrelate(winChunk, order);
            let lpcRes = levinsonDurbin(r, order); // –û—Ç—Ä–∏–º—É—î–º–æ {a, k, error}
            
            // Pitch
            let pitch = detectPitch(winChunk, sampleRate);
            
            // Residual Gain (Error Gain)
            // –ï–Ω–µ—Ä–≥—ñ—è –ø–æ–º–∏–ª–∫–∏ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è - —Ü–µ —ñ —î –ø–æ—Ç—Ä—ñ–±–Ω–∞ –≥—É—á–Ω—ñ—Å—Ç—å –∑–±—É–¥–∂–µ–Ω–Ω—è
            let g = Math.sqrt(lpcRes.error); 

            frames.push({
                k: lpcRes.k,     // –í–µ–∫—Ç–æ—Ä –¥–ª—è NN (Reflection Coeffs)
                gain: g,         // –ì—É—á–Ω—ñ—Å—Ç—å
                pitch: pitch     // –¢–æ–Ω
            });
        }
        drawNN();
    }

function startTraining() {
        const order = parseInt(document.getElementById('lpcOrder').value);
        const latent = parseInt(document.getElementById('latentDim').value);
        
        // --- –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –õ–û–ì–Ü–ö–ò ---
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ: —á–∏ —ñ—Å–Ω—É—î –º–µ—Ä–µ–∂–∞? –ß–∏ –∑–º—ñ–Ω–∏–ª–∏—Å—è –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ?
        // –Ø–∫—â–æ –º–µ—Ä–µ–∂–∞ —î —ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ç—ñ —Å–∞–º—ñ -> –ù–ï —Å—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤—É, –≤—á–∏–º–æ —Å—Ç–∞—Ä—É.
        if (!nn || nn.inputSize !== order || nn.hiddenSize !== latent) {
            nn = new Autoencoder(order, latent);
            console.log("–°—Ç–≤–æ—Ä–µ–Ω–æ –Ω–æ–≤—É –º–æ–¥–µ–ª—å");
        } else {
            console.log("–ü—Ä–æ–¥–æ–≤–∂—É—î–º–æ –Ω–∞–≤—á–∞–Ω–Ω—è —ñ—Å–Ω—É—é—á–æ—ó –º–æ–¥–µ–ª—ñ");
        }
        
        let btn = document.getElementById('btnTrain');
        btn.disabled = true; 
        btn.innerText = "–í—á—É—Å—è...";
        isTraining = true;
        
        // –õ—ñ—á–∏–ª—å–Ω–∏–∫ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Ü–∏–∫–ª—É "–¥–æ–≤—á–∞–Ω–Ω—è"
        let epoch = 0;
        const EPOCHS_PER_CLICK = 300; // –°–∫—ñ–ª—å–∫–∏ –µ–ø–æ—Ö –¥–æ–¥–∞—Ç–∏ –ø—Ä–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—ñ
        
        function loop() {
            if(!isTraining) return;
            
            let totalLoss = 0;
            let count = 0;
            
            for(let f of frames) {
                if(f.gain < 0.005) continue; 
                
                let clean = f.k; 
                
                // –®—É–º –¥–æ–¥–∞—î–º–æ –¥–∏–Ω–∞–º—ñ—á–Ω–æ, —â–æ–± –º–µ—Ä–µ–∂–∞ –±–∞—á–∏–ª–∞ –Ω–æ–≤—ñ –ø—Ä–∏–∫–ª–∞–¥–∏
                let noisyInput = new Float32Array(clean.length);
                for(let i=0; i<clean.length; i++) {
                    noisyInput[i] = clean[i] + (Math.random()-0.5) * 0.2; 
                }
                
                totalLoss += nn.train(noisyInput, clean);
                count++;
            }
            
            let avgLoss = count > 0 ? totalLoss / count : 0;
            document.getElementById('lossDisp').innerText = avgLoss.toFixed(5);
            
            if(epoch % 5 === 0) drawNN(true);
            
            epoch++;
            
            // –ö—Ä—É—Ç–∏–º–æ —Ü–∏–∫–ª, –ø–æ–∫–∏ –Ω–µ –ø—Ä–æ–π–¥–µ–º–æ –≤–∏–∑–Ω–∞—á–µ–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ø–æ—Ö
            if(epoch < EPOCHS_PER_CLICK) {
                requestAnimationFrame(loop);
            } else {
                // –§—ñ–Ω—ñ—à —Ü—å–æ–≥–æ –µ—Ç–∞–ø—É
                isTrained = true;
                isTraining = false;
                
                btn.innerText = "–î–æ–≤—á–∏—Ç–∏ (+300 –µ–ø–æ—Ö)"; 
                btn.disabled = false;
                
                document.getElementById('trainStatus').innerText = "–ù–∞–≤—á–µ–Ω–æ";
                document.getElementById('trainStatus').className = "status-badge active-badge";
                document.getElementById('inferPanel').style.opacity = 1;
                document.getElementById('inferPanel').style.pointerEvents = 'all';
                
                // –ü–µ—Ä–µ–º–∞–ª—å–æ–≤—É—î–º–æ –±–µ–∑ –∞–Ω—ñ–º–∞—Ü—ñ—ó (—Å—Ç–∞—Ç–∏—á–Ω—ñ –≤–∞–≥–∏)
                drawNN(false);
            }
        }
        loop();
    } 


 // --- 5. –°–ò–ù–¢–ï–ó (–í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ Logic + Slider) ---

    function playMode(mode) {
        if(!audioCtx) return;
        
        const noiseLvl = parseInt(document.getElementById('noiseSlider').value) / 100;
        const sliderMix = parseInt(document.getElementById('synthSlider').value) / 100; 
        const order = parseInt(document.getElementById('lpcOrder').value);
        
        const hopSize = Math.floor(FRAME_SIZE / 2);
        const totalSamples = frames.length * hopSize + FRAME_SIZE;
        
        const outBuf = audioCtx.createBuffer(1, totalSamples, sampleRate);
        const pcm = outBuf.getChannelData(0);
        
        let filterMem = new Float32Array(order).fill(0);
        let phase = 0;
        const ROBOT_PITCH = 150; // –ì—Ü
        
        let visInput = null, visOutput = null;

        for(let i=0; i<frames.length; i++) {
            let f = frames[i];
            
            // 1. –û—Ç—Ä–∏–º—É—î–º–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ K
            let k = Float32Array.from(f.k); // –ö–æ–ø—ñ—è
            
            // 2. –î–æ–¥–∞—î–º–æ —à—É–º (—è–∫—â–æ —Ç—Ä–µ–±–∞)
            if(mode === 'noisy' || mode === 'ai') {
                for(let j=0; j<k.length; j++) {
                    k[j] += (Math.random()-0.5) * noiseLvl * 2.5; 
                    // Clamping –≤—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö
                    if(k[j]>0.99) k[j]=0.99; if(k[j]<-0.99) k[j]=-0.99;
                }
            }
            visInput = k;
            
            // 3. –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è (Denoising)
            if(mode === 'ai' && isTrained) {
                k = nn.forward(k); 
                // NN –≤–∂–µ –ø–æ–≤–µ—Ä—Ç–∞—î –¥–∞–Ω—ñ –≤ [-1, 1], –∞–ª–µ –¥–ª—è –±–µ–∑–ø–µ–∫–∏ —Ñ—ñ–ª—å—Ç—Ä–∞:
                for(let j=0; j<k.length; j++) {
                     if(k[j]>0.99) k[j]=0.99; if(k[j]<-0.99) k[j]=-0.99;
                }
            }
            visOutput = k;
            
            // 4. –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è K -> A (–§—ñ–ª—å—Ç—Ä)
            let a = kToA(k); // –û—Ç—Ä–∏–º—É—î–º–æ [1, a1, a2...]

            // 5. –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑–±—É–¥–∂–µ–Ω–Ω—è (Excitation)
            let exc = new Float32Array(FRAME_SIZE);
            let gain = f.gain;
            
            // Pitch logic: —è–∫—â–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª –≥–ª—É—Ö–∏–π, –∞–ª–µ —Å–ª–∞–π–¥–µ—Ä "–†–æ–±–æ—Ç", 
            // –≤–º–∏–∫–∞—î–º–æ —à—Ç—É—á–Ω–∏–π —Ç–æ–Ω.
            let hasPitch = f.pitch > 0;
            let currentPitch = hasPitch ? f.pitch : ROBOT_PITCH;
            let period = sampleRate / currentPitch;
            let pulseAmp = Math.sqrt(period); // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –µ–Ω–µ—Ä–≥—ñ—ó —ñ–º–ø—É–ª—å—Å—É

            for(let n=0; n<FRAME_SIZE; n++) {
                // Noise source
                let noiseSamp = (Math.random() * 2 - 1);
                
                // Pulse source
                let pulseSamp = 0;
                phase++;
                if(phase >= period) {
                    phase -= period;
                    pulseSamp = pulseAmp;
                }

                // Mixing logic
                // –Ø–∫—â–æ —Å–ª–∞–π–¥–µ—Ä = 0 (–®–µ–ø—ñ—Ç) -> —Ç—ñ–ª—å–∫–∏ noiseSamp
                // –Ø–∫—â–æ —Å–ª–∞–π–¥–µ—Ä = 1 (–†–æ–±–æ—Ç) -> —Ç—ñ–ª—å–∫–∏ pulseSamp
                let finalExc = 0;
                
                // –Ø–∫—â–æ –≤ –æ—Ä–∏–≥—ñ–Ω–∞–ª—ñ –±—É–≤ —Ç–æ–Ω - –º—ñ–∫—Å—É—î–º–æ –∑–∞ —Å–º–∞–∫–æ–º
                // –Ø–∫—â–æ –≤ –æ—Ä–∏–≥—ñ–Ω–∞–ª—ñ –Ω–µ –±—É–ª–æ —Ç–æ–Ω—É - –≤—Å–µ –æ–¥–Ω–æ –º—ñ–∫—Å—É—î–º–æ –∑–∞ —Å–ª–∞–π–¥–µ—Ä–æ–º, 
                // —â–æ–± —Å—Ç–≤–æ—Ä–∏—Ç–∏ –µ—Ñ–µ–∫—Ç "—Ä–æ–±–æ—Ç–∏–∑–∞—Ü—ñ—ó —à–µ–ø–æ—Ç—É".
                finalExc = (pulseSamp * sliderMix) + (noiseSamp * (1.0 - sliderMix));
                
                exc[n] = finalExc * gain;
            }
            
            if(mode === 'original') {
                playBuffer(rawBuffer, false); return;
            }

            // 6. –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è
            let synth = filterIIR(exc, a, filterMem);
            
            // 7. Overlap-Add
            let startPos = i * hopSize;
            for(let n=0; n<FRAME_SIZE; n++) {
                let w = 0.5 - 0.5 * Math.cos(2*Math.PI*n/(FRAME_SIZE-1));
                if(startPos+n < pcm.length) pcm[startPos+n] += synth[n] * w;
            }
        }
        
        playBuffer(outBuf, true);
        drawSpec(visInput, 'specIn');
        drawSpec(visOutput, 'specOut');
    }

    function playBuffer(buf, isObj) {
        if(!buf) return;
        const src = audioCtx.createBufferSource();
        if(isObj) src.buffer = buf;
        else {
            const b = audioCtx.createBuffer(1, buf.length, sampleRate);
            b.getChannelData(0).set(buf);
            src.buffer = b;
        }
        src.connect(audioCtx.destination);
        src.start();
    }
    
    // --- –ì–†–ê–§–Ü–ö–ê ---
    function drawWave(d) {
        const ctx = document.getElementById('waveCanvas').getContext('2d');
        const w=ctx.canvas.width=ctx.canvas.clientWidth; 
        const h=ctx.canvas.height=ctx.canvas.clientHeight;
        ctx.clearRect(0,0,w,h); ctx.beginPath(); ctx.strokeStyle='#4f46e5';
        let step = Math.ceil(d.length/w);
        for(let i=0;i<w;i++) ctx.lineTo(i, h/2 + d[i*step]*h*0.8);
        ctx.stroke();
    }
    
    function drawSpec(d, id) {
        if(!d) return;
        const ctx = document.getElementById(id).getContext('2d');
        const w=ctx.canvas.width=ctx.canvas.clientWidth; 
        const h=ctx.canvas.height=ctx.canvas.clientHeight;
        ctx.clearRect(0,0,w,h);
        let bw = w/d.length;
        for(let i=0;i<d.length;i++) {
            let val = d[i];
            ctx.fillStyle = val>0?'#10b981':'#f59e0b';
            let bh = Math.abs(val)*h/2;
            ctx.fillRect(i*bw, h/2, bw-1, -bh);
            ctx.fillRect(i*bw, h/2, bw-1, bh);
        }
    }
    
    function drawNN(anim=false) {
        const ctx = document.getElementById('nnCanvas').getContext('2d');
        const w=ctx.canvas.width=ctx.canvas.clientWidth;
        const h=ctx.canvas.height=ctx.canvas.clientHeight;
        ctx.clearRect(0,0,w,h);
        if(!nn) return;

        const layers = [nn.inputSize, nn.hiddenSize, nn.inputSize];
        const layerGap = w / (layers.length + 1);
        let nodes = [];
        
        layers.forEach((count, lIdx) => {
            let x = (lIdx + 1) * layerGap;
            let yGap = h / (count + 1);
            let ln = [];
            for(let i=0; i<count; i++) ln.push({x: x, y: (i+1)*yGap});
            nodes.push(ln);
        });

        // Edges
        // 1. –ú–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—ó (Edges) –∑ –ø—Ä–∏–≤'—è–∑–∫–æ—é –¥–æ –≤–∞–≥
        for(let l=0; l<layers.length-1; l++) {
            let currentNodes = nodes[l];
            let nextNodes = nodes[l+1];
            
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ, –∑ —è–∫–∏–º —à–∞—Ä–æ–º –≤–∞–≥ –ø—Ä–∞—Ü—é—î–º–æ
            let weights = (l === 0) ? nn.W1 : nn.W2;
            let inputCount = (l === 0) ? nn.inputSize : nn.hiddenSize;

            for(let i=0; i<currentNodes.length; i++) { // i - —ñ–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —à–∞—Ä—É
                for(let j=0; j<nextNodes.length; j++) { // j - —ñ–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —à–∞—Ä—É
                    
                    let n1 = currentNodes[i];
                    let n2 = nextNodes[j];
                    
                    // –û—Ç—Ä–∏–º—É—î–º–æ –≤–∞–≥—É –∑–≤'—è–∑–∫—É
                    // –ú–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ –ø–ª–æ—Å–∫–∞: [target_node * input_count + source_node]
                    let wVal = 0;
                    if(weights) {
                         wVal = weights[j * inputCount + i];
                    }

                    ctx.beginPath();
                    ctx.moveTo(n1.x, n1.y);
                    ctx.lineTo(n2.x, n2.y);
                    
                    // –õ–æ–≥—ñ–∫–∞ –∫–æ–ª—å–æ—Ä—É:
                    // –ß–∏–º –±—ñ–ª—å—à–∞ –≤–∞–≥–∞ -> —Ç–∏–º —Ç–æ–≤—â–∞/—è—Å–∫—Ä–∞–≤—ñ—à–∞ –ª—ñ–Ω—ñ—è.
                    // anim=true –¥–æ–¥–∞—î "–º–µ—Ä–µ—Ö—Ç—ñ–Ω–Ω—è" –ø—ñ–¥ —á–∞—Å –Ω–∞–≤—á–∞–Ω–Ω—è
                    let opacity = Math.abs(wVal); 
                    if(opacity > 1) opacity = 1; // Limit
                    if(opacity < 0.05) opacity = 0.05; // Minimum visibility
                    
                    if(anim) {
                        // –ï—Ñ–µ–∫—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
                        ctx.strokeStyle = `rgba(236, 72, 153, ${opacity})`; // –†–æ–∂–µ–≤–∏–π
                        ctx.lineWidth = opacity * 2;
                    } else {
                        // –°—Ç–∞—Ç–∏—á–Ω–∏–π —Å—Ç–∞–Ω
                        ctx.strokeStyle = `rgba(129, 140, 248, ${opacity * 0.8})`; // –°–∏–Ω—ñ–π
                        ctx.lineWidth = opacity;
                    }

                    ctx.stroke();
                }
            }
        }
        // Nodes
        layers.forEach((count, lIdx) => {
            for(let n of nodes[lIdx]) {
                ctx.beginPath(); ctx.arc(n.x, n.y, 4, 0, 7);
                ctx.fillStyle = anim?'#ec4899':(lIdx==1?'#f43f5e':'#818cf8');
                ctx.fill();
            }
        });
    }

    function resetAll() { location.reload(); }
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Autoencoder</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	
	<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

	
    <style>
        :root { --primary: #4f46e5; --accent: #ec4899; --bg: #f8fafc; --panel: #ffffff; --text: #1e293b; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { max-width: 900px; width: 100%; display: grid; gap: 15px; }
        
        .panel { background: var(--panel); padding: 10px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); border: 1px solid #e2e8f0; }
        h2 { margin-top: 0; font-size: 1.2rem; border-bottom: 2px solid #f1f5f9; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        
        .controls-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px; }
        .control-item { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 0.9em; font-weight: 600; color: #64748b; }
        select, input[type=number] { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }
        
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 600; transition: 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:disabled { background: #cbd5e1; cursor: not-allowed; transform: none; }
        button.record { background: #ef4444; }
        button.play-orig { background: #64748b; }
        button.play-vocoder { background: #0ea5e9; }
        button.play-noise { background: #f59e0b; }
        button.play-ai { background: #10b981; box-shadow: 0 0 15px rgba(16, 185, 129, 0.4); }

        .slider-container { display: flex; align-items: center; gap: 10px; }
        input[type=range] { flex-grow: 1; accent-color: var(--primary); }
        
        canvas { width: 100%; height: 100%; }
        .viz-box { height: 150px; background: #0f172a; border-radius: 8px; position: relative; overflow: hidden; margin-top: 10px;}
        
        .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.8em; background: #e2e8f0; color: #475569; }
        .active-badge { background: #dcfce7; color: #166534; }
		
		
		#specIn, #specOut {
        height: 100px !important; 
        width: 100%;
        background: #0f172a;      
        border-radius: 4px;
    }
    </style>
</head>
<body>

<div class="container">
    <h3>–ê–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä - –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞ –¥–ª—è –¥–µ–Ω–æ–π–∑—ñ–Ω–≥—É —ñ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –≥–æ–ª–æ—Å–∞</span></h3>

		
<details>
    <summary><strong>üìö –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ –¥–æ–≤—ñ–¥–∫–∞</strong></summary>
    
    <div style="padding: 20px; background: #f9f9f9; border-radius: 10px; margin-top: 10px;">
        
        <h3>1. –ö—Ä–æ–∫–∏ —Ä–æ–±–æ—Ç–∏ —Å–∏–º—É–ª—è—Ç–æ—Ä–∞</h3>
        
        <ol>
            <li><strong>–ó–∞–ø–∏—Å –∞—É–¥—ñ–æ</strong><br>
                –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑–∞–ø–∏—Å—É—î –≥–æ–ª–æ—Å–æ–≤—É —Ñ—Ä–∞–∑—É. –°–∏–≥–Ω–∞–ª –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —è–∫ –æ–¥–Ω–æ–º—ñ—Ä–Ω–∏–π –º–∞—Å–∏–≤ (—á–∞—Å–æ–≤–∏–π —Ä—è–¥) \( x[n] \), –¥–µ \( n \) ‚Äî –¥–∏—Å–∫—Ä–µ—Ç–Ω–∏–π –º–æ–º–µ–Ω—Ç —á–∞—Å—É.
            </li>
            
            <li><strong>–§—Ä–µ–π–º—ñ–Ω–≥ —Ç–∞ –≤—ñ–∫–æ–Ω—É–≤–∞–Ω–Ω—è</strong><br>
                –°–∏–≥–Ω–∞–ª –¥—ñ–ª–∏—Ç—å—Å—è –Ω–∞ —Ñ—Ä–µ–π–º–∏ –¥–æ–≤–∂–∏–Ω–æ—é \( N \) –∑ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è–º. –î–æ –∫–æ–∂–Ω–æ–≥–æ —Ñ—Ä–µ–π–º—É –∑–∞—Å—Ç–æ—Å–æ–≤—É—î—Ç—å—Å—è –≤—ñ–∫–Ω–æ –•–µ–º–º—ñ–Ω–≥–∞ –¥–ª—è –∑–º–µ–Ω—à–µ–Ω–Ω—è —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∏—Ö –≤–∏—Ç–æ–∫—ñ–≤:
                \[
                x_w[n] = x[n] \cdot \left(0.54 - 0.46\cos\left(\frac{2\pi n}{N-1}\right)\right)
                \]
                –¥–µ \( x_w[n] \) ‚Äî –≤—ñ–∫–æ–Ω–æ–≤–∞–Ω–∏–π —Å–∏–≥–Ω–∞–ª.
            </li>
            
            <li><strong>LPC-–∞–Ω–∞–ª—ñ–∑ (Linear Predictive Coding)</strong><br>
				–ù–∞ —Ü—å–æ–º—É –∫—Ä–æ—Ü—ñ –º–∏ —Ä–µ–∞–ª—ñ–∑—É—î–º–æ "—Å–∏–Ω—Ç–µ—Ç–∏—á–Ω–∏–π –≥–æ–ª–æ—Å" - –≤–æ–∫–æ–¥–µ—Ä. –î–µ—Ç–∞–ª—å–Ω–æ –ø—Ä–æ —Ä–æ–±–æ—Ç—É –≤–æ–∫–æ–¥–µ—Ä–∞ –¥–∏–≤–∏—Å—å —É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ "–í–æ–∫–æ–¥–µ—Ä –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ª—ñ–Ω—ñ–π–Ω–æ–≥–æ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è".<br>
                –î–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ñ—Ä–µ–π–º—É –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è –∞–≤—Ç–æ–∫–æ—Ä–µ–ª—è—Ü—ñ—è \( R[k] \):
                \[
                R[k] = \sum_{n=0}^{N-1-k} x_w[n] \cdot x_w[n+k]
                \]
                –ó–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∞–ª–≥–æ—Ä–∏—Ç–º—É –õ–µ–≤—ñ–Ω—Å–æ–Ω–∞-–î–∞—Ä–±—ñ–Ω–∞ –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –≤—ñ–¥–±–∏—Ç—Ç—è (reflection coefficients) \( k_i \), —è–∫—ñ –ª–µ–∂–∞—Ç—å —É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ \([-1, 1]\).
            </li>
            
            <li><strong>–§–æ—Ä–º—É–≤–∞–Ω–Ω—è –¥–∞—Ç–∞—Å–µ—Ç—É</strong><br>
                –í–µ–∫—Ç–æ—Ä \( \mathbf{k} = (k_1, k_2, \dots, k_p) \) –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —è–∫ –≤—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ –¥–ª—è –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä–∞. –î–æ–¥–∞—Ç–∫–æ–≤–æ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è:
                <ul>
                    <li>\( G \) ‚Äî –µ–Ω–µ—Ä–≥—ñ—è –∑–∞–ª–∏—à–∫–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª—É (gain)</li>
                    <li>\( F_0 \) ‚Äî –æ—Å–Ω–æ–≤–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞ (pitch)</li>
                </ul>
            </li>
            
            <li><strong>–ù–∞–≤—á–∞–Ω–Ω—è –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä–∞</strong><br>
                –î–æ –≤—Ö—ñ–¥–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ \( \mathbf{k} \) –¥–æ–¥–∞—î—Ç—å—Å—è —à—É–º, –æ—Ç—Ä–∏–º—É—é—á–∏ \( \tilde{\mathbf{k}} \). –ú–µ—Ä–µ–∂–∞ –Ω–∞–≤—á–∞—î—Ç—å—Å—è –≤—ñ–¥–Ω–æ–≤–ª—é–≤–∞—Ç–∏ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π \( \mathbf{k} \) –∑ \( \tilde{\mathbf{k}} \).
            </li>
            
            <li><strong>–°–∏–Ω—Ç–µ–∑ –∑–≤—É–∫—É</strong><br>
                –í—ñ–¥–Ω–æ–≤–ª–µ–Ω—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –Ω–∞–∑–∞–¥ —É –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ LPC-—Ñ—ñ–ª—å—Ç—Ä–∞, —è–∫–∏–π –∑–±—É–¥–∂—É—î—Ç—å—Å—è —à—É–º–æ–º (–¥–ª—è –≥–ª—É—Ö–∏—Ö –∑–≤—É–∫—ñ–≤) –∞–±–æ —ñ–º–ø—É–ª—å—Å–∞–º–∏ (–¥–ª—è –¥–∑–≤—ñ–Ω–∫–∏—Ö).
            </li>
        </ol>
        
        <hr>
        
        <h3>2. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä–∞</h3>
        
        <p>–ê–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä ‚Äî —Ü–µ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂–∞, —â–æ –Ω–∞–≤—á–∞—î—Ç—å—Å—è –≤—ñ–¥—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ —Å–≤—ñ–π –≤—Ö—ñ–¥. –í—ñ–Ω —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è –∑ –¥–≤–æ—Ö —á–∞—Å—Ç–∏–Ω:</p>
        
        <ul>
            <li><strong>–ï–Ω–∫–æ–¥–µ—Ä</strong>: –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î –≤—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ –≤ –ª–∞—Ç–µ–Ω—Ç–Ω–∏–π (—Å—Ç–∏—Å–Ω–µ–Ω–∏–π) –ø—Ä–æ—Å—Ç—ñ—Ä.</li>
            <li><strong>–î–µ–∫–æ–¥–µ—Ä</strong>: –≤—ñ–¥–Ω–æ–≤–ª—é—î –¥–∞–Ω—ñ –∑ –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É.</li>
        </ul>
        
        <p>–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ —Ü–µ –º–æ–∂–Ω–∞ –∑–∞–ø–∏—Å–∞—Ç–∏ —è–∫:</p>
        \[
        \mathbf{x} \xrightarrow{\text{–ï–Ω–∫–æ–¥–µ—Ä}} \mathbf{z} \xrightarrow{\text{–î–µ–∫–æ–¥–µ—Ä}} \hat{\mathbf{x}}
        \]
        <p>–¥–µ:</p>
        <ul>
            <li>\( \mathbf{x} \in \mathbb{R}^p \) ‚Äî –≤—Ö—ñ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, LPC-–∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏)</li>
            <li>\( \mathbf{z} \in \mathbb{R}^d \) ‚Äî –ª–∞—Ç–µ–Ω—Ç–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (—Å—Ç–∏—Å–Ω–µ–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è), –¥–µ \( d \ll p \)</li>
            <li>\( \hat{\mathbf{x}} \in \mathbb{R}^p \) ‚Äî —Ä–µ–∫–æ–Ω—Å—Ç—Ä—É–π–æ–≤–∞–Ω–∏–π –≤–∏—Ö—ñ–¥</li>
        </ul>
        
        <p>–£  —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è <strong>–¥–µ–Ω–æ–π–∑—ñ–Ω–≥–æ–≤–∏–π –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä</strong> (Denoising Autoencoder), —è–∫–∏–π –Ω–∞–≤—á–∞—î—Ç—å—Å—è –≤—ñ–¥–Ω–æ–≤–ª—é–≤–∞—Ç–∏ —á–∏—Å—Ç—ñ –¥–∞–Ω—ñ –∑ –∑–∞—à—É–º–ª–µ–Ω–∏—Ö.</p>
        
        <hr>
        
        <h3>3. –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ –æ—Å–Ω–æ–≤–∏</h3>
        
        <h4>–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–µ—Ä–µ–∂—ñ</h4>
        <ul>
            <li>–í—Ö—ñ–¥–Ω–∏–π —à–∞—Ä: \( p \) –Ω–µ–π—Ä–æ–Ω—ñ–≤ (—Ä–æ–∑–º—ñ—Ä–Ω—ñ—Å—Ç—å LPC-–≤–µ–∫—Ç–æ—Ä–∞)</li>
            <li>–ü—Ä–∏—Ö–æ–≤–∞–Ω–∏–π (–ª–∞—Ç–µ–Ω—Ç–Ω–∏–π) —à–∞—Ä: \( d \) –Ω–µ–π—Ä–æ–Ω—ñ–≤ (\( d < p \))</li>
            <li>–í–∏—Ö—ñ–¥–Ω–∏–π —à–∞—Ä: \( p \) –Ω–µ–π—Ä–æ–Ω—ñ–≤</li>
        </ul>
        
        <h4>–ü—Ä—è–º–µ –ø–æ—à–∏—Ä–µ–Ω–Ω—è (Forward Pass)</h4>
        
        <p>–î–ª—è —à–∞—Ä—É –∑ —Ñ—É–Ω–∫—Ü—ñ—î—é –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó \( \sigma(\cdot) \):</p>
        \[
        \mathbf{h} = \sigma(\mathbf{W}_1 \mathbf{x} + \mathbf{b}_1)
        \]
        \[
        \hat{\mathbf{x}} = \sigma(\mathbf{W}_2 \mathbf{h} + \mathbf{b}_2)
        \]
        
        <p>–¥–µ:</p>
        <ul>
            <li>\( \mathbf{W}_1 \in \mathbb{R}^{d \times p} \) ‚Äî –º–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ –µ–Ω–∫–æ–¥–µ—Ä–∞</li>
            <li>\( \mathbf{b}_1 \in \mathbb{R}^d \) ‚Äî –≤–µ–∫—Ç–æ—Ä –∑–º—ñ—â–µ–Ω–Ω—è –µ–Ω–∫–æ–¥–µ—Ä–∞</li>
            <li>\( \mathbf{W}_2 \in \mathbb{R}^{p \times d} \) ‚Äî –º–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ –¥–µ–∫–æ–¥–µ—Ä–∞</li>
            <li>\( \mathbf{b}_2 \in \mathbb{R}^p \) ‚Äî –≤–µ–∫—Ç–æ—Ä –∑–º—ñ—â–µ–Ω–Ω—è –¥–µ–∫–æ–¥–µ—Ä–∞</li>
            <li>\( \sigma(\cdot) \) ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, tanh)</li>
        </ul>
        
        <h4>–§—É–Ω–∫—Ü—ñ—è –≤—Ç—Ä–∞—Ç (Loss Function)</h4>
        
        <p>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Å–µ—Ä–µ–¥–Ω—å–æ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ (MSE):</p>
        \[
        \mathcal{L} = \frac{1}{p} \sum_{i=1}^{p} (x_i - \hat{x}_i)^2
        \]
        <p>–¥–µ \( x_i \) ‚Äî –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è, \( \hat{x}_i \) ‚Äî —Ä–µ–∫–æ–Ω—Å—Ç—Ä—É–π–æ–≤–∞–Ω–µ.</p>
        
        <h4>–ù–∞–≤—á–∞–Ω–Ω—è: –∑–≤–æ—Ä–æ—Ç–Ω–µ –ø–æ—à–∏—Ä–µ–Ω–Ω—è –ø–æ–º–∏–ª–∫–∏ (Backpropagation)</h4>
        
        <p>–ê–ª–≥–æ—Ä–∏—Ç–º backpropagation –æ–±—á–∏—Å–ª—é—î –≥—Ä–∞–¥—ñ—î–Ω—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—ó –≤—Ç—Ä–∞—Ç –ø–æ –≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—é –¥–æ –≤–∞–≥ –º–µ—Ä–µ–∂—ñ:</p>
        
        <ol>
            <li>–ì—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ —à–∞—Ä—É:
                \[
                \delta^{(2)} = (\hat{\mathbf{x}} - \mathbf{x}) \odot \sigma'(\mathbf{z}^{(2)})
                \]
                –¥–µ \( \odot \) ‚Äî –ø–æ–µ–ª–µ–º–µ–Ω—Ç–Ω–µ –º–Ω–æ–∂–µ–Ω–Ω—è, \( \mathbf{z}^{(2)} = \mathbf{W}_2 \mathbf{h} + \mathbf{b}_2 \)
            </li>
            
            <li>–ì—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è –ø—Ä–∏—Ö–æ–≤–∞–Ω–æ–≥–æ —à–∞—Ä—É:
                \[
                \delta^{(1)} = (\mathbf{W}_2^T \delta^{(2)}) \odot \sigma'(\mathbf{z}^{(1)})
                \]
                –¥–µ \( \mathbf{z}^{(1)} = \mathbf{W}_1 \mathbf{x} + \mathbf{b}_1 \)
            </li>
            
            <li>–û–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∞–≥ –∑–∞ –ø—Ä–∞–≤–∏–ª–æ–º SGD:
                \[
                \mathbf{W}_1 \leftarrow \mathbf{W}_1 - \eta \cdot \delta^{(1)} \mathbf{x}^T
                \]
                \[
                \mathbf{b}_1 \leftarrow \mathbf{b}_1 - \eta \cdot \delta^{(1)}
                \]
                \[
                \mathbf{W}_2 \leftarrow \mathbf{W}_2 - \eta \cdot \delta^{(2)} \mathbf{h}^T
                \]
                \[
                \mathbf{b}_2 \leftarrow \mathbf{b}_2 - \eta \cdot \delta^{(2)}
                \]
                –¥–µ \( \eta \) ‚Äî —à–≤–∏–¥–∫—ñ—Å—Ç—å –Ω–∞–≤—á–∞–Ω–Ω—è (learning rate).
            </li>
        </ol>
        
        <hr>
        
        <h3>4. –§—É–Ω–∫—Ü—ñ—ó –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó —Ç–∞ —ó—Ö –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ</h3>
        
        <h4>Tanh (–≥—ñ–ø–µ—Ä–±–æ–ª—ñ—á–Ω–∏–π —Ç–∞–Ω–≥–µ–Ω—Å)</h4>
        \[
        \tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}
        \]
        <ul>
            <li>–î—ñ–∞–ø–∞–∑–æ–Ω –∑–Ω–∞—á–µ–Ω—å: \([-1, 1]\)</li>
            <li>–Ü–¥–µ–∞–ª—å–Ω–æ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è LPC-–∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤, —è–∫—ñ –ª–µ–∂–∞—Ç—å —É —Ü—å–æ–º—É –∂ –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ</li>
            <li>–ü–æ—Ö—ñ–¥–Ω–∞: \( \tanh'(x) = 1 - \tanh^2(x) \)</li>
        </ul>
        
        <h4>Sigmoid (–ª–æ–≥—ñ—Å—Ç–∏—á–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è)</h4>
        \[
        \sigma(x) = \frac{1}{1 + e^{-x}}
        \]
        <ul>
            <li>–î—ñ–∞–ø–∞–∑–æ–Ω –∑–Ω–∞—á–µ–Ω—å: \((0, 1)\)</li>
            <li>–ü–æ—Ö—ñ–¥–Ω–∞: \( \sigma'(x) = \sigma(x)(1 - \sigma(x)) \)</li>
            <li>–ú–µ–Ω—à –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Å–∏–º–µ—Ç—Ä–∏—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö (—è–∫ LPC-–∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏)</li>
        </ul>
        
        <h4>ReLU (Rectified Linear Unit)</h4>
        \[
        \text{ReLU}(x) = \max(0, x)
        \]
        <ul>
            <li>–î—ñ–∞–ø–∞–∑–æ–Ω –∑–Ω–∞—á–µ–Ω—å: \([0, \infty)\)</li>
            <li>–ü–æ—Ö—ñ–¥–Ω–∞: \( 1 \) –¥–ª—è \( x > 0 \), \( 0 \) –¥–ª—è \( x \leq 0 \)</li>
            <li>–ú–æ–∂–µ –ø—Ä–∏–∑–≤–æ–¥–∏—Ç–∏ –¥–æ "–ø–æ–º–µ—Ä–ª–∏—Ö –Ω–µ–π—Ä–æ–Ω—ñ–≤"</li>
            <li>–ù–µ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è LPC –±–µ–∑ –¥–æ–¥–∞—Ç–∫–æ–≤–æ—ó –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó</li>
        </ul>
        
        <hr>
        
        <h3>5. –í—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä–∞ –≤—ñ–¥ PCA/SVD</h3>
        
        <h4>PCA (Principal Component Analysis) / SVD (Singular Value Decomposition)</h4>
        
        <p>PCA ‚Äî –ª—ñ–Ω—ñ–π–Ω–∏–π –º–µ—Ç–æ–¥ –∑–º–µ–Ω—à–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ:</p>
        \[
        \mathbf{X} \approx \mathbf{U}_k \boldsymbol{\Sigma}_k \mathbf{V}_k^T
        \]
        <p>–¥–µ:</p>
        <ul>
            <li>\( \mathbf{U}_k \) ‚Äî –º–∞—Ç—Ä–∏—Ü—è –≤–ª–∞—Å–Ω–∏—Ö –≤–µ–∫—Ç–æ—Ä—ñ–≤ –∫–æ–≤–∞—Ä—ñ–∞—Ü—ñ–π–Ω–æ—ó –º–∞—Ç—Ä–∏—Ü—ñ</li>
            <li>\( \boldsymbol{\Sigma}_k \) ‚Äî –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å</li>
            <li>\( \mathbf{V}_k^T \) ‚Äî —Ç—Ä–∞–Ω—Å–ø–æ–Ω–æ–≤–∞–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ –≤–ª–∞—Å–Ω–∏—Ö –≤–µ–∫—Ç–æ—Ä—ñ–≤</li>
        </ul>
        
        <p><strong>–û–±–º–µ–∂–µ–Ω–Ω—è PCA:</strong></p>
        <ul>
            <li>–¢—ñ–ª—å–∫–∏ –ª—ñ–Ω—ñ–π–Ω—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è</li>
            <li>–ù–µ –º–æ–∂–µ –º–æ–¥–µ–ª—é–≤–∞—Ç–∏ —Å–∫–ª–∞–¥–Ω—ñ –Ω–µ–ª—ñ–Ω—ñ–π–Ω—ñ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ</li>
            <li>–ß—É—Ç–ª–∏–≤–∏–π –¥–æ –≤–∏–∫–∏–¥—ñ–≤</li>
        </ul>
        
        <h4>–ê–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä</h4>
        
        <p><strong>–ü–µ—Ä–µ–≤–∞–≥–∏ –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä–∞:</strong></p>
        <ul>
            <li>–ú–æ–∂–µ –≤–∏–≤—á–∞—Ç–∏ <strong>–Ω–µ–ª—ñ–Ω—ñ–π–Ω—ñ</strong> –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞–≤–¥—è–∫–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó</li>
            <li>–ó–¥–∞—Ç–Ω–∏–π –¥–æ –Ω–∞–≤—á–∞–Ω–Ω—è –Ω–∞ –∑–∞—à—É–º–ª–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö (–¥–µ–Ω–æ–π–∑–∏–Ω–≥)</li>
            <li>–ú–æ–∂–µ –≤–∏–≤—á–∞—Ç–∏ —ñ—î—Ä–∞—Ä—Ö—ñ—á–Ω—ñ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è</li>
            <li>–ë—ñ–ª—å—à –≥–Ω—É—á–∫–∏–π –∑–∞ —Ä–∞—Ö—É–Ω–æ–∫ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∏ –º–µ—Ä–µ–∂—ñ</li>
        </ul>
        
        <p><strong>–ö–ª—é—á–æ–≤–∞ –≤—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å:</strong> –Ø–∫—â–æ –≤ –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –ª—ñ–Ω—ñ–π–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó —Ç–∞ MSE-—Ñ—É–Ω–∫—Ü—ñ—é –≤—Ç—Ä–∞—Ç, –≤—ñ–Ω –≤–∏—Ä–æ–¥–∂—É—î—Ç—å—Å—è —É PCA. –°–∞–º–µ –Ω–µ–ª—ñ–Ω—ñ–π–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó —Ä–æ–±–ª—è—Ç—å –∞–≤—Ç–æ–µ–Ω–∫–æ–¥–µ—Ä –ø–æ—Ç—É–∂–Ω—ñ—à–∏–º —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º.</p>
        
        <hr>
        
        <h3>6. –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –Ω–∞ –ø—Ä–∞–∫—Ç–∏—Ü—ñ</h3>
        
               
        <ol>
            <li><strong>–ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω–µ –º–æ–¥–µ–ª—é–≤–∞–Ω–Ω—è –≥–æ–ª–æ—Å—É</strong><br>
                –ó–∞–º—ñ—Å—Ç—å —Ä–æ–±–æ—Ç–∏ –∑ "—Å–∏—Ä–∏–º" –∞—É–¥—ñ–æ,  –ø—Ä–∞—Ü—é—é—Ç—å –∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ç—Ä–∞–∫—Ç—É (LPC-–∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏).
            </li>
            
            <li><strong>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è —è–∫ –ø–æ–±—ñ—á–Ω–∏–π –ø—Ä–æ–¥—É–∫—Ç –Ω–∞–≤—á–∞–Ω–Ω—è</strong><br>
                –õ–∞—Ç–µ–Ω—Ç–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä (\( d \)-–≤–∏–º—ñ—Ä–Ω–∏–π –≤–µ–∫—Ç–æ—Ä) —î —Å—Ç–∏—Å–Ω–µ–Ω–∏–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è–º –≥–æ–ª–æ—Å—É.
            </li>
            
            <li><strong>–î–µ–Ω–æ–π–∑–∏–Ω–≥ —á–µ—Ä–µ–∑ –Ω–∞–≤—á–∞–Ω–Ω—è</strong><br>
                –ú–µ—Ä–µ–∂–∞ –≤—á–∏—Ç—å—Å—è —ñ–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ —à—É–º —ñ –≤—ñ–¥–Ω–æ–≤–ª—é–≤–∞—Ç–∏ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏.
            </li>
            
            
        </ol>
       
    </div>
</details>







    <div class="panel">
        <h2>1. –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</h2>
        <div class="controls-grid">
            <div class="control-item">
                <label>LPC Order (Input Size)</label>
                <select id="lpcOrder">
                    <option value="10" selected>10 (–°—Ç–∞–Ω–¥–∞—Ä—Ç)</option>
                    <option value="16">16 (–í–∏—Å–æ–∫–∞ —Ç–æ—á–Ω—ñ—Å—Ç—å)</option>
                    <option value="8">8 (–ù–∏–∑—å–∫–∞ —Ç–æ—á–Ω—ñ—Å—Ç—å)</option>
                </select>
            </div>
            <div class="control-item">
                <label>–†–æ–∑–º—ñ—Ä–Ω—ñ—Å—Ç—å –ª–∞—Ç–µ–Ω—Ç–Ω–æ–≥–æ —à–∞—Ä—É(Bottleneck)</label>
                <input type="number" id="latentDim" value="2" min="1" max="8">
                <small style="color:#64748b">–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö</small>
            </div>
            <div class="control-item">
                <label>–§—É–Ω–∫—Ü—ñ—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó</label>
                <select id="activationFunc">
                    <option value="tanh" selected>Tanh (Recommended)</option>
                    <option value="sigmoid">Sigmoid</option>
                    <option value="relu">ReLU (Experimental)</option>
                </select>
            </div>
            <div class="control-item" style="justify-content: flex-end;">
                <button onclick="resetAll()">üîÑ –°–∫–∏–Ω—É—Ç–∏</button>
            </div>
        </div>
    </div>

    <div class="panel">
        <h2>2. –ó–∞–ø–∏—Å –≥–æ–ª–æ—Å—É <span id="recStatus" class="status-badge">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è</span></h2>
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <button onclick="startRecording()" class="record">üé§ –ó–∞–ø–∏—Å–∞—Ç–∏ —Ñ—Ä–∞–∑—É</button>
            <button onclick="playBuffer(rawBuffer)" id="btnPlayRaw" class="play-orig" disabled>üîà –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
        </div>
        <div style="height: 60px; background: #f1f5f9; border-radius: 6px;">
            <canvas id="waveCanvas"></canvas>
        </div>
    </div>

    <div class="panel" id="trainPanel" style="opacity:0.6; pointer-events:none;">
        <h2>3. –ù–∞–≤—á–∞–Ω–Ω—è (Autoencoder) <span id="trainStatus" class="status-badge">–ù–µ –Ω–∞–≤—á–µ–Ω–æ</span></h2>
        <div class="viz-box">
            <canvas id="nnCanvas"></canvas>
            <div style="position:absolute; top:10px; right:10px; color:#4ade80; font-family:monospace;">Loss: <span id="lossDisp">-</span></div>
        </div>
        <div style="margin-top:10px;">
            <button onclick="startTraining()" id="btnTrain">üß† –¢—Ä–µ–Ω—É–≤–∞—Ç–∏ –º–µ—Ä–µ–∂—É</button>
        </div>
    </div>

    <div class="panel" id="inferPanel" style="opacity:0.6; pointer-events:none;">
        <h2>4. –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Ç–∞ –°–∏–Ω—Ç–µ–∑</h2>
        
        <div class="controls-grid">
            <div class="control-item">
                <label>–†—ñ–≤–µ–Ω—å –≤—Ö—ñ–¥–Ω–æ–≥–æ —à—É–º—É: <span id="noiseVal">50%</span></label>
                <div class="slider-container">
                    <span>0%</span>
                    <input type="range" id="noiseSlider" min="0" max="100" value="50" oninput="document.getElementById('noiseVal').innerText=this.value+'%'">
                    <span>100%</span>
                </div>
            </div>
            <div class="control-item">
                <label>–†–æ–±–æ—Ç–∏–∑–æ–≤–∞–Ω—ñ—Å—Ç—å (Pulse vs Noise): <span id="synthVal">80%</span></label>
                <div class="slider-container">
                    <span>–®–µ–ø—ñ—Ç</span>
                    <input type="range" id="synthSlider" min="0" max="100" value="80" oninput="document.getElementById('synthVal').innerText=this.value+'%'">
                    <span>–†–æ–±–æ—Ç</span>
                </div>
            </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top:15px;">
            <button onclick="playMode('original')" class="play-orig">1. –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
            <button onclick="playMode('vocoder')" class="play-vocoder">2. –í–æ–∫–æ–¥–µ—Ä</button>
            <button onclick="playMode('noisy')" class="play-noise">3. –ó —à—É–º–æ–º (–≤—Ö—ñ–¥ –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ)</button>
            <button onclick="playMode('ai')" class="play-ai">4. –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ AI</button>
        </div>
        
        <div style="display:flex; justify-content:space-between; margin-top:10px;">
            <div style="width:48%; text-align:center;">
                <small>–í–µ–∫—Ç–æ—Ä –æ–∑–Ω–∞–∫ (LPC) –í—Ö—ñ–¥</small>
                <canvas id="specIn" height="80" style="background:#e2e8f0; border-radius:4px;"></canvas>
            </div>
            <div style="width:48%; text-align:center;">
                <small>–í–µ–∫—Ç–æ—Ä –æ–∑–Ω–∞–∫ (LPC) –í–∏—Ö—ñ–¥</small>
                <canvas id="specOut" height="80" style="background:#e2e8f0; border-radius:4px;"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 1. –ì–õ–û–ë–ê–õ–¨–ù–Ü –ó–ú–Ü–ù–ù–Ü ---
    let audioCtx;
    let rawBuffer = null;
    let sampleRate = 0;
    
    // Dataset
    let frames = []; 
    const FRAME_SIZE = 512; 
    
    // Neural Net
    let nn = null;
    let isTrained = false;
    let isTraining = false;
    
    // --- 2. –ú–ê–¢–ï–ú–ê–¢–ò–ß–ù–ï –Ø–î–†–û (LPC) ---
    
    function autocorrelate(x, maxLag) {
        let res = new Float32Array(maxLag + 1);
        for(let k=0; k<=maxLag; k++) {
            let s = 0;
            for(let n=0; n<x.length-k; n++) s += x[n]*x[n+k];
            res[k] = s;
        }
        return res;
    }

    // –ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –∞–Ω–∞–ª—ñ–∑—É.
    // –ü–æ–≤–µ—Ä—Ç–∞—î —ñ 'a' (–¥–ª—è —Ñ—ñ–ª—å—Ç—Ä–∞), —ñ 'k' (–¥–ª—è –Ω–µ–π—Ä–æ–º–µ—Ä–µ–∂—ñ)
    function levinsonDurbin(r, order) {
        let a = new Float32Array(order + 1);
        let k_arr = new Float32Array(order);
        
        a[0] = 1.0;
        let e = r[0];
        
        // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ —Ç–∏—à—ñ/–ø–æ–º–∏–ª–æ–∫
        if (e < 1e-10) e = 1e-10;

        for (let i = 1; i <= order; i++) {
            let acc = 0;
            for (let j = 1; j < i; j++) acc += a[j] * r[i - j];
            
            // –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∞ –≤—ñ–¥–±–∏—Ç—Ç—è (reflection coeff)
            let k = -(r[i] + acc) / e;
            
            // Hard Clamp (–ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ NN!)
            if (k > 0.99) k = 0.99;
            if (k < -0.99) k = -0.99;
            
            k_arr[i-1] = k; // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥–ª—è dataset

            let a_new = new Float32Array(i + 1);
            a_new[0] = 1.0;
            a_new[i] = k;
            
            for (let j = 1; j < i; j++) {
                a_new[j] = a[j] + k * a[i - j];
            }
            
            a = a_new;
            e *= (1 - k * k);
        }
        
        // –ü–∞–¥—ñ–Ω–≥ –º–∞—Å–∏–≤—É a –¥–æ –ø–æ–≤–Ω–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É, —è–∫—â–æ —Ç—Ä–µ–±–∞ (—Ç—É—Ç –¥–∏–Ω–∞–º—ñ—á–Ω–æ)
        // –î–ª—è filterIIR –Ω–∞–º –ø–æ—Ç—Ä—ñ–±–µ–Ω –ø–æ–≤–Ω–∏–π –º–∞—Å–∏–≤ a
        return { a: a, k: k_arr, error: e };
    }

    // –ó–≤–æ—Ä–æ—Ç–Ω–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è k -> a (–¥–ª—è —Å–∏–Ω—Ç–µ–∑—É –ø—ñ—Å–ª—è NN)
    function kToA(k_coeffs) {
        let order = k_coeffs.length;
        let a = new Float32Array(order + 1);
        a[0] = 1.0;
        
        for(let i=1; i<=order; i++) {
            let k = k_coeffs[i-1];
            let a_new = new Float32Array(i + 1);
            a_new[0] = 1.0;
            a_new[i] = k;
            for(let j=1; j<i; j++) {
                a_new[j] = a[j] + k * a[i-j];
            }
            a = a_new;
        }
        return a;
    }

    function filterIIR(x, a, mem) {
        let y = new Float32Array(x.length);
        let ord = a.length - 1;
        if(!mem) mem = new Float32Array(ord).fill(0);

        for(let n=0; n<x.length; n++) {
            let s = x[n];
            for(let k=1; k<=ord; k++) {
                let val = (n >= k) ? y[n-k] : mem[ord-k];
                s -= a[k] * val;
            }
            // –õ—ñ–º—ñ—Ç–µ—Ä, —â–æ–± –Ω–µ –ø–æ—Ä–≤–∞–ª–æ –¥–∏–Ω–∞–º—ñ–∫–∏
            if(s > 4.0) s = 4.0; 
            if(s < -4.0) s = -4.0;
            y[n] = s;
        }
        for(let i=0; i<ord; i++) mem[i] = y[y.length-1-i];
        return y;
    }

    function detectPitch(buffer, sr) {
        let r = autocorrelate(buffer, 150);
        let maxVal = -Infinity;
        let lag = 0;
        for(let k=20; k<r.length-1; k++) {
            if(r[k] > maxVal && r[k] > r[k-1] && r[k] > r[k+1]) {
                maxVal = r[k];
                lag = k;
            }
        }
        if(maxVal > r[0] * 0.25) return sr / lag;
        return 0; 
    }

    // --- 3. –ù–ï–ô–†–û–ú–ï–†–ï–ñ–ê (–í–∏–ø—Ä–∞–≤–ª–µ–Ω–∞) ---
    class Autoencoder {
        constructor(inputSize, hiddenSize) {
            this.inputSize = inputSize;
            this.hiddenSize = hiddenSize;
            
            // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Xavier (–≤–∞–∂–ª–∏–≤–∞ –¥–ª—è –∑–±—ñ–∂–Ω–æ—Å—Ç—ñ)
            let lim1 = Math.sqrt(6 / (inputSize + hiddenSize));
            this.W1 = new Float32Array(hiddenSize * inputSize).map(()=>(Math.random()*2-1)*lim1);
            this.b1 = new Float32Array(hiddenSize).fill(0);
            
            let lim2 = Math.sqrt(6 / (hiddenSize + inputSize));
            this.W2 = new Float32Array(inputSize * hiddenSize).map(()=>(Math.random()*2-1)*lim2);
            this.b2 = new Float32Array(inputSize).fill(0);
            
            this.lr = 0.005; // –ú–µ–Ω—à–∏–π learning rate –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ
        }

        // –ê–∫—Ç–∏–≤–∞—Ü—ñ—è tanh (—ñ–¥–µ–∞–ª—å–Ω–æ –¥–ª—è k [-1, 1])
        tanh(x) { return Math.tanh(x); }
        dtanh(y) { return 1 - y*y; }

        forward(input) {
            this.h = new Float32Array(this.hiddenSize);
            // Layer 1
            for(let i=0; i<this.hiddenSize; i++) {
                let s = this.b1[i];
                for(let j=0; j<this.inputSize; j++) s += input[j] * this.W1[i*this.inputSize + j];
                this.h[i] = this.tanh(s);
            }
            
            this.out = new Float32Array(this.inputSize);
            // Layer 2
            for(let i=0; i<this.inputSize; i++) {
                let s = this.b2[i];
                for(let j=0; j<this.hiddenSize; j++) s += this.h[j] * this.W2[i*this.hiddenSize + j];
                this.out[i] = this.tanh(s); // –í–∏—Ö—ñ–¥ —Ç–µ–∂ tanh, –±–æ k [-1, 1]
            }
            return this.out;
        }

        train(input, target) {
            let out = this.forward(input);
            
            // Output Gradients
            let out_grad = new Float32Array(this.inputSize);
            let loss = 0;
            for(let i=0; i<this.inputSize; i++) {
                let err = target[i] - out[i];
                loss += err * err;
                out_grad[i] = err * this.dtanh(out[i]); // –ì—Ä–∞–¥—ñ—î–Ω—Ç MSE * –ø–æ—Ö—ñ–¥–Ω–∞ tanh
            }

            // Hidden Gradients
            let h_grad = new Float32Array(this.hiddenSize);
            for(let i=0; i<this.hiddenSize; i++) {
                let err = 0;
                for(let j=0; j<this.inputSize; j++) err += out_grad[j] * this.W2[j*this.hiddenSize + i];
                h_grad[i] = err * this.dtanh(this.h[i]);
            }

            // Update Weights (SGD)
            for(let i=0; i<this.inputSize; i++) {
                this.b2[i] += this.lr * out_grad[i];
                for(let j=0; j<this.hiddenSize; j++) {
                    this.W2[i*this.hiddenSize + j] += this.lr * out_grad[i] * this.h[j];
                }
            }
            for(let i=0; i<this.hiddenSize; i++) {
                this.b1[i] += this.lr * h_grad[i];
                for(let j=0; j<this.inputSize; j++) {
                    this.W1[i*this.inputSize + j] += this.lr * h_grad[i] * input[j];
                }
            }
            
            return loss;
        }
    }

    // --- 4. –õ–û–ì–Ü–ö–ê –Ü–ù–¢–ï–†–§–ï–ô–°–£ ---

    async function startRecording() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioCtx.sampleRate;
        
        let status = document.getElementById('recStatus');
        status.innerText = "–ó–∞–ø–∏—Å..."; status.className = "status-badge active-badge";
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            let chunks = [];
            
            mediaRecorder.ondataavailable = e => chunks.push(e.data);
            mediaRecorder.onstop = async () => {
                const blob = new Blob(chunks);
                const buf = await blob.arrayBuffer();
                const decoded = await audioCtx.decodeAudioData(buf);
                rawBuffer = decoded.getChannelData(0);
                
                status.innerText = "–ì–æ—Ç–æ–≤–æ"; status.className = "status-badge";
                document.getElementById('btnPlayRaw').disabled = false;
                
                analyzeAudio(); 
                document.getElementById('trainPanel').style.opacity = 1;
                document.getElementById('trainPanel').style.pointerEvents = 'all';
                drawWave(rawBuffer);
            };
            
            mediaRecorder.start();
            setTimeout(() => mediaRecorder.stop(), 2000); 
        } catch(e) { alert("Mic Error: " + e); }
    }

    function analyzeAudio() {
        if(!rawBuffer) return;
        const order = parseInt(document.getElementById('lpcOrder').value);
        frames = [];
        let hopSize = Math.floor(FRAME_SIZE / 2);
        
        for (let i = 0; i < rawBuffer.length - FRAME_SIZE; i += hopSize) {
            let chunk = rawBuffer.slice(i, i + FRAME_SIZE);
            
            // Hamming Window
            let winChunk = new Float32Array(FRAME_SIZE);
            let energy = 0;
            for(let j=0; j<FRAME_SIZE; j++) {
                let v = chunk[j] * (0.54 - 0.46 * Math.cos(2*Math.PI*j/(FRAME_SIZE-1)));
                winChunk[j] = v;
                energy += v*v;
            }
            
            // LPC Analysis
            let r = autocorrelate(winChunk, order);
            let lpcRes = levinsonDurbin(r, order); // –û—Ç—Ä–∏–º—É—î–º–æ {a, k, error}
            
            // Pitch
            let pitch = detectPitch(winChunk, sampleRate);
            
            // Residual Gain (Error Gain)
            // –ï–Ω–µ—Ä–≥—ñ—è –ø–æ–º–∏–ª–∫–∏ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è - —Ü–µ —ñ —î –ø–æ—Ç—Ä—ñ–±–Ω–∞ –≥—É—á–Ω—ñ—Å—Ç—å –∑–±—É–¥–∂–µ–Ω–Ω—è
            let g = Math.sqrt(lpcRes.error); 

            frames.push({
                k: lpcRes.k,     // –í–µ–∫—Ç–æ—Ä –¥–ª—è NN (Reflection Coeffs)
                gain: g,         // –ì—É—á–Ω—ñ—Å—Ç—å
                pitch: pitch     // –¢–æ–Ω
            });
        }
        drawNN();
    }

function startTraining() {
        const order = parseInt(document.getElementById('lpcOrder').value);
        const latent = parseInt(document.getElementById('latentDim').value);
        
        // --- –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –õ–û–ì–Ü–ö–ò ---
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ: —á–∏ —ñ—Å–Ω—É—î –º–µ—Ä–µ–∂–∞? –ß–∏ –∑–º—ñ–Ω–∏–ª–∏—Å—è –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ?
        // –Ø–∫—â–æ –º–µ—Ä–µ–∂–∞ —î —ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ç—ñ —Å–∞–º—ñ -> –ù–ï —Å—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤—É, –≤—á–∏–º–æ —Å—Ç–∞—Ä—É.
        if (!nn || nn.inputSize !== order || nn.hiddenSize !== latent) {
            nn = new Autoencoder(order, latent);
            console.log("–°—Ç–≤–æ—Ä–µ–Ω–æ –Ω–æ–≤—É –º–æ–¥–µ–ª—å");
        } else {
            console.log("–ü—Ä–æ–¥–æ–≤–∂—É—î–º–æ –Ω–∞–≤—á–∞–Ω–Ω—è —ñ—Å–Ω—É—é—á–æ—ó –º–æ–¥–µ–ª—ñ");
        }
        
        let btn = document.getElementById('btnTrain');
        btn.disabled = true; 
        btn.innerText = "–í—á—É—Å—è...";
        isTraining = true;
        
        // –õ—ñ—á–∏–ª—å–Ω–∏–∫ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Ü–∏–∫–ª—É "–¥–æ–≤—á–∞–Ω–Ω—è"
        let epoch = 0;
        const EPOCHS_PER_CLICK = 300; // –°–∫—ñ–ª—å–∫–∏ –µ–ø–æ—Ö –¥–æ–¥–∞—Ç–∏ –ø—Ä–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—ñ
        
        function loop() {
            if(!isTraining) return;
            
            let totalLoss = 0;
            let count = 0;
            
            for(let f of frames) {
                if(f.gain < 0.005) continue; 
                
                let clean = f.k; 
                
                // –®—É–º –¥–æ–¥–∞—î–º–æ –¥–∏–Ω–∞–º—ñ—á–Ω–æ, —â–æ–± –º–µ—Ä–µ–∂–∞ –±–∞—á–∏–ª–∞ –Ω–æ–≤—ñ –ø—Ä–∏–∫–ª–∞–¥–∏
                let noisyInput = new Float32Array(clean.length);
                for(let i=0; i<clean.length; i++) {
                    noisyInput[i] = clean[i] + (Math.random()-0.5) * 0.2; 
                }
                
                totalLoss += nn.train(noisyInput, clean);
                count++;
            }
            
            let avgLoss = count > 0 ? totalLoss / count : 0;
            document.getElementById('lossDisp').innerText = avgLoss.toFixed(5);
            
            if(epoch % 5 === 0) drawNN(true);
            
            epoch++;
            
            // –ö—Ä—É—Ç–∏–º–æ —Ü–∏–∫–ª, –ø–æ–∫–∏ –Ω–µ –ø—Ä–æ–π–¥–µ–º–æ –≤–∏–∑–Ω–∞—á–µ–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ø–æ—Ö
            if(epoch < EPOCHS_PER_CLICK) {
                requestAnimationFrame(loop);
            } else {
                // –§—ñ–Ω—ñ—à —Ü—å–æ–≥–æ –µ—Ç–∞–ø—É
                isTrained = true;
                isTraining = false;
                
                btn.innerText = "–î–æ–≤—á–∏—Ç–∏ (+300 –µ–ø–æ—Ö)"; 
                btn.disabled = false;
                
                document.getElementById('trainStatus').innerText = "–ù–∞–≤—á–µ–Ω–æ";
                document.getElementById('trainStatus').className = "status-badge active-badge";
                document.getElementById('inferPanel').style.opacity = 1;
                document.getElementById('inferPanel').style.pointerEvents = 'all';
                
                // –ü–µ—Ä–µ–º–∞–ª—å–æ–≤—É—î–º–æ –±–µ–∑ –∞–Ω—ñ–º–∞—Ü—ñ—ó (—Å—Ç–∞—Ç–∏—á–Ω—ñ –≤–∞–≥–∏)
                drawNN(false);
            }
        }
        loop();
    } 


 // --- 5. –°–ò–ù–¢–ï–ó (–í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ Logic + Slider) ---

    function playMode(mode) {
        if(!audioCtx) return;
        
        const noiseLvl = parseInt(document.getElementById('noiseSlider').value) / 100;
        const sliderMix = parseInt(document.getElementById('synthSlider').value) / 100; 
        const order = parseInt(document.getElementById('lpcOrder').value);
        
        const hopSize = Math.floor(FRAME_SIZE / 2);
        const totalSamples = frames.length * hopSize + FRAME_SIZE;
        
        const outBuf = audioCtx.createBuffer(1, totalSamples, sampleRate);
        const pcm = outBuf.getChannelData(0);
        
        let filterMem = new Float32Array(order).fill(0);
        let phase = 0;
        const ROBOT_PITCH = 150; // –ì—Ü
        
        let visInput = null, visOutput = null;

        for(let i=0; i<frames.length; i++) {
            let f = frames[i];
            
            // 1. –û—Ç—Ä–∏–º—É—î–º–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ K
            let k = Float32Array.from(f.k); // –ö–æ–ø—ñ—è
            
            // 2. –î–æ–¥–∞—î–º–æ —à—É–º (—è–∫—â–æ —Ç—Ä–µ–±–∞)
            if(mode === 'noisy' || mode === 'ai') {
                for(let j=0; j<k.length; j++) {
                    k[j] += (Math.random()-0.5) * noiseLvl * 2.5; 
                    // Clamping –≤—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö
                    if(k[j]>0.99) k[j]=0.99; if(k[j]<-0.99) k[j]=-0.99;
                }
            }
            visInput = k;
            
            // 3. –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è (Denoising)
            if(mode === 'ai' && isTrained) {
                k = nn.forward(k); 
                // NN –≤–∂–µ –ø–æ–≤–µ—Ä—Ç–∞—î –¥–∞–Ω—ñ –≤ [-1, 1], –∞–ª–µ –¥–ª—è –±–µ–∑–ø–µ–∫–∏ —Ñ—ñ–ª—å—Ç—Ä–∞:
                for(let j=0; j<k.length; j++) {
                     if(k[j]>0.99) k[j]=0.99; if(k[j]<-0.99) k[j]=-0.99;
                }
            }
            visOutput = k;
            
            // 4. –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è K -> A (–§—ñ–ª—å—Ç—Ä)
            let a = kToA(k); // –û—Ç—Ä–∏–º—É—î–º–æ [1, a1, a2...]

            // 5. –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑–±—É–¥–∂–µ–Ω–Ω—è (Excitation)
            let exc = new Float32Array(FRAME_SIZE);
            let gain = f.gain;
            
            // Pitch logic: —è–∫—â–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª –≥–ª—É—Ö–∏–π, –∞–ª–µ —Å–ª–∞–π–¥–µ—Ä "–†–æ–±–æ—Ç", 
            // –≤–º–∏–∫–∞—î–º–æ —à—Ç—É—á–Ω–∏–π —Ç–æ–Ω.
            let hasPitch = f.pitch > 0;
            let currentPitch = hasPitch ? f.pitch : ROBOT_PITCH;
            let period = sampleRate / currentPitch;
            let pulseAmp = Math.sqrt(period); // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –µ–Ω–µ—Ä–≥—ñ—ó —ñ–º–ø—É–ª—å—Å—É

            for(let n=0; n<FRAME_SIZE; n++) {
                // Noise source
                let noiseSamp = (Math.random() * 2 - 1);
                
                // Pulse source
                let pulseSamp = 0;
                phase++;
                if(phase >= period) {
                    phase -= period;
                    pulseSamp = pulseAmp;
                }

                // Mixing logic
                // –Ø–∫—â–æ —Å–ª–∞–π–¥–µ—Ä = 0 (–®–µ–ø—ñ—Ç) -> —Ç—ñ–ª—å–∫–∏ noiseSamp
                // –Ø–∫—â–æ —Å–ª–∞–π–¥–µ—Ä = 1 (–†–æ–±–æ—Ç) -> —Ç—ñ–ª—å–∫–∏ pulseSamp
                let finalExc = 0;
                
                // –Ø–∫—â–æ –≤ –æ—Ä–∏–≥—ñ–Ω–∞–ª—ñ –±—É–≤ —Ç–æ–Ω - –º—ñ–∫—Å—É—î–º–æ –∑–∞ —Å–º–∞–∫–æ–º
                // –Ø–∫—â–æ –≤ –æ—Ä–∏–≥—ñ–Ω–∞–ª—ñ –Ω–µ –±—É–ª–æ —Ç–æ–Ω—É - –≤—Å–µ –æ–¥–Ω–æ –º—ñ–∫—Å—É—î–º–æ –∑–∞ —Å–ª–∞–π–¥–µ—Ä–æ–º, 
                // —â–æ–± —Å—Ç–≤–æ—Ä–∏—Ç–∏ –µ—Ñ–µ–∫—Ç "—Ä–æ–±–æ—Ç–∏–∑–∞—Ü—ñ—ó —à–µ–ø–æ—Ç—É".
                finalExc = (pulseSamp * sliderMix) + (noiseSamp * (1.0 - sliderMix));
                
                exc[n] = finalExc * gain;
            }
            
            if(mode === 'original') {
                playBuffer(rawBuffer, false); return;
            }

            // 6. –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è
            let synth = filterIIR(exc, a, filterMem);
            
            // 7. Overlap-Add
            let startPos = i * hopSize;
            for(let n=0; n<FRAME_SIZE; n++) {
                let w = 0.5 - 0.5 * Math.cos(2*Math.PI*n/(FRAME_SIZE-1));
                if(startPos+n < pcm.length) pcm[startPos+n] += synth[n] * w;
            }
        }
        
        playBuffer(outBuf, true);
        drawSpec(visInput, 'specIn');
        drawSpec(visOutput, 'specOut');
    }

    function playBuffer(buf, isObj) {
        if(!buf) return;
        const src = audioCtx.createBufferSource();
        if(isObj) src.buffer = buf;
        else {
            const b = audioCtx.createBuffer(1, buf.length, sampleRate);
            b.getChannelData(0).set(buf);
            src.buffer = b;
        }
        src.connect(audioCtx.destination);
        src.start();
    }
    
    // --- –ì–†–ê–§–Ü–ö–ê ---
    function drawWave(d) {
        const ctx = document.getElementById('waveCanvas').getContext('2d');
        const w=ctx.canvas.width=ctx.canvas.clientWidth; 
        const h=ctx.canvas.height=ctx.canvas.clientHeight;
        ctx.clearRect(0,0,w,h); ctx.beginPath(); ctx.strokeStyle='#4f46e5';
        let step = Math.ceil(d.length/w);
        for(let i=0;i<w;i++) ctx.lineTo(i, h/2 + d[i*step]*h*0.8);
        ctx.stroke();
    }
    
    function drawSpec(d, id) {
        if(!d) return;
        const ctx = document.getElementById(id).getContext('2d');
        const w=ctx.canvas.width=ctx.canvas.clientWidth; 
        const h=ctx.canvas.height=ctx.canvas.clientHeight;
        ctx.clearRect(0,0,w,h);
        let bw = w/d.length;
        for(let i=0;i<d.length;i++) {
            let val = d[i];
            ctx.fillStyle = val>0?'#10b981':'#f59e0b';
            let bh = Math.abs(val)*h/2;
            ctx.fillRect(i*bw, h/2, bw-1, -bh);
            ctx.fillRect(i*bw, h/2, bw-1, bh);
        }
    }
    
    function drawNN(anim=false) {
        const ctx = document.getElementById('nnCanvas').getContext('2d');
        const w=ctx.canvas.width=ctx.canvas.clientWidth;
        const h=ctx.canvas.height=ctx.canvas.clientHeight;
        ctx.clearRect(0,0,w,h);
        if(!nn) return;

        const layers = [nn.inputSize, nn.hiddenSize, nn.inputSize];
        const layerGap = w / (layers.length + 1);
        let nodes = [];
        
        layers.forEach((count, lIdx) => {
            let x = (lIdx + 1) * layerGap;
            let yGap = h / (count + 1);
            let ln = [];
            for(let i=0; i<count; i++) ln.push({x: x, y: (i+1)*yGap});
            nodes.push(ln);
        });

        // Edges
        // 1. –ú–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—ó (Edges) –∑ –ø—Ä–∏–≤'—è–∑–∫–æ—é –¥–æ –≤–∞–≥
        for(let l=0; l<layers.length-1; l++) {
            let currentNodes = nodes[l];
            let nextNodes = nodes[l+1];
            
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ, –∑ —è–∫–∏–º —à–∞—Ä–æ–º –≤–∞–≥ –ø—Ä–∞—Ü—é—î–º–æ
            let weights = (l === 0) ? nn.W1 : nn.W2;
            let inputCount = (l === 0) ? nn.inputSize : nn.hiddenSize;

            for(let i=0; i<currentNodes.length; i++) { // i - —ñ–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —à–∞—Ä—É
                for(let j=0; j<nextNodes.length; j++) { // j - —ñ–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —à–∞—Ä—É
                    
                    let n1 = currentNodes[i];
                    let n2 = nextNodes[j];
                    
                    // –û—Ç—Ä–∏–º—É—î–º–æ –≤–∞–≥—É –∑–≤'—è–∑–∫—É
                    // –ú–∞—Ç—Ä–∏—Ü—è –≤–∞–≥ –ø–ª–æ—Å–∫–∞: [target_node * input_count + source_node]
                    let wVal = 0;
                    if(weights) {
                         wVal = weights[j * inputCount + i];
                    }

                    ctx.beginPath();
                    ctx.moveTo(n1.x, n1.y);
                    ctx.lineTo(n2.x, n2.y);
                    
                    // –õ–æ–≥—ñ–∫–∞ –∫–æ–ª—å–æ—Ä—É:
                    // –ß–∏–º –±—ñ–ª—å—à–∞ –≤–∞–≥–∞ -> —Ç–∏–º —Ç–æ–≤—â–∞/—è—Å–∫—Ä–∞–≤—ñ—à–∞ –ª—ñ–Ω—ñ—è.
                    // anim=true –¥–æ–¥–∞—î "–º–µ—Ä–µ—Ö—Ç—ñ–Ω–Ω—è" –ø—ñ–¥ —á–∞—Å –Ω–∞–≤—á–∞–Ω–Ω—è
                    let opacity = Math.abs(wVal); 
                    if(opacity > 1) opacity = 1; // Limit
                    if(opacity < 0.05) opacity = 0.05; // Minimum visibility
                    
                    if(anim) {
                        // –ï—Ñ–µ–∫—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
                        ctx.strokeStyle = `rgba(236, 72, 153, ${opacity})`; // –†–æ–∂–µ–≤–∏–π
                        ctx.lineWidth = opacity * 2;
                    } else {
                        // –°—Ç–∞—Ç–∏—á–Ω–∏–π —Å—Ç–∞–Ω
                        ctx.strokeStyle = `rgba(129, 140, 248, ${opacity * 0.8})`; // –°–∏–Ω—ñ–π
                        ctx.lineWidth = opacity;
                    }

                    ctx.stroke();
                }
            }
        }
        // Nodes
        layers.forEach((count, lIdx) => {
            for(let n of nodes[lIdx]) {
                ctx.beginPath(); ctx.arc(n.x, n.y, 4, 0, 7);
                ctx.fillStyle = anim?'#ec4899':(lIdx==1?'#f43f5e':'#818cf8');
                ctx.fill();
            }
        });
    }

    function resetAll() { location.reload(); }
</script>
</body>
</html>
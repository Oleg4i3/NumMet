<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞—É–¥—ñ–æ</title>
    
    <script>
        window.MathJax = {
            tex: { 
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$']]
            },
            svg: { fontCache: 'global' },
            startup: { typeset: false }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #e2e8f0;
            --accent: #38bdf8;
            --highlight: #facc15;
            --kept: #10b981;
            --lost: #f43f5e;
            --dct: #f97316;
            --border: #334155;
            --lossy-accent: #ff9800;
            --lossy-kept: #4caf50;
            --threshold: #00bcd4;
        }
        
        body {
            font-family: 'Segoe UI', monospace;
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
        }
        
        h1 { color: var(--accent); margin-bottom: 5px; font-weight: 300; }
        .subtitle { color: #aaa; margin-bottom: 30px; text-align: center; max-width: 800px; }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: var(--panel);
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            max-width: 1000px;
        }
        
        .tab-btn {
            flex: 1;
            padding: 12px 20px;
            background: #2d3748;
            color: #cbd5e1;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            text-align: center;
        }
        
        .tab-btn:hover {
            background: #4a5568;
            border-color: var(--accent);
        }
        
        .tab-btn.active {
            background: var(--accent);
            color: #0f172a;
            border-color: var(--accent);
        }
        
        .tab-content {
            display: none;
            width: 100%;
            max-width: 1000px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Shared Audio Controls */
        .audio-controls {
            background: var(--panel);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 1px solid var(--border);
        }
        
        .audio-controls .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button, .file-label {
            background: #334155;
            color: #fff;
            border: 1px solid #475569;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-family: inherit;
        }
        
        button:hover:not(:disabled), .file-label:hover {
            background: #475569;
            border-color: var(--accent);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .recording {
            background: #ef4444 !important;
            animation: pulse 1s infinite;
        }
        
        /* Lossy Tab Styles */
        #lossy-tab .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        #lossy-tab .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }
        
        #lossy-tab canvas {
            width: 100%;
            background: #000;
            border-radius: 4px;
            display: block;
        }
        
        #lossy-tab .slider-container {
            position: relative;
            height: 40px;
            background: #222;
            margin-top: 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }
        
        #lossy-tab input[type=range] {
            width: 100%;
            accent-color: var(--threshold);
            cursor: pointer;
        }
        
        #lossy-tab .options-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 4px;
        }
        
        #lossy-tab .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }
        
        #lossy-tab .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            text-align: center;
        }
        
        #lossy-tab .stat-box {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
        }
        
        #lossy-tab .stat-val {
            font-size: 1.2rem;
            font-weight: bold;
            display: block;
            margin-top: 5px;
        }
        
        /* SVD Tab Styles */
        #svd-tab .main-grid {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1100px) {
            #svd-tab .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        #svd-tab .panel {
            background: var(--panel);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        #svd-tab .step-guide {
            background: #172554;
            border-left: 4px solid var(--highlight);
            padding: 15px;
            margin-bottom: 5px;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #cbd5e1;
        }
        
        #svd-tab .step-title {
            color: var(--highlight);
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
            display: block;
        }
        
        #svd-tab .theory-block {
            background: #020617;
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 15px;
            font-size: 0.85rem;
            color: #94a3b8;
            line-height: 1.7;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #svd-tab .slider-label {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 0.9rem;
        }
        
        #svd-tab .canvas-container {
            position: relative;
            margin-bottom: 15px;
            border: 1px solid #334155;
            padding-left: 35px;
            padding-bottom: 20px;
            background: #000;
        }
        
        #svd-tab .overlay-label {
            position: absolute;
            top: 0;
            left: 35px;
            background: rgba(15, 23, 42, 0.9);
            color: var(--accent);
            padding: 2px 6px;
            font-size: 0.75rem;
            pointer-events: none;
            border-bottom-right-radius: 4px;
        }
        
        /* Common */
        .status-text {
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
            min-height: 1.2em;
            margin-top: 5px;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-label {
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞—É–¥—ñ–æ: SVD i DCT</h1>
    <p class="subtitle">
        –ü–æ—Ä—ñ–≤–Ω—è–π—Ç–µ –¥–≤–∞ –º–µ—Ç–æ–¥–∏ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞—É–¥—ñ–æ: –ø—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–µ (–Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ—Ä–æ–≥—É —á—É—Ç–Ω–æ—Å—Ç—ñ) 
        —Ç–∞ –º–∞—Ç—Ä–∏—á–Ω–µ (–Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ–≥–æ —Ä–æ–∑–∫–ª–∞–¥—É). –ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ –∞—É–¥—ñ–æ –æ–¥–∏–Ω —Ä–∞–∑ —Ç–∞ –¥–æ—Å–ª—ñ–¥–∂—É–π—Ç–µ –æ–±–∏–¥–≤–∞ –ø—ñ–¥—Ö–æ–¥–∏.
    </p>
	
	
	
	<details>
    <summary style="padding: 20px; font-size: 1.2rem; font-weight: bold; background: linear-gradient(90deg, #1e293b, #0f172a); color: #38bdf8; cursor: pointer; border-radius: 8px; border: 1px solid #334155;">
        üìö –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∏–π –¥–æ–≤—ñ–¥–Ω–∏–∫: –î–≤–∞ –ø—ñ–¥—Ö–æ–¥–∏ –¥–æ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞—É–¥—ñ–æ
    </summary>
    <div style="background: #0f172a; padding: 25px; margin-top: 10px; border-radius: 8px; border: 1px solid #334155; color: #e2e8f0; line-height: 1.6;">

        <!-- –í—Å—Ç—É–ø -->
        <div style="margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid #334155;">
            <h3 style="color: #38bdf8; margin-top: 0;">–ó–∞–≥–∞–ª—å–Ω—ñ –ø—Ä–∏–Ω—Ü–∏–ø–∏ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞—É–¥—ñ–æ</h3>
            <p>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞—É–¥—ñ–æ ‚Äî —Ü–µ –ø—Ä–æ—Ü–µ—Å –∑–º–µ–Ω—à–µ–Ω–Ω—è –æ–±—Å—è–≥—É –¥–∞–Ω–∏—Ö, –Ω–µ–æ–±—Ö—ñ–¥–Ω–∏—Ö –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∑–≤—É–∫–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª—É, —à–ª—è—Ö–æ–º –≤–∏–¥–∞–ª–µ–Ω–Ω—è –Ω–∞–¥–º—ñ—Ä–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó. –Ü—Å–Ω—É—î –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω–∏—Ö –ø—ñ–¥—Ö–æ–¥–∏:</p>
            <ul>
                <li><strong style="color: #ff9800;">–ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è (Lossy)</strong> ‚Äî –≤–∏–¥–∞–ª—è—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é, —è–∫—É –ª—é–¥—Å—å–∫–µ –≤—É—Ö–æ –Ω–µ —Å–ø—Ä–∏–π–º–∞—î, “ë—Ä—É–Ω—Ç—É—é—á–∏—Å—å –Ω–∞ —Ñ—ñ–∑—ñ–æ–ª–æ–≥—ñ—ó —Å–ª—É—Ö—É</li>
                <li><strong style="color: #38bdf8;">–ú–∞—Ç—Ä–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è (SVD)</strong> ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è —Ç–∞ –≤—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –º–∞–ª–æ–≤–∞–∂–ª–∏–≤–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤ —Å–∏–≥–Ω–∞–ª—É</li>
            </ul>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
            <!-- –õ—ñ–≤–∞ –∫–æ–ª–æ–Ω–∫–∞: Lossy -->
            <div style="background: #1e293b; padding: 20px; border-radius: 8px; border-left: 4px solid #ff9800;">
                <h3 style="color: #ff9800; margin-top: 0;">üéµ –ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è</h3>
                
                <div style="background: #0f172a; padding: 15px; border-radius: 6px; margin: 15px 0;">
                    <h4 style="color: #00bcd4; margin-top: 0;">1. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è (MDCT)</h4>
                    <p>–°—É—á–∞—Å–Ω—ñ –∞—É–¥—ñ–æ–∫–æ–¥–µ–∫–∏ (MP3, AAC, Opus) –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å <strong>–ú–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω–µ –î–∏—Å–∫—Ä–µ—Ç–Ω–µ –ö–æ—Å–∏–Ω—É—Å–Ω–µ –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è</strong>:</p>
                    <div style="background: #172554; padding: 15px; border-left:3px solid #ff9800; font-family: 'Times New Roman', serif; font-size: 1.1rem; margin: 15px 0; text-align: center;">
                        X<sub>k</sub> = &sum;<sub>n=0</sub><sup>N-1</sup> x<sub>n</sub> &cdot; cos [&pi;/N (n + 0.5 + N/2)(k + 0.5)]
                    </div>
                    <p>–¥–µ <strong>x<sub>n</sub></strong> ‚Äî –≤—Ö—ñ–¥–Ω—ñ –∞–º–ø–ª—ñ—Ç—É–¥–∏, –∞ <strong>cos[...]</strong> ‚Äî –±–∞–∑–∏—Å–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó. –Ø–∫—â–æ —Å–∏–≥–Ω–∞–ª —Å—Ö–æ–∂–∏–π –Ω–∞ –∫–æ—Å–∏–Ω—É—Å–æ—ó–¥—É –ø–µ–≤–Ω–æ—ó —á–∞—Å—Ç–æ—Ç–∏, –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç <strong>X<sub>k</sub></strong> –±—É–¥–µ –≤–µ–ª–∏–∫–∏–º.</p>
                </div>

                <div style="background: #0f172a; padding: 15px; border-radius: 6px; margin: 15px 0;">
                    <h4 style="color: #00bcd4; margin-top: 0;">2. –ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–∞ –º–æ–¥–µ–ª—å</h4>
                    <p><strong>–ó–∞–∫–æ–Ω –í–µ–±–µ—Ä–∞-–§–µ—Ö–Ω–µ—Ä–∞:</strong> —Å–ø—Ä–∏–π–Ω—è—Ç—Ç—è –≥—É—á–Ω–æ—Å—Ç—ñ –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π–Ω–µ –ª–æ–≥–∞—Ä–∏—Ñ–º—É —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ –∑–≤—É–∫—É:</p>
                    <div style="background: #172554; padding: 15px; border-left:3px solid #ff9800; font-family: 'Times New Roman', serif; font-size: 1.1rem; margin: 10px 0; text-align: center;">
                        S = k &middot; ln(I/I<sub>0</sub>)
                    </div>
                    <p>–î–µ <strong>S</strong> ‚Äî –≤—ñ–¥—á—É—Ç—Ç—è –≥—É—á–Ω–æ—Å—Ç—ñ, <strong>I</strong> ‚Äî —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –∑–≤—É–∫—É, <strong>I<sub>0</sub></strong> ‚Äî –ø–æ—Ä—ñ–≥ —á—É—Ç–Ω–æ—Å—Ç—ñ. –ß–µ—Ä–µ–∑ —Ü–µ —Å–ø–µ–∫—Ç—Ä–æ–≥—Ä–∞–º–∏ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è –≤ –ª–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω—ñ–π —à–∫–∞–ª—ñ.</p>
                </div>

                <div style="background: #0f172a; padding: 15px; border-radius: 6px; margin: 15px 0;">
                    <h4 style="color: #00bcd4; margin-top: 0;">3. –ï—Ñ–µ–∫—Ç –º–∞—Å–∫—É–≤–∞–Ω–Ω—è</h4>
                    <p>–°–∏–ª—å–Ω—ñ –∑–≤—É–∫–∏ (–º–∞—Å–∫–µ—Ä–∏) –ø—Ä–∏—Ö–æ–≤—É—é—Ç—å —Å–ª–∞–±—à—ñ –∑–≤—É–∫–∏ –±–ª–∏–∑—å–∫–∏—Ö —á–∞—Å—Ç–æ—Ç:</p>
                    <ul>
                        <li><strong>–ß–∞—Å—Ç–æ—Ç–Ω–µ –º–∞—Å–∫—É–≤–∞–Ω–Ω—è:</strong> –∑–≤—É–∫ –æ–¥–Ω—ñ—î—ó —á–∞—Å—Ç–æ—Ç–∏ –º–∞—Å–∫—É—î –∑–≤—É–∫–∏ –±–ª–∏–∑—å–∫–∏—Ö —á–∞—Å—Ç–æ—Ç</li>
                        <li><strong>–¢–∏–º—á–∞—Å–æ–≤–µ –º–∞—Å–∫—É–≤–∞–Ω–Ω—è:</strong> –≥—É—á–Ω–∏–π –∑–≤—É–∫ —Ç–∏–º—á–∞—Å–æ–≤–æ –ø—ñ–¥–≤–∏—â—É—î –ø–æ—Ä—ñ–≥ —á—É—Ç–Ω–æ—Å—Ç—ñ</li>
                    </ul>
                    <p>–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ —Ü–µ –º–æ–¥–µ–ª—é—î—Ç—å—Å—è —Ñ—É–Ω–∫—Ü—ñ—î—é —Ä–æ–∑—Ç—ñ–∫–∞–Ω–Ω—è (Spreading Function), —è–∫–∞ –ø—ñ–¥–≤–∏—â—É—î –ø–æ—Ä—ñ–≥ —á—É—Ç–Ω–æ—Å—Ç—ñ –Ω–∞–≤–∫–æ–ª–æ –º–∞—Å–∫–µ—Ä–∞.</p>
                </div>

                <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 6px; border-left: 3px solid #ff9800;">
                    <h4 style="color: #ff9800; margin-top: 0;">üí° –ü—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è</h4>
                    <p><strong>–§–æ—Ä–º–∞—Ç–∏:</strong> MP3, AAC, Ogg Vorbis, Opus</p>
                    <p><strong>–°—Ç—É–ø—ñ–Ω—å —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è:</strong> 10:1 - 12:1 –±–µ–∑ –ø–æ–º—ñ—Ç–Ω–æ—ó –≤—Ç—Ä–∞—Ç–∏ —è–∫–æ—Å—Ç—ñ</p>
                    <p><strong>–ü–µ—Ä–µ–≤–∞–≥–∏:</strong> –≤–∏—Å–æ–∫–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å, –ø—ñ–¥—Ç—Ä–∏–º–∫–∞ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É, —à–∏—Ä–æ–∫–µ –ø–æ—à–∏—Ä–µ–Ω–Ω—è</p>
                </div>
            </div>

            <!-- –ü—Ä–∞–≤–∞ –∫–æ–ª–æ–Ω–∫–∞: SVD -->
            <div style="background: #1e293b; padding: 20px; border-radius: 8px; border-left: 4px solid #38bdf8;">
                <h3 style="color: #38bdf8; margin-top: 0;">üìä –ú–∞—Ç—Ä–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è (SVD)</h3>
                
                <div style="background: #0f172a; padding: 15px; border-radius: 6px; margin: 15px 0;">
                    <h4 style="color: #facc15; margin-top: 0;">1. –°–∏–Ω–≥—É–ª—è—Ä–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ –º–∞—Ç—Ä–∏—Ü—ñ</h4>
                    <p>–ë—É–¥—å-—è–∫—É –º–∞—Ç—Ä–∏—Ü—é <strong>A</strong> —Ä–æ–∑–º—ñ—Ä–æ–º <strong>m √ó n</strong> –º–æ–∂–Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–∏ —è–∫:</p>
                    <div style="background: #172554; padding: 15px; border-left:3px solid #38bdf8; font-family: 'Times New Roman', serif; font-size: 1.1rem; margin: 10px 0; text-align: center;">
                        A = UŒ£V<sup>T</sup> = &sum;<sub>i=1</sub><sup>r</sup> œÉ<sub>i</sub> u<sub>i</sub> v<sub>i</sub><sup>T</sup>
                    </div>
                    <p>–¥–µ <strong>U</strong> —ñ <strong>V</strong> ‚Äî –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ñ –º–∞—Ç—Ä–∏—Ü—ñ, –∞ <strong>Œ£</strong> ‚Äî –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏—Ö —á–∏—Å–µ–ª <strong>œÉ‚ÇÅ ‚â• œÉ‚ÇÇ ‚â• ... ‚â• œÉ<sub>r</sub> > 0</strong>.</p>
                </div>

                <div style="background: #0f172a; padding: 15px; border-radius: 6px; margin: 15px 0;">
                    <h4 style="color: #facc15; margin-top: 0;">2. –ù–∞–±–ª–∏–∂–µ–Ω–Ω—è –Ω–∏–∑—å–∫–æ–≥–æ —Ä–∞–Ω–≥—É</h4>
                    <p>–í—ñ–¥–∫–∏–¥–∞—é—á–∏ –º–∞–ª—ñ —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ñ —á–∏—Å–ª–∞, –æ—Ç—Ä–∏–º—É—î–º–æ —Å—Ç–∏—Å–Ω–µ–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è:</p>
                    <div style="background: #172554; padding: 15px; border-left:3px solid #38bdf8; font-family: 'Times New Roman', serif; font-size: 1.1rem; margin: 10px 0; text-align: center;">
                        A<sub>k</sub> = &sum;<sub>i=1</sub><sup>k</sup> œÉ<sub>i</sub> u<sub>i</sub> v<sub>i</sub><sup>T</sup>, k < r
                    </div>
                    <p>–ü–æ—Ö–∏–±–∫–∞ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è: <strong>‚ÄñA - A<sub>k</sub>‚Äñ¬≤ = Œ£<sub>i=k+1</sub><sup>r</sup> œÉ<sub>i</sub>¬≤</strong>. –ß–∏–º —à–≤–∏–¥—à–µ —Å–ø–∞–¥–∞—é—Ç—å œÉ<sub>i</sub>, —Ç–∏–º –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è.</p>
                </div>

                <div style="background: #0f172a; padding: 15px; border-radius: 6px; margin: 15px 0;">
                    <h4 style="color: #facc15; margin-top: 0;">3. –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –¥–ª—è –∞—É–¥—ñ–æ</h4>
                    <p>–ê—É–¥—ñ–æ—Å–∏–≥–Ω–∞–ª –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –≤ —Å–ø–µ–∫—Ç—Ä–æ–≥—Ä–∞–º—É (–º–∞—Ç—Ä–∏—Ü—é —á–∞—Å—Ç–æ—Ç–∞-—á–∞—Å), –ø–æ—Ç—ñ–º –∑–∞—Å—Ç–æ—Å–æ–≤—É—î—Ç—å—Å—è SVD:</p>
                    <ol>
                        <li>–û–±—á–∏—Å–ª—é—î–º–æ STFT (Short-Time Fourier Transform)</li>
                        <li>–û—Ç—Ä–∏–º—É—î–º–æ –º–∞—Ç—Ä–∏—Ü—é –ª–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω–∏—Ö –∞–º–ø–ª—ñ—Ç—É–¥</li>
                        <li>–ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ SVD —Ç–∞ –∑–∞–ª–∏—à–∞—î–º–æ <strong>k</strong> –Ω–∞–π–±—ñ–ª—å—à–∏—Ö —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏—Ö —á–∏—Å–µ–ª</li>
                        <li>–í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ —Å–∏–≥–Ω–∞–ª –∑—ñ –∑–º–µ–Ω—à–µ–Ω–æ—é –º–∞—Ç—Ä–∏—Ü–µ—é</li>
                    </ol>
                </div>

                <div style="background: rgba(56, 189, 248, 0.1); padding: 15px; border-radius: 6px; border-left: 3px solid #38bdf8;">
                    <h4 style="color: #38bdf8; margin-top: 0;">üí° –ü—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è</h4>
                    <p><strong>–ì–∞–ª—É–∑—ñ:</strong> –æ–±—Ä–æ–±–∫–∞ —Å–∏–≥–Ω–∞–ª—ñ–≤, —à—É–º–æ–ø–æ–¥–∞–≤–ª–µ–Ω–Ω—è, –≤–∏–¥—ñ–ª–µ–Ω–Ω—è –≥–æ–ª–æ—Å—É, –º–∞—à–∏–Ω–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è</p>
                    <p><strong>–°—Ç—É–ø—ñ–Ω—å —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è:</strong> –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Ö–∞—Ä–∞–∫—Ç–µ—Ä—É —Å–∏–≥–Ω–∞–ª—É (2:1 - 20:1)</p>
                    <p><strong>–ü–µ—Ä–µ–≤–∞–≥–∏:</strong> –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ —Å—Ç—Ä–æ–≥—ñ—Å—Ç—å, –∑–±–µ—Ä—ñ–≥–∞—î —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–∏—Ö, –ø—Ä–∏–¥–∞—Ç–Ω–µ –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É</p>
                </div>
            </div>
        </div>

        <!-- –ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ —Ç–∞–±–ª–∏—Ü—è -->
        <div style="background: #1e293b; padding: 25px; border-radius: 8px; margin-top: 20px;">
            <h3 style="color: #facc15; text-align: center; margin-top: 0;">‚öñÔ∏è –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –º–µ—Ç–æ–¥—ñ–≤</h3>
            
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <thead>
                        <tr style="background: #0f172a;">
                            <th style="padding: 12px; border: 1px solid #334155; text-align: center; color: #38bdf8;">–ö—Ä–∏—Ç–µ—Ä—ñ–π</th>
                            <th style="padding: 12px; border: 1px solid #334155; text-align: center; color: #ff9800;">–ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–∏–π –º–µ—Ç–æ–¥</th>
                            <th style="padding: 12px; border: 1px solid #334155; text-align: center; color: #38bdf8;">SVD –º–µ—Ç–æ–¥</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–û—Å–Ω–æ–≤–Ω–∏–π –ø—Ä–∏–Ω—Ü–∏–ø</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">–í–∏–¥–∞–ª–µ–Ω–Ω—è –Ω–µ–ø–æ–º—ñ—Ç–Ω–æ—ó –¥–ª—è –≤—É—Ö–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó</td>
                            <td style="padding: 12px; border: 1px solid #334155;">–ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –º–∞—Ç—Ä–∏—Ü—ñ –Ω–∏–∑—å–∫–æ–≥–æ —Ä–∞–Ω–≥—É</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ –æ—Å–Ω–æ–≤–∞</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">MDCT/DCT, –ø—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω—ñ –º–æ–¥–µ–ª—ñ</td>
                            <td style="padding: 12px; border: 1px solid #334155;">–õ—ñ–Ω—ñ–π–Ω–∞ –∞–ª–≥–µ–±—Ä–∞ (SVD, PCA)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–ö—Ä–∏—Ç–µ—Ä—ñ–π —è–∫–æ—Å—Ç—ñ</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">–°—É–±'—î–∫—Ç–∏–≤–Ω–∞ —è–∫—ñ—Å—Ç—å (—Å–ª—É—Ö–æ–≤–∞)</td>
                            <td style="padding: 12px; border: 1px solid #334155;">–û–±'—î–∫—Ç–∏–≤–Ω–∞ –ø–æ—Ö–∏–±–∫–∞ (MSE, RMSE)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–¢–∏–ø –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ñ–≤</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">–ü—Ä–µ-–µ—Ö–æ, –∫–≤–∞–Ω—Ç—É–≤–∞–ª—å–Ω–∏–π —à—É–º</td>
                            <td style="padding: 12px; border: 1px solid #334155;">"–ú–µ—Ç–∞–ª–µ–≤–∏–π" –∑–≤—É–∫, –≤—Ç—Ä–∞—Ç–∞ –¥–µ—Ç–∞–ª–µ–π</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–ï—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">–í–∏—Å–æ–∫–∞ –¥–ª—è –º—É–∑–∏–∫–∏/–º–æ–≤–∏ (10-12:1)</td>
                            <td style="padding: 12px; border: 1px solid #334155;">–ó–º—ñ–Ω–Ω–∞, –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Å–∏–≥–Ω–∞–ª—É</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–û–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">–°–µ—Ä–µ–¥–Ω—è (—Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –≤ –∞–ø–∞—Ä–∞—Ç—ñ)</td>
                            <td style="padding: 12px; border: 1px solid #334155;">–í–∏—Å–æ–∫–∞ (O(n¬≥) –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ SVD)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #334155; background: #0f172a;"><strong>–¢–∏–ø–æ–≤–µ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è</strong></td>
                            <td style="padding: 12px; border: 1px solid #334155;">–ê—É–¥—ñ–æ–∫–æ–¥–µ–∫–∏ (MP3, AAC), —Å—Ç—Ä–∏–º—ñ–Ω–≥</td>
                            <td style="padding: 12px; border: 1px solid #334155;">–î–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è, –æ–±—Ä–æ–±–∫–∞ —Å–∏–≥–Ω–∞–ª—ñ–≤, ML</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- –í–∏—Å–Ω–æ–≤–∫–∏ -->
        <div style="background: linear-gradient(90deg, #172554, #0f172a); padding: 25px; border-radius: 8px; margin-top: 30px; border-left: 4px solid #facc15;">
            <h3 style="color: #facc15; margin-top: 0;">üéØ –ö–ª—é—á–æ–≤—ñ –≤–∏—Å–Ω–æ–≤–∫–∏</h3>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                <div>
                    <h4 style="color: #ff9800;">–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –ø—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è?</h4>
                    <ul>
                        <li>–î–ª—è –º—É–∑–∏–∫–∏ —Ç–∞ –º–æ–≤–∏ –∑ –≤–∏—Å–æ–∫–∏–º–∏ –≤–∏–º–æ–≥–∞–º–∏ –¥–æ —Å—É–±'—î–∫—Ç–∏–≤–Ω–æ—ó —è–∫–æ—Å—Ç—ñ</li>
                        <li>–ö–æ–ª–∏ –≤–∞–∂–ª–∏–≤–∞ —Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å –∑ —ñ—Å–Ω—É—é—á–∏–º–∏ –ø—Ä–∏—Å—Ç—Ä–æ—è–º–∏ (–ø–ª–µ—î—Ä–∏, —Ç–µ–ª–µ—Ñ–æ–Ω–∏)</li>
                        <li>–î–ª—è –ø–æ—Ç–æ–∫–æ–≤–æ—ó –ø–µ—Ä–µ–¥–∞—á—ñ –∞—É–¥—ñ–æ (—ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-—Ä–∞–¥—ñ–æ, —Å—Ç—Ä–∏–º—ñ–Ω–≥–æ–≤—ñ —Å–µ—Ä–≤—ñ—Å–∏)</li>
                        <li>–ö–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–∞ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É –∑ –Ω–∏–∑—å–∫–æ—é –∑–∞—Ç—Ä–∏–º–∫–æ—é</li>
                    </ul>
                </div>
                
                <div>
                    <h4 style="color: #38bdf8;">–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ SVD —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è?</h4>
                    <ul>
                        <li>–î–ª—è –Ω–∞—É–∫–æ–≤–∏—Ö –¥–æ—Å–ª—ñ–¥–∂–µ–Ω—å —Ç–∞ –∞–Ω–∞–ª—ñ–∑—É —Å–∏–≥–Ω–∞–ª—ñ–≤</li>
                        <li>–ö–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–∏—Ö</li>
                        <li>–î–ª—è —à—É–º–æ–ø–æ–¥–∞–≤–ª–µ–Ω–Ω—è —Ç–∞ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è –∫–æ—Ä–∏—Å–Ω–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤</li>
                        <li>–í —Å–∏—Å—Ç–µ–º–∞—Ö –º–∞—à–∏–Ω–Ω–æ–≥–æ –Ω–∞–≤—á–∞–Ω–Ω—è –¥–ª—è –∑–º–µ–Ω—à–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä–Ω–æ—Å—Ç—ñ</li>
                    </ul>
                </div>
            </div>
            
            <div style="background: rgba(250, 204, 21, 0.1); padding: 15px; border-radius: 6px; margin-top: 20px; border-left: 3px solid #facc15;">
                <p style="margin: 0; font-style: italic; color: #cbd5e1;">
                    <strong>–í–∞–∂–ª–∏–≤–æ:</strong> –û–±–∏–¥–≤–∞ –ø—ñ–¥—Ö–æ–¥–∏ –º–∞—é—Ç—å —Å–≤–æ—é –Ω—ñ—à—É. –ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω—ñ –º–µ—Ç–æ–¥–∏ –¥–æ–º—ñ–Ω—É—é—Ç—å —É –ø–æ–±—É—Ç–æ–≤—ñ–π –µ–ª–µ–∫—Ç—Ä–æ–Ω—ñ—Ü—ñ —Ç–∞ –º–µ–¥—ñ–∞, 
                    —Ç–æ–¥—ñ —è–∫ –º–∞—Ç—Ä–∏—á–Ω—ñ –º–µ—Ç–æ–¥–∏ –∑–Ω–∞—Ö–æ–¥—è—Ç—å –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –≤ –Ω–∞—É–∫–æ–≤–∏—Ö –¥–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è—Ö —Ç–∞ —Å–ø–µ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –∑–∞–¥–∞—á–∞—Ö –æ–±—Ä–æ–±–∫–∏ —Å–∏–≥–Ω–∞–ª—ñ–≤. 
                    –°—É—á–∞—Å–Ω—ñ –≥—ñ–±—Ä–∏–¥–Ω—ñ –ø—ñ–¥—Ö–æ–¥–∏ —á–∞—Å—Ç–æ –ø–æ—î–¥–Ω—É—é—Ç—å –µ–ª–µ–º–µ–Ω—Ç–∏ –æ–±–æ—Ö –º–µ—Ç–æ–¥—ñ–≤ –¥–ª—è –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤.
                </p>
            </div>
        </div>



    </div>
</details>
	
	

    <!-- Shared Audio Controls -->
    <div class="audio-controls">
        <div class="btn-row">
            <label class="file-label">
                üìÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—É–¥—ñ–æ—Ñ–∞–π–ª
                <input type="file" id="fileInput" accept="audio/*">
            </label>
            <button id="btnMic">üé§ –ó–∞–ø–∏—Å–∞—Ç–∏ –∑ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞ (4 —Å–µ–∫)</button>
            <button id="btnPreset" style="background: var(--lossy-accent); color: #000;">üéπ –ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Ç–µ—Å—Ç–æ–≤–∏–π —Å–∏–≥–Ω–∞–ª</button>
        </div>
        <div id="audioStatus" class="status-text">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∞—É–¥—ñ–æ...</div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
        <button class="tab-btn active" data-tab="lossy">üéµ –ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è (Lossy)</button>
        <button class="tab-btn" data-tab="svd">üìä –ú–∞—Ç—Ä–∏—á–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è (SVD)</button>
    </div>

    <!-- Lossy Tab Content -->
    <div id="lossy-tab" class="tab-content active">
        <div class="container">
            <div class="panel">
                <div style="display:flex; justify-content:space-between; align-items: center;">
                    <h3>–ß–∞—Å—Ç–æ—Ç–Ω–∏–π –°–ø–µ–∫—Ç—Ä (FFT)</h3>
                    <div style="font-size: 0.8rem; color:#aaa">X: –ß–∞—Å—Ç–æ—Ç–∞ (Hz) | Y: –ì—É—á–Ω—ñ—Å—Ç—å (dB)</div>
                </div>
                
                <canvas id="cvSpectrum" height="250"></canvas>
                
                <div class="slider-container">
                    <span style="min-width: 80px; font-size: 0.9rem;">‚úÇÔ∏è –ü–æ—Ä—ñ–≥:</span>
                    <input type="range" id="slThreshold" min="0" max="100" value="10">
                    <span id="lblThreshold" style="min-width: 50px; text-align: right; font-weight: bold; color: var(--threshold);">10%</span>
                </div>

                <div class="options-container">
                    <label class="checkbox-label" title="–Ø–∫—â–æ —É–≤—ñ–º–∫–Ω–µ–Ω–æ, —Ç–∏—Ö—ñ –∑–≤—É–∫–∏ –ø–ª–∞–≤–Ω–æ –ø—Ä–∏–≥–ª—É—à—É—é—Ç—å—Å—è, –∞ –Ω–µ —Ä—ñ–∑–∫–æ –æ–±—Ä—ñ–∑–∞—é—Ç—å—Å—è">
                        <input type="checkbox" id="chkSoft"> –ú'—è–∫–∏–π –ø–æ—Ä—ñ–≥ (Soft)
                    </label>
                    <label class="checkbox-label" title="–Ø–∫—â–æ —É–≤—ñ–º–∫–Ω–µ–Ω–æ, –ø–æ—Ä—ñ–≥ –ø—ñ–¥–Ω—ñ–º–∞—î—Ç—å—Å—è –Ω–∞–≤–∫–æ–ª–æ –≥—É—á–Ω–∏—Ö –∑–≤—É–∫—ñ–≤ (–ø—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏–∫–∞)">
                        <input type="checkbox" id="chkMasking"> –ú–∞—Å–∫—É–≤–∞–Ω–Ω—è (Masking)
                    </label>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div style="color:#aaa; font-size:0.8rem">–í—Å—å–æ–≥–æ –≥–∞—Ä–º–æ–Ω—ñ–∫</div>
                        <span class="stat-val" id="valTotal">0</span>
                    </div>
                    <div class="stat-box">
                        <div style="color:var(--lossy-kept); font-size:0.8rem">–ó–±–µ—Ä–µ–∂–µ–Ω–æ (–≤ —Å–µ—Ä–µ–¥–Ω—å–æ–º—É)</div>
                        <span class="stat-val" id="valKept">0</span>
                    </div>
                    <div class="stat-box">
                        <div style="color:var(--lossy-accent); font-size:0.8rem">–°—Ç—É–ø—ñ–Ω—å —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è</div>
                        <span class="stat-val" id="valRatio">1.0x</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
                <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
                    <button class="btn-play" id="btnPlayOrig" style="background: var(--lossy-kept);">‚ñ∂ –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
                    <button class="btn-play-compressed" id="btnPlayComp" style="background: var(--lossy-accent); color: #000;">‚ñ∂ –°—Ç–∏—Å–Ω–µ–Ω–µ</button>
                </div>
                <canvas id="cvWave" height="100"></canvas>
                <p style="text-align: center; font-size: 0.85rem; color: #777; margin-top: 10px;">
                    –ó–µ–ª–µ–Ω–∞ –ª—ñ–Ω—ñ—è ‚Äî –æ—Ä–∏–≥—ñ–Ω–∞–ª. –ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∞ ‚Äî –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è —á–∞—Å—Ç–æ—Ç.
                </p>
            </div>
        </div>
    </div>

    <!-- SVD Tab Content -->
    <div id="svd-tab" class="tab-content">
        <div class="main-grid">
            <div class="panel">
                <div id="guide" class="step-guide"></div>

                <div id="theoryPanel" class="theory-block"></div>
                
                <button id="btnAction" style="background: var(--accent); color: #0f172a; border: none; font-weight: bold; margin-top: 10px; padding: 15px; width: 100%;">–î–∞–ª—ñ...</button>
                <div id="status" class="status-text"></div>

                <hr style="border:0; border-top:1px solid #334155; width:100%; margin:15px 0;">

                <div id="controls">
                    <div style="font-weight:bold; color:var(--accent); border-bottom:1px solid #334155; padding-bottom:5px;">–ú–µ—Ç–æ–¥ SVD:</div>
                    
                    <div class="slider-label">
                        <span>–†–∞–Ω–≥ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è (k)</span>
                        <span id="lblK" style="color:var(--accent); font-weight:bold; font-size: 1.1rem;">2</span>
                    </div>
                    <input type="range" id="sliderK" min="1" max="32" value="2">

                    <div class="slider-label">
                        <span>–†–æ–∑–º—ñ—Ä –±–ª–æ–∫—É (–∫–∞–¥—Ä—ñ–≤)</span>
                        <span id="lblBlock" style="color:#cbd5e1;">32</span>
                    </div>
                    <input type="range" id="sliderBlock" min="16" max="64" step="4" value="32">
                    
                    <div class="stat-box" style="background: #0f172a; padding: 10px; border-radius: 4px; margin-top: 10px; font-size: 0.85rem; border: 1px solid #334155; display: flex; flex-direction: column; gap: 4px;">
                        <div style="display:flex; justify-content:space-between;">
                            <span>–ó–º–µ–Ω—à–µ–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤:</span> <span id="valComp" style="color: var(--kept); font-weight: bold;">0%</span>
                        </div>
                        <div style="display:flex; justify-content:space-between;">
                            <span>–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ –ø–æ—Ö–∏–±–∫–∞:</span> <span id="valErr" style="color: var(--lost)">0%</span>
                        </div>
                    </div>

                    <div class="btn-row" style="margin-top: 10px;">
                        <button id="btnPlayOrigSvd" onclick="playSvd('orig')" style="background: var(--kept);">‚ñ∂ –í—Ö—ñ–¥ (11kHz)</button>
                        <button id="btnPlayRecSvd" onclick="playSvd('rec')" style="background: var(--accent);">‚ñ∂ SVD –†–µ–∑—É–ª—å—Ç–∞—Ç</button>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="overlay-label">–í—Ö—ñ–¥–Ω–∞ –°–ø–µ–∫—Ç—Ä–æ–≥—Ä–∞–º–∞ (Log-Scale)</div>
                    <canvas id="cvOrig" height="150"></canvas>
                </div>
                
                <div class="canvas-container">
                    <div class="overlay-label">–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è SVD</div>
                    <canvas id="cvRec" height="150"></canvas>
                </div>

                <div style="margin-top: 10px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <strong>–°–ø–µ–∫—Ç—Ä —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏—Ö —á–∏—Å–µ–ª ($\sigma_i$)</strong>
                        <span style="font-size: 0.8rem; color: #64748b;">–£—Å–µ—Ä–µ–¥–Ω–µ–Ω–æ –ø–æ –±–ª–æ–∫–∞–º</span>
                    </div>
                    <div style="position: relative; height: 120px; background: #000; border: 1px solid #334155; border-radius: 2px;">
                        <canvas id="cvScree" height="120"></canvas>
                    </div>
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 5px; display: flex; justify-content: space-between;">
                        <span><span style="color: var(--kept)">‚óº</span> –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è (–°–∏–≥–Ω–∞–ª)</span>
                        <span><span style="color: var(--lost)">‚óº</span> –í—ñ–¥–∫–∏–Ω—É—Ç–æ (–®—É–º)</span>
                    </div>
                </div>
            </div>
        </div>
		
    </div>

<script>
    // ==================== GLOBAL STATE ====================
    let sharedAudio = {
        buffer: null,
        sampleRate: 44100,
        data: null,
        duration: 0
    };
    
    let audioContext = null;
    let currentTab = 'lossy';
    
    // ==================== TAB MANAGEMENT ====================
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            btn.classList.add('active');
            currentTab = btn.dataset.tab;
            document.getElementById(`${currentTab}-tab`).classList.add('active');
            
            // Update SVD UI if needed
            if (currentTab === 'svd' && window.svdStep === 0 && sharedAudio.data) {
                setTimeout(() => svdLoadAudioFromShared(), 100);
            }
        });
    });
    
    // ==================== SHARED AUDIO HANDLING ====================
    async function initAudioContext() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        return audioContext;
    }
    
    document.getElementById('fileInput').addEventListener('change', async function(e) {
        if (!e.target.files[0]) return;
        
        await initAudioContext();
        const file = e.target.files[0];
        const arrayBuffer = await file.arrayBuffer();
        
        try {
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            processSharedAudio(audioBuffer);
        } catch (err) {
            document.getElementById('audioStatus').textContent = '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∞—É–¥—ñ–æ';
            console.error(err);
        }
    });
    
    document.getElementById('btnMic').addEventListener('click', async function() {
        await initAudioContext();
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            const chunks = [];
            
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            mediaRecorder.onstop = async () => {
                const blob = new Blob(chunks, { type: 'audio/webm' });
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                processSharedAudio(audioBuffer);
                stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorder.start();
            this.classList.add('recording');
            this.textContent = '‚è∫ –ó–∞–ø–∏—Å...';
            
            setTimeout(() => {
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    this.classList.remove('recording');
                    this.innerHTML = 'üé§ –ó–∞–ø–∏—Å–∞—Ç–∏ –∑ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞ (4 —Å–µ–∫)';
                }
            }, 4000);
            
        } catch (err) {
            alert('–î–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ');
            console.error(err);
        }
    });
    
    document.getElementById('btnPreset').addEventListener('click', async function() {
        await initAudioContext();
        
        // Generate test signal (similar to Lossy preset)
        const duration = 1.5;
        const sampleRate = 44100;
        const length = sampleRate * duration;
        const data = new Float32Array(length);
        
        for (let i = 0; i < length; i++) {
            let t = i / sampleRate;
            let env = 1 - (t / duration);
            let mod = Math.sin(2 * Math.PI * 110 * t) * 5;
            let carrier = Math.sin(2 * Math.PI * 220 * t + mod);
            let noise = (Math.random() - 0.5) * 0.05;
            data[i] = (carrier * 0.8 + noise) * env;
        }
        
        // Create AudioBuffer
        const buffer = audioContext.createBuffer(1, length, sampleRate);
        buffer.copyToChannel(data, 0);
        processSharedAudio(buffer);
    });
    
    function processSharedAudio(audioBuffer) {
        sharedAudio.buffer = audioBuffer;
        sharedAudio.sampleRate = audioBuffer.sampleRate;
        sharedAudio.duration = audioBuffer.duration;
        
        // Get mono channel data
        const channelData = audioBuffer.getChannelData(0);
        sharedAudio.data = channelData;
        
        document.getElementById('audioStatus').textContent = 
            `–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ: ${audioBuffer.duration.toFixed(2)} —Å–µ–∫, ${audioBuffer.sampleRate} –ì—Ü`;
        
        // Process for current tab
        if (currentTab === 'lossy') {
            lossyProcessInput(channelData);
        } else {
            svdLoadAudioFromShared();
        }
    }
    
    // ==================== LOSSY COMPRESSION SIMULATOR ====================
    const LOSSY = {
        fftSize: 4096,
        sampleRate: 44100,
        duration: 1.5,
        
        audioCtx: null,
        originalBuffer: null,
        recordedData: null,
        windowStart: 0,
        
        spectrumReal: [],
        spectrumImag: [],
        spectrumMag: [],
        maxMag: 0,
        
        compressedSignal: null
    };
    
    // FFT Library (from Lossy.html)
    const FFT = {
        reverseBits: function(x, n) {
            let result = 0;
            for (let i = 0; i < n; i++, x >>= 1) result = (result << 1) | (x & 1);
            return result;
        },
        transform: function(real, imag) {
            const n = real.length;
            const levels = Math.log2(n);
            for (let i = 0; i < n; i++) {
                const rev = this.reverseBits(i, levels);
                if (rev > i) {
                    [real[i], real[rev]] = [real[rev], real[i]];
                    [imag[i], imag[rev]] = [imag[rev], imag[i]];
                }
            }
            for (let size = 2; size <= n; size *= 2) {
                const half = size / 2;
                const step = 2 * Math.PI / size;
                for (let i = 0; i < n; i += size) {
                    for (let j = 0; j < half; j++) {
                        const k = i + j;
                        const t = k + half;
                        const angle = -j * step;
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);
                        const tr = real[t] * cos - imag[t] * sin;
                        const ti = real[t] * sin + imag[t] * cos;
                        real[t] = real[k] - tr;
                        imag[t] = imag[k] - ti;
                        real[k] += tr;
                        imag[k] += ti;
                    }
                }
            }
        },
        inverse: function(real, imag) {
            const n = real.length;
            for(let i=0; i<n; i++) imag[i] = -imag[i];
            this.transform(real, imag);
            for(let i=0; i<n; i++) {
                imag[i] = -imag[i];
                real[i] /= n;
                imag[i] /= n;
            }
        }
    };
    
    function lossyProcessInput(rawData) {
        LOSSY.recordedData = rawData;
        
        const center = Math.floor(rawData.length / 2);
        LOSSY.windowStart = Math.max(0, center - LOSSY.fftSize/2);
        
        const slice = rawData.slice(LOSSY.windowStart, LOSSY.windowStart + LOSSY.fftSize);
        const windowed = new Float32Array(LOSSY.fftSize);
        
        for(let i=0; i<LOSSY.fftSize; i++) {
            let val = (i < slice.length) ? slice[i] : 0;
            let win = 0.5 * (1 - Math.cos(2 * Math.PI * i / (LOSSY.fftSize - 1)));
            windowed[i] = val * win;
        }
        
        LOSSY.spectrumReal = new Float32Array(windowed);
        LOSSY.spectrumImag = new Float32Array(LOSSY.fftSize).fill(0);
        FFT.transform(LOSSY.spectrumReal, LOSSY.spectrumImag);
        
        LOSSY.spectrumMag = new Float32Array(LOSSY.fftSize / 2);
        LOSSY.maxMag = 0;
        
        for(let i=0; i<LOSSY.spectrumMag.length; i++) {
            let mag = Math.sqrt(LOSSY.spectrumReal[i]**2 + LOSSY.spectrumImag[i]**2);
            LOSSY.spectrumMag[i] = mag;
            if(mag > LOSSY.maxMag) LOSSY.maxMag = mag;
        }
        
        document.getElementById('btnPlayOrig').disabled = false;
        document.getElementById('btnPlayComp').disabled = false;
        lossyUpdateCompression();
    }
    
    function lossyCalculateMaskingThresholds(magnitudes, baseThreshold) {
        const thresholds = new Float32Array(magnitudes.length).fill(baseThreshold);
        const len = magnitudes.length;
        
        for (let i = 0; i < len; i++) {
            const mag = magnitudes[i];
            if (mag > baseThreshold) {
                const spread = Math.max(10, Math.floor(i * 0.15));
                for (let j = Math.max(0, i - spread); j <= Math.min(len - 1, i + spread); j++) {
                    if (i === j) continue;
                    const dist = Math.abs(i - j);
                    const normalizedDist = dist / spread;
                    const decay = Math.pow(0.1, normalizedDist);
                    const maskLevel = mag * decay * 0.8;
                    if (maskLevel > thresholds[j]) {
                        thresholds[j] = maskLevel;
                    }
                }
            }
        }
        return thresholds;
    }
    
    function lossyUpdateCompression() {
        if (!LOSSY.recordedData || !LOSSY.recordedData.length) return;
        
        const thresholdPercent = parseInt(document.getElementById('slThreshold').value);
        document.getElementById('lblThreshold').textContent = thresholdPercent + "%";
        
        const useSoft = document.getElementById('chkSoft').checked;
        const useMasking = document.getElementById('chkMasking').checked;
        
        const fullLength = LOSSY.recordedData.length;
        const processedData = new Float32Array(fullLength);
        const hopSize = LOSSY.fftSize / 2;
        
        const winFunc = new Float32Array(LOSSY.fftSize);
        for(let i=0; i<LOSSY.fftSize; i++) {
            winFunc[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (LOSSY.fftSize - 1)));
        }
        
        let totalBinsProcessed = 0;
        let keptBinsProcessed = 0;
        
        for (let offset = 0; offset <= fullLength - LOSSY.fftSize; offset += hopSize) {
            const chunkReal = new Float32Array(LOSSY.fftSize);
            const chunkImag = new Float32Array(LOSSY.fftSize);
            
            for (let i = 0; i < LOSSY.fftSize; i++) {
                chunkReal[i] = LOSSY.recordedData[offset + i] * winFunc[i];
            }
            
            FFT.transform(chunkReal, chunkImag);
            
            let localMax = 0;
            const mags = new Float32Array(LOSSY.fftSize);
            for (let i = 0; i < LOSSY.fftSize; i++) {
                let m = Math.sqrt(chunkReal[i]**2 + chunkImag[i]**2);
                mags[i] = m;
                if (m > localMax) localMax = m;
            }
            
            let currentThresholds = null;
            let scalarThreshold = 0;
            
            if (useMasking) {
                const base = localMax * (thresholdPercent / 400);
                currentThresholds = lossyCalculateMaskingThresholds(mags, base);
            } else {
                scalarThreshold = localMax * (thresholdPercent / 100);
            }
            
            for (let i = 0; i < LOSSY.fftSize; i++) {
                const mag = mags[i];
                const thresh = useMasking ? currentThresholds[i] : scalarThreshold;
                
                if (mag < thresh) {
                    chunkReal[i] = 0;
                    chunkImag[i] = 0;
                } else {
                    if (useSoft) {
                        const scale = (mag - thresh) / mag;
                        chunkReal[i] *= scale;
                        chunkImag[i] *= scale;
                    }
                    if (i < LOSSY.fftSize / 2 && mags[i] > 1e-5) keptBinsProcessed++;
                }
            }
            totalBinsProcessed += (LOSSY.fftSize / 2);
            
            FFT.inverse(chunkReal, chunkImag);
            
            for (let i = 0; i < LOSSY.fftSize; i++) {
                processedData[offset + i] += chunkReal[i];
            }
        }
        
        LOSSY.compressedSignal = processedData;
        
        document.getElementById('valTotal').textContent = Math.floor(totalBinsProcessed / (fullLength/hopSize));
        document.getElementById('valKept').textContent = Math.floor(keptBinsProcessed / (fullLength/hopSize))+1;
        
        let ratio = (keptBinsProcessed > 0) ? (totalBinsProcessed / keptBinsProcessed).toFixed(1) : "MAX";
        document.getElementById('valRatio').textContent = ratio + ":1";
        document.getElementById('valRatio').style.color = (parseFloat(ratio) > 10 || ratio === "MAX") ? '#ff9800' : '#4caf50';
        
        let visThresholdData = null;
        if (useMasking) {
            const base = LOSSY.maxMag * (thresholdPercent / 400);
            visThresholdData = lossyCalculateMaskingThresholds(LOSSY.spectrumMag, base);
        } else {
            visThresholdData = (thresholdPercent / 100) * LOSSY.maxMag;
        }
        
        lossyDrawVisuals(visThresholdData);
    }
    
    function lossyDrawVisuals(thresholdData) {
        lossyDrawSpectrum(thresholdData);
        lossyDrawWaveforms();
    }
    
    function lossyDrawSpectrum(thresholdData) {
        const cv = document.getElementById('cvSpectrum');
        const ctx = cv.getContext('2d');
        const w = cv.width = cv.clientWidth;
        const h = cv.height = cv.clientHeight;
        
        ctx.clearRect(0, 0, w, h);
        
        const minFreq = 20;
        const maxFreq = LOSSY.sampleRate / 2;
        const freqPerBin = LOSSY.sampleRate / LOSSY.fftSize;
        
        const getFreqAtX = (x) => {
            const t = x / w;
            return minFreq * Math.pow(maxFreq / minFreq, t);
        };
        
        const getXAtFreq = (f) => {
            return (Math.log(f / minFreq) / Math.log(maxFreq / minFreq)) * w;
        };
        
        ctx.strokeStyle = '#333';
        ctx.fillStyle = '#555';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.lineWidth = 1;
        
        [100, 1000, 10000].forEach(f => {
            const x = getXAtFreq(f);
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
            ctx.fillText(f >= 1000 ? (f/1000)+'k' : f, x, h - 5);
        });
        
        ctx.strokeStyle = '#00bcd4';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        
        const isArrayThreshold = (thresholdData instanceof Float32Array || Array.isArray(thresholdData));
        
        if (isArrayThreshold) {
            let started = false;
            for (let x = 0; x < w; x++) {
                const f = getFreqAtX(x);
                const binIndex = Math.floor(f / freqPerBin);
                if(binIndex < thresholdData.length) {
                    const thVal = thresholdData[binIndex];
                    let thY = h - (thVal / LOSSY.maxMag * h * 0.9);
                    if(thY < 0) thY = 0;
                    
                    if(!started) { ctx.moveTo(x, thY); started = true; }
                    else { ctx.lineTo(x, thY); }
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#00bcd4';
            ctx.textAlign = 'left';
            ctx.fillText("–ü–æ—Ä—ñ–≥ (–ú–∞—Å–∫—É–≤–∞–Ω–Ω—è)", 5, 15);
        } else {
            const threshold = thresholdData;
            const thY = h - (threshold / LOSSY.maxMag * h * 0.9);
            if(threshold > 0) {
                ctx.moveTo(0, thY);
                ctx.lineTo(w, thY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#00bcd4';
                ctx.textAlign = 'left';
                ctx.fillText("–ü–æ—Ä—ñ–≥", 5, thY - 5);
            }
        }
        
        for (let x = 0; x < w; x++) {
            const fStart = getFreqAtX(x);
            const fEnd = getFreqAtX(x + 1);
            let iStart = Math.floor(fStart / freqPerBin);
            let iEnd = Math.ceil(fEnd / freqPerBin);
            
            if (iStart < 0) iStart = 0;
            if (iEnd >= LOSSY.spectrumMag.length) iEnd = LOSSY.spectrumMag.length - 1;
            if (iEnd < iStart) iEnd = iStart;
            
            let val = 0;
            let binIndexForThreshold = iStart;
            
            for (let i = iStart; i <= iEnd; i++) {
                if (LOSSY.spectrumMag[i] > val) {
                    val = LOSSY.spectrumMag[i];
                    binIndexForThreshold = i;
                }
            }
            
            let currentThreshVal = 0;
            if(isArrayThreshold) {
                if(binIndexForThreshold < thresholdData.length) currentThreshVal = thresholdData[binIndexForThreshold];
            } else {
                currentThreshVal = thresholdData;
            }
            
            const heightNorm = Math.min(1, val / (LOSSY.maxMag || 1));
            const barH = heightNorm * h * 0.9;
            const y = h - barH;
            
            if (val >= currentThreshVal) {
                ctx.fillStyle = '#4caf50';
            } else {
                ctx.fillStyle = '#222';
            }
            
            ctx.fillRect(x, y, 1, barH);
        }
    }
    
    function lossyDrawWaveforms() {
        if (!LOSSY.recordedData || !LOSSY.compressedSignal) return;
        
        const cv = document.getElementById('cvWave');
        const ctx = cv.getContext('2d');
        const w = cv.width = cv.clientWidth;
        const h = cv.height = cv.clientHeight;
        const cy = h/2;
        
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
        for(let i=0; i<w; i++) {
            let idxInWindow = Math.floor((i/w) * LOSSY.fftSize);
            let globalIdx = LOSSY.windowStart + idxInWindow;
            
            if (globalIdx < LOSSY.recordedData.length) {
                let val = LOSSY.recordedData[globalIdx] * 2;
                if(i===0) ctx.moveTo(i, cy - val*50);
                else ctx.lineTo(i, cy - val*50);
            }
        }
        ctx.stroke();
        
        ctx.beginPath();
        ctx.strokeStyle = '#ff9800';
        for(let i=0; i<w; i++) {
            let idxInWindow = Math.floor((i/w) * LOSSY.fftSize);
            let globalIdx = LOSSY.windowStart + idxInWindow;
            
            if (globalIdx < LOSSY.compressedSignal.length) {
                let val = LOSSY.compressedSignal[globalIdx] * 2;
                if(i===0) ctx.moveTo(i, cy - val*50);
                else ctx.lineTo(i, cy - val*50);
            }
        }
        ctx.stroke();
    }
    
    function lossyPlayBuffer(bufferData) {
        if(!audioContext) return;
        if(audioContext.state === 'suspended') audioContext.resume();
        
        const src = audioContext.createBufferSource();
        const buf = audioContext.createBuffer(1, bufferData.length, LOSSY.sampleRate);
        buf.getChannelData(0).set(bufferData);
        src.buffer = buf;
        
        const gain = audioContext.createGain();
        gain.gain.value = 0.5;
        
        src.connect(gain);
        gain.connect(audioContext.destination);
        src.start();
    }
    
    document.getElementById('btnPlayOrig').addEventListener('click', () => {
        if (LOSSY.recordedData) lossyPlayBuffer(LOSSY.recordedData);
    });
    
    document.getElementById('btnPlayComp').addEventListener('click', () => {
        if (LOSSY.compressedSignal) lossyPlayBuffer(LOSSY.compressedSignal);
    });
    
    document.getElementById('slThreshold').addEventListener('input', lossyUpdateCompression);
    document.getElementById('chkSoft').addEventListener('change', lossyUpdateCompression);
    document.getElementById('chkMasking').addEventListener('change', lossyUpdateCompression);
    
    // ==================== SVD SIMULATOR ====================
    const SVD = {
        rate: 11025,
        fft: 512,
        hop: 128,
        dur: 5.0,
        
        rawSig: null,
        stft: null,
        step: 0,
        globalAvgS: [],
        currentBlockSize: 32
    };
    
    const STEPS = [
        {
            t: "1. –í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ",
            d: "–ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–∞–π–ª. –ú–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —á–∞—Å—Ç–æ—Ç—É 11 –∫–ì—Ü.",
            b: "–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...",
            theory: `
                <div class="theory-header">–î–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü—ñ—è</div>
                –°–∏–≥–Ω–∞–ª x[n] –¥–∏—Å–∫—Ä–µ—Ç–∏–∑—É—î—Ç—å—Å—è –∑ —á–∞—Å—Ç–æ—Ç–æ—é 11025 –ì—Ü (—Ç–µ–ª–µ—Ñ–æ–Ω–Ω–∞ —è–∫—ñ—Å—Ç—å).
                –¶–µ –º–∞—Å–∏–≤ –¥—ñ–π—Å–Ω–∏—Ö —á–∏—Å–µ–ª (float32).
            `
        },
        {
            t: "2. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑",
            d: "–ë—É–¥—É—î–º–æ STFT –º–∞—Ç—Ä–∏—Ü—é. SVD –ø—Ä–∞—Ü—é—î —Å–∞–º–µ –∑ –Ω–µ—é.",
            b: "üöÄ –ê–Ω–∞–ª—ñ–∑ (STFT)",
            f: svdDoAnalysis,
            theory: `
                <div class="theory-header">–í—ñ–∫–Ω–æ –•–µ–º–º—ñ–Ω–≥–∞</div>
                $$ w[n] = 0.54 - 0.46 \\cos\\left(\\frac{2\\pi n}{N-1}\\right) $$
                
                <div class="theory-header">–ö–æ—Ä–æ—Ç–∫–æ—á–∞—Å–Ω–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –§—É—Ä'—î</div>
                $$ X[k, m] = \\sum_{n=0}^{N-1} x[n+mH] \\cdot w[n] \cdot e^{-j\\frac{2\\pi}{N}kn} $$
                –ú–∞—Ç—Ä–∏—Ü—è $A$ —Å–∫–ª–∞–¥–∞—î—Ç—å—Å—è –∑ –ª–æ–≥–∞—Ä–∏—Ñ–º—ñ–≤ –º–∞–≥–Ω—ñ—Ç—É–¥ $|X|$.
            `
        },
        {
            t: "3. –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –º–µ—Ç–æ–¥—ñ–≤",
            d: "–ü–æ—Ä—ñ–≤–Ω—è–π—Ç–µ –¥–≤–∞ –ø—ñ–¥—Ö–æ–¥–∏. SVD –¥–∞—î '–º–µ—Ç–∞–ª–µ–≤–∏–π' –∑–≤—É–∫ —á–µ—Ä–µ–∑ –Ω–∏–∑—å–∫–∏–π —Ä–∞–Ω–≥.",
            b: "üîÑ –ü–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É",
            f: svdReset,
            theory: `
                <div class="theory-header"> SVD (Low-Rank)</div>
                –ú–∏ –Ω–∞–±–ª–∏–∂–∞—î–º–æ –∫–æ–∂–µ–Ω –±–ª–æ–∫ –º–∞—Ç—Ä–∏—Ü—ñ —Å—É–º–æ—é $k$ –º–∞—Ç—Ä–∏—Ü—å —Ä–∞–Ω–≥—É 1:
                $$ A_{block} \\approx \\sum_{i=1}^{k} \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^T $$
                
                <div class="theory-header">–°—Ç—É–ø—ñ–Ω—å —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è SVD</div>
                $$ C = \\left( 1 - \\frac{N_{bl} \\cdot k \\cdot (1 + M + N_{w})}{M \\cdot N_{tot}} \\right) \\times 100\% $$
				
				    <span class="symbol">$N_{bl}$</span>
    <span><b>–ö—ñ–ª—å–∫—ñ—Å—Ç—å –±–ª–æ–∫—ñ–≤</b> (Number of Blocks). –ù–∞ —Å–∫—ñ–ª—å–∫–∏ —à–º–∞—Ç–∫—ñ–≤ –º–∏ "–ø–æ—Ä—ñ–∑–∞–ª–∏" –∞—É–¥—ñ–æ.</span>
</div>

<div class="math-row">
    <span class="symbol">$k$</span>
    <span><b>–†–∞–Ω–≥</b> (Rank). –ö—ñ–ª—å–∫—ñ—Å—Ç—å "—à–∞—Ä—ñ–≤" (–≤–µ–∫—Ç–æ—Ä—ñ–≤), —è–∫—ñ –º–∏ –∑–∞–ª–∏—à–∏–ª–∏. –¶–µ –Ω–∞—à —Å–ª–∞–π–¥–µ—Ä —è–∫–æ—Å—Ç—ñ.</span>
</div>

<div class="math-row">
    <span class="symbol">$M$</span>
    <span><b>–ö—ñ–ª—å–∫—ñ—Å—Ç—å —á–∞—Å—Ç–æ—Ç</b> (Frequency Bins). –í–∏—Å–æ—Ç–∞ —Å–ø–µ–∫—Ç—Ä–æ–≥—Ä–∞–º–∏ (–∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å FFT, —Ç—É—Ç 257).</span>
</div>

<div class="math-row">
    <span class="symbol">$N_{w}$</span>
    <span><b>–®–∏—Ä–∏–Ω–∞ –±–ª–æ–∫—É</b> (Block Width). –°–∫—ñ–ª—å–∫–∏ –∫–∞–¥—Ä—ñ–≤ —á–∞—Å—É –≤ –æ–¥–Ω–æ–º—É –±–ª–æ—Ü—ñ (—Å–ª–∞–π–¥–µ—Ä 16..64).</span>
</div>

<div class="math-row">
    <span class="symbol">$N_{tot}$</span>
    <span><b>–ó–∞–≥–∞–ª—å–Ω–∞ –¥–æ–≤–∂–∏–Ω–∞</b> (Total Frames). –ü–æ–≤–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–∞–¥—Ä—ñ–≤ —á–∞—Å—É —É –≤—Å—å–æ–º—É —Ñ–∞–π–ª—ñ.</span>
</div>
				
				
				
				
            `
        }
    ];
    
    function svdUpdateUI() {
        const s = STEPS[SVD.step];
        document.getElementById('guide').innerHTML = `<span class="step-title">${s.t}</span>${s.d}`;
        document.getElementById('theoryPanel').innerHTML = s.theory;
        
        if(window.MathJax && window.MathJax.typesetPromise) {
            MathJax.typesetPromise([document.getElementById('theoryPanel')]);
        }
        
        const ctrls = document.getElementById('controls');
        if(SVD.step===2) ctrls.style.opacity = '1';
        else ctrls.style.opacity = '0.5';
        
        const btn = document.getElementById('btnAction');
        btn.textContent = s.b;
        btn.disabled = (SVD.step === 0);
        btn.onclick = s.f ? s.f : svdNextStep;
    }
    
    function svdNextStep() { 
        if(STEPS[SVD.step].f) STEPS[SVD.step].f(); 
        else SVD.step++; 
        svdUpdateUI();
    }
    
    async function svdLoadAudioFromShared() {
        if (!sharedAudio.data || !audioContext) return;
        
        try {
            const len = Math.floor(sharedAudio.duration * SVD.rate);
            const offline = new OfflineAudioContext(1, len, SVD.rate);
            const src = offline.createBufferSource();
            
            const resampledBuffer = await resampleAudio(sharedAudio.buffer, SVD.rate);
            src.buffer = resampledBuffer;
            
            src.connect(offline.destination);
            src.start();
            const rendered = await offline.startRendering();
            
            let data = rendered.getChannelData(0);
            if(data.length > SVD.rate * SVD.dur) {
                data = data.slice(0, Math.floor(SVD.rate * SVD.dur));
            }
            
            SVD.rawSig = data;
            document.getElementById('status').textContent = `–°–∏–≥–Ω–∞–ª: ${(data.length/SVD.rate).toFixed(1)}—Å @ 11–∫–ì—Ü`;
            
            SVD.step = 1;
            svdUpdateUI();
        } catch(e) {
            alert("–ü–æ–º–∏–ª–∫–∞ –∞—É–¥—ñ–æ: " + e);
        }
    }
    
    async function resampleAudio(audioBuffer, targetRate) {
        const sourceRate = audioBuffer.sampleRate;
        const length = audioBuffer.length * targetRate / sourceRate;
        const offlineCtx = new OfflineAudioContext(1, length, targetRate);
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(offlineCtx.destination);
        source.start();
        return await offlineCtx.startRendering();
    }
    
    function svdDoAnalysis() {
        document.getElementById('status').textContent = "–û–±—á–∏—Å–ª–µ–Ω–Ω—è STFT...";
        
        setTimeout(() => {
            const nFft = SVD.fft, hop = SVD.hop;
            const nFrames = Math.floor((SVD.rawSig.length - nFft) / hop);
            const nBins = nFft/2 + 1;
            
            const magLog = [];
            const phase = [];
            
            const win = new Float32Array(nFft);
            for(let i=0; i<nFft; i++) {
                win[i] = 0.54 - 0.46 * Math.cos(2*Math.PI*i/(nFft-1));
            }
            
            for(let i=0; i<nBins; i++) {
                magLog[i] = new Float32Array(nFrames);
                phase[i] = new Float32Array(nFrames);
            }
            
            const re = new Float32Array(nFft), im = new Float32Array(nFft);
            for(let f=0; f<nFrames; f++) {
                const start = f*hop;
                for(let i=0; i<nFft; i++) {
                    re[i] = SVD.rawSig[start+i]*win[i];
                    im[i] = 0;
                }
                svdSimpleFFT(re, im);
                
                for(let i=0; i<nBins; i++) {
                    const m = Math.sqrt(re[i]**2 + im[i]**2);
                    magLog[i][f] = Math.log(1 + 100 * m);
                    phase[i][f] = Math.atan2(im[i], re[i]);
                }
            }
            
            SVD.stft = { magLog, phase, nFrames, nBins };
            svdDrawSpectrogram('cvOrig', magLog);
            
            document.getElementById('btnPlayOrigSvd').disabled = false;
            document.getElementById('btnPlayRecSvd').disabled = false;
            document.getElementById('sliderK').max = SVD.currentBlockSize;
            
            SVD.step = 2;
            svdUpdateUI();
            svdOnBlockChange();
            document.getElementById('status').textContent = "–ì–æ—Ç–æ–≤–æ.";
        }, 50);
    }
    
    function svdOnKChange() {
        svdUpdateReconstruction(false);
    }
    
    function svdOnBlockChange() {
        SVD.currentBlockSize = parseInt(document.getElementById('sliderBlock').value);
        document.getElementById('lblBlock').textContent = SVD.currentBlockSize;
        document.getElementById('sliderK').max = SVD.currentBlockSize;
        svdUpdateReconstruction(true);
    }
    
    function svdUpdateReconstruction(recompute) {
        if(!SVD.stft) return;
        
        const k = parseInt(document.getElementById('sliderK').value);
        document.getElementById('lblK').textContent = k;
        
        const { magLog, nFrames, nBins } = SVD.stft;
        const blockSize = SVD.currentBlockSize;
        const nBlocks = Math.ceil(nFrames / blockSize);
        const recLog = new Array(nBins).fill(0).map(() => new Float32Array(nFrames));
        
        let totalEnergy = 0, errorEnergy = 0;
        let sumS = new Float32Array(blockSize).fill(0);
        
        const sizeRaw = nBins * nFrames;
        const sizeComp = nBlocks * k * (1 + nBins + blockSize);
        
        for(let b=0; b<nBlocks; b++) {
            const fStart = b * blockSize;
            const w = Math.min(blockSize, nFrames - fStart);
            if(w < 2) continue;
            
            const blockA = new Array(nBins).fill(0).map(() => new Float32Array(w));
            for(let i=0; i<nBins; i++) {
                for(let j=0; j<w; j++) {
                    blockA[i][j] = magLog[i][fStart + j];
                }
            }
            
            const { U, S, V } = svdSimpleSVD(blockA);
            
            for(let sIdx=0; sIdx<S.length; sIdx++) {
                if(sIdx < sumS.length) sumS[sIdx] += S[sIdx];
                totalEnergy += S[sIdx]*S[sIdx];
                if(sIdx >= k) errorEnergy += S[sIdx]*S[sIdx];
            }
            
            const effectiveK = Math.min(k, S.length);
            for(let i=0; i<nBins; i++) {
                for(let j=0; j<w; j++) {
                    let sum = 0;
                    for(let r=0; r<effectiveK; r++) {
                        sum += U[i][r] * S[r] * V[j][r];
                    }
                    recLog[i][fStart + j] = sum;
                }
            }
        }
        
        SVD.globalAvgS = sumS.map(val => val / nBlocks);
        const ratio = (1 - sizeComp/sizeRaw) * 100;
        document.getElementById('valComp').textContent = Math.max(0, ratio).toFixed(1) + "%";
        
        const rmse = Math.sqrt(errorEnergy / totalEnergy) * 100;
        document.getElementById('valErr').textContent = rmse.toFixed(1) + "%";
        
        SVD.stft.recLog = recLog;
        svdDrawSpectrogram('cvRec', recLog);
        svdDrawScree(k);
    }
    
    function svdDrawSpectrogram(id, mat) {
        const cv = document.getElementById(id);
        const ctx = cv.getContext('2d');
        const w = cv.width = cv.clientWidth;
        const h = cv.height = cv.clientHeight;
        const padL = 35, padB = 20, plotW = w - padL, plotH = h - padB;
        
        const rows = mat.length;
        const cols = mat[0].length;
        const img = ctx.createImageData(plotW, plotH);
        
        let maxVal = 0;
        for(let i=0; i<rows; i+=2) {
            for(let j=0; j<cols; j+=4) {
                if(mat[i][j] > maxVal) maxVal = mat[i][j];
            }
        }
        if(maxVal < 0.1) maxVal = 1;
        
        for(let y=0; y<plotH; y++) {
            const r = Math.floor(rows * (1 - y/plotH));
            if(r<0 || r>=rows) continue;
            
            for(let x=0; x<plotW; x++) {
                const c = Math.floor(cols * (x/plotW));
                if(c>=cols) continue;
                
                let val = Math.max(0, mat[r][c]);
                let n = Math.pow(val/maxVal, 0.7);
                const idx = (y*plotW + x)*4;
                img.data[idx] = n*255;
                img.data[idx+1] = n*n*200;
                img.data[idx+2] = n*n*n*150;
                img.data[idx+3] = 255;
            }
        }
        
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,w,h);
        ctx.putImageData(img, padL, 0);
        
        ctx.fillStyle = "#94a3b8";
        ctx.font = "10px monospace";
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        
        const nyquist = SVD.rate/2;
        for(let i=0; i<=4; i++) {
            const y = plotH * (1 - i/4);
            const f = (i/4 * nyquist / 1000).toFixed(1) + "k";
            ctx.fillText(f, padL-4, y);
            ctx.fillRect(padL-3, y, 3, 1);
        }
    }
    
    function svdDrawScree(k) {
        const cv = document.getElementById('cvScree');
        const ctx = cv.getContext('2d');
        const w = cv.width = cv.clientWidth;
        const h = cv.height = cv.clientHeight;
        
        ctx.clearRect(0,0,w,h);
        const data = SVD.globalAvgS;
        if(!data || data.length === 0) return;
        
        const len = data.length;
        const maxVal = data[0];
        const barW = w / len;
        
        for(let i=0; i<len; i++) {
            const barH = (data[i] / maxVal) * (h - 10);
            ctx.fillStyle = (i < k) ? '#10b981' : '#ef4444';
            ctx.fillRect(i * barW + 1, h - barH, barW - 2, barH);
        }
        
        const splitX = k * barW;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(splitX, 0);
        ctx.lineTo(splitX, h);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    function playSvd(type) {
        if(!SVD.stft || !audioContext) return;
        if(audioContext.state === 'suspended') audioContext.resume();
        
        const mat = (type==='orig') ? SVD.stft.magLog : SVD.stft.recLog;
        const { phase, nFrames, nBins } = SVD.stft;
        const nFft = SVD.fft, hop = SVD.hop;
        const out = new Float32Array(nFrames*hop + nFft);
        const re = new Float32Array(nFft), im = new Float32Array(nFft);
        
        for(let f=0; f<nFrames; f++) {
            for(let i=0; i<nBins; i++) {
                const mLog = mat[i][f];
                const mLin = (Math.exp(mLog) - 1)/100;
                const p = phase[i][f];
                re[i] = mLin*Math.cos(p);
                im[i] = mLin*Math.sin(p);
                if(i>0 && i<nBins-1) {
                    re[nFft-i] = re[i];
                    im[nFft-i] = -im[i];
                }
            }
            
            for(let i=0;i<nFft;i++) im[i] = -im[i];
            svdSimpleFFT(re, im);
            
            for(let i=0;i<nFft;i++) re[i] /= nFft;
            
            const pos = f*hop;
            for(let i=0; i<nFft; i++) {
                out[pos+i] += re[i];
            }
        }
        
        const b = audioContext.createBuffer(1, out.length, SVD.rate);
        b.getChannelData(0).set(out);
        const s = audioContext.createBufferSource();
        s.buffer = b;
        s.connect(audioContext.destination);
        s.start();
    }
    
    function svdReset() {
        SVD.step = 0;
        SVD.stft = null;
        SVD.rawSig = null;
        
        ['cvOrig','cvRec','cvScree'].forEach(id => {
            const cv = document.getElementById(id);
            cv.getContext('2d').clearRect(0,0,cv.width,cv.height);
        });
        
        svdUpdateUI();
    }
    
    function svdSimpleFFT(re, im) {
        const n = re.length;
        let j = 0;
        for(let i=0; i<n-1; i++) {
            if(i < j) {
                [re[i], re[j]] = [re[j], re[i]];
                [im[i], im[j]] = [im[j], im[i]];
            }
            let k = n >> 1;
            while(k <= j) {
                j -= k;
                k >>= 1;
            }
            j += k;
        }
        
        let step = 1;
        while(step < n) {
            const jump = step << 1;
            const delta = -Math.PI/step;
            const s = Math.sin(delta);
            const c = Math.cos(delta);
            let wr = 1, wi = 0;
            
            for(let k=0; k<step; k++) {
                for(let i=k; i<n; i+=jump) {
                    const oi = i + step;
                    const tr = wr*re[oi] - wi*im[oi];
                    const ti = wr*im[oi] + wi*re[oi];
                    re[oi] = re[i] - tr;
                    im[oi] = im[i] - ti;
                    re[i] += tr;
                    im[i] += ti;
                }
                let t = wr;
                wr = t*c - wi*s;
                wi = t*s + wi*c;
            }
            step = jump;
        }
    }
    
    function svdSimpleSVD(A) {
        const m = A.length, n = A[0].length;
        const dim = n;
        const C = new Array(dim).fill(0).map(() => new Float32Array(dim));
        
        for(let i=0; i<n; i++) {
            for(let j=i; j<n; j++) {
                let s = 0;
                for(let k=0; k<m; k++) s += A[k][i] * A[k][j];
                C[i][j] = s;
                C[j][i] = s;
            }
        }
        
        let V = new Array(dim).fill(0).map((_,i) => {
            let r = new Float32Array(dim);
            r[i] = 1;
            return r;
        });
        
        for(let it=0; it<20; it++) {
            let max = 0, p = 0, q = 0;
            for(let i=0; i<dim-1; i++) {
                for(let j=i+1; j<dim; j++) {
                    if(Math.abs(C[i][j]) > max) {
                        max = Math.abs(C[i][j]);
                        p = i;
                        q = j;
                    }
                }
            }
            
            if(max < 1e-5) break;
            
            let th = 0.5 * Math.atan2(2*C[p][q], C[q][q] - C[p][p]);
            let c = Math.cos(th), s = Math.sin(th);
            let cpp = C[p][p], cqq = C[q][q], cpq = C[p][q];
            
            C[p][p] = c*c*cpp - 2*s*c*cpq + s*s*cqq;
            C[q][q] = s*s*cpp + 2*s*c*cpq + c*c*cqq;
            C[p][q] = 0;
            C[q][p] = 0;
            
            for(let i=0; i<dim; i++) {
                if(i !== p && i !== q) {
                    let cip = C[i][p], ciq = C[i][q];
                    C[i][p] = c*cip - s*ciq;
                    C[p][i] = C[i][p];
                    C[i][q] = s*cip + c*ciq;
                    C[q][i] = C[i][q];
                }
            }
            
            for(let i=0; i<dim; i++) {
                let vip = V[i][p], viq = V[i][q];
                V[i][p] = c*vip - s*viq;
                V[i][q] = s*vip + c*viq;
            }
        }
        
        let S = new Float32Array(dim);
        for(let i=0; i<dim; i++) {
            S[i] = Math.sqrt(Math.max(0, C[i][i]));
        }
        
        let idx = Array.from(S.keys()).sort((a,b) => S[b] - S[a]);
        let S_srt = new Float32Array(dim);
        let V_srt = new Array(dim).fill(0).map(() => new Float32Array(dim));
        
        for(let i=0; i<dim; i++) {
            S_srt[i] = S[idx[i]];
            for(let r=0; r<dim; r++) {
                V_srt[r][i] = V[r][idx[i]];
            }
        }
        
        let U_srt = new Array(m).fill(0).map(() => new Float32Array(dim));
        for(let i=0; i<m; i++) {
            for(let j=0; j<dim; j++) {
                if(S_srt[j] < 1e-6) continue;
                let sum = 0;
                for(let k=0; k<n; k++) {
                    sum += A[i][k] * V_srt[k][j];
                }
                U_srt[i][j] = sum / S_srt[j];
            }
        }
        
        return { U: U_srt, S: S_srt, V: V_srt };
    }
    
    // Initialize SVD UI
    document.getElementById('sliderK').addEventListener('input', svdOnKChange);
    document.getElementById('sliderBlock').addEventListener('input', svdOnBlockChange);
    document.getElementById('btnAction').addEventListener('click', svdNextStep);
    
    svdUpdateUI();
    
    // Initialize
    window.addEventListener('resize', () => {
        if(currentTab === 'lossy' && LOSSY.spectrumReal.length) {
            lossyUpdateCompression();
        }
    });
    
    // Auto-load audio when switching to SVD tab if available
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            if(currentTab === 'svd' && sharedAudio.data && SVD.step === 0) {
                setTimeout(() => svdLoadAudioFromShared(), 100);
            }
        });
    });
</script>
</body>
</html>